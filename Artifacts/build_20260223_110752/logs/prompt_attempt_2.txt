You are a Swift/SwiftUI developer. A previous attempt to complete a task failed.

TESTING & DEBUGGING REFERENCE:
For building, testing, and debugging iOS/macOS apps, reference this workflow guide:
/Users/emmanuel/Dev/Tools/Eocon-Foundation-V1/.Foundation/Docs/swiftDocs/Testing/XCODEBUILD_MCP_WORKFLOW.md

This guide covers:
- XcodeBuild MCP server tools for programmatic Xcode interaction
- Building for simulator, booting simulators, installing/launching apps
- UI automation: screenshots, accessibility hierarchy, tap simulation
- Debugging UI issues (button taps, gestures, navigation)

=== ORIGINAL TASK ===
I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

## Observations

T1–T6 are complete. The full backend is in place: \`AnalysisPipeline\`, \`TierResolver\`, \`DefaultPolicyScorer\`, \`ModelDownloadManager\`, \`HistoricalPolicies\`, and all SwiftData models. \`ContentView.swift\` is a placeholder. No UI views, ViewModels, Style structs, or \`ReportExporter\` exist yet. One data-model gap must be closed first: \`AnalyzedClause\` does not persist \`architectureScores\`, \`proxyDetection\`, or \`wasSafetyFallback\`, which are required by the drill-down chart views and export tier-usage stats.

## Approach

Build the UI layer in dependency order: close the data-model gap → navigation shell → screens in flow order → chart views → export → accessibility layer → macOS sidebar. Every view follows the MVVM-S pattern (\`@Observable\` ViewModel + pure-value Style struct). iOS uses \`NavigationStack\`; macOS uses \`NavigationSplitView\` gated with \`#if os(macOS)\`.

---

## Step 1 — Extend \`AnalyzedClause\` to Persist Chart Data

In \`file:app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift\`, add three new stored properties:

- \`architectureScoresData: Data\` — \`@Attribute(.externalStorage)\`, JSON-encoded \`ArchitectureScores\`; expose a computed \`architectureScores: ArchitectureScores\` getter/setter (same pattern as \`PolicyAnalysis.scoreResult\`)
- \`proxyTerms: [String]\` — stored directly (small array)
- \`expandsOutgroup: Bool\`
- \`wasSafetyFallback: Bool\` — \`true\` when \`TierResolver\` routed the clause to Tier 2 after a Tier 3 safety guardrail rejection

Update the \`init\` to accept these new parameters with sensible defaults so existing call sites compile without changes.

---

## Step 2 — Navigation Shell (\`ContentView.swift\`)

Replace the placeholder \`ContentView\` entirely.

- Add \`@AppStorage(\"hasCompletedOnboarding\") private var hasCompletedOnboarding: Bool = false\`
- **iOS path** (\`#if os(iOS)\`): \`NavigationStack\` — show \`WelcomeView\` when \`!hasCompletedOnboarding\`, otherwise \`PolicyHistoryView\` as the root
- **macOS path** (\`#if os(macOS)\`): \`NavigationSplitView\` with a sidebar (\`List\` of \`SidebarItem\` enum: \`.analyze\`, \`.training\`, \`.validation\`, \`.data\`) and a detail column that switches on the selected item; the Analyze item renders \`PolicyHistoryView\` in the sidebar column and a detail panel for \`ScoreCardView\`/charts
- Pass \`hasCompletedOnboarding\` binding into \`WelcomeView\`

---

## Step 3 — \`WelcomeView\` + \`WelcomeViewModel\` + \`WelcomeViewStyle\`

**Files:** \`Views/WelcomeView.swift\`, \`ViewModels/WelcomeViewModel.swift\`, \`Views/Style/WelcomeViewStyle.swift\`

**\`WelcomeViewModel: @Observable @MainActor\`**
- \`isDownloadStarted: Bool\`
- \`func getStarted(deps: AppDependencies, hasCompletedOnboarding: inout Bool)\` — calls \`deps.startTier2Download()\`, sets \`hasCompletedOnboarding = true\`

**\`WelcomeView\`**
- App icon, one-sentence description, \"Get Started\" button
- Inline download progress section (observe \`modelDownloadManager.state\`): \`ProgressView(value:)\` + percentage label + \"Pause\" button calling \`modelDownloadManager.cancelDownload()\`
- Retry button when \`modelDownloadManager.downloadError != nil\`
- Accessibility: \`.accessibilityHint\` on \"Get Started\" button; \`@AccessibilityFocusState\` to move focus to progress bar after tap

**\`WelcomeViewStyle\`**
- \`reduceMotion\`, \`dynamicTypeSize\` environment values
- \`static func progressAnimation(reduceMotion: Bool) -> Animation?\`

---

## Step 4 — \`PolicyHistoryView\` + \`PolicyHistoryViewModel\` + \`PolicyHistoryViewStyle\`

**Files:** \`Views/PolicyHistoryView.swift\`, \`ViewModels/PolicyHistoryViewModel.swift\`, \`Views/Style/PolicyHistoryViewStyle.swift\`

**\`PolicyHistoryViewModel: @Observable @MainActor\`**
- \`isShowingFilePicker: Bool\`
- \`selectedAnalysis: PolicyAnalysis?\`
- \`func delete(_ analysis: PolicyAnalysis, context: ModelContext)\` — calls \`context.delete(analysis)\`

**\`PolicyHistoryView\`**
- \`@Query(sort: \\PolicyAnalysis.dateAnalyzed, order: .reverse) var analyses: [PolicyAnalysis]\`
- \`@Environment(\\.modelContext) private var modelContext\`
- Navigation bar: title \"Analyses\", trailing \"+\" button sets \`viewModel.isShowingFilePicker = true\`
- MLX downloading banner: shown when \`modelDownloadManager.state\` is \`.downloading\` or \`.unavailable\` (and \`hasCompletedOnboarding\`); disappears when \`.available\`
- List rows: policy name, formatted date + clause count, COI badge
- \`.swipeActions\` (iOS) / \`.contextMenu { Button(\"Delete\", role: .destructive) }\` (macOS) calling \`viewModel.delete\`
- Empty state: \`ContentUnavailableView(\"No Analyses\", systemImage: \"doc.text.magnifyingglass\", description: Text(\"Analyze your first policy\"))\`
- \`.fileImporter(isPresented: \$viewModel.isShowingFilePicker, allowedContentTypes: [.pdf])\` → on success navigate to \`AnalysisView(pdfURL:)\`
- Tapping a row navigates to \`ScoreCardView(analysis:)\`

**\`PolicyHistoryViewStyle\`**
- \`static func coiBadgeColor(_ coi: Double, differentiateWithoutColor: Bool) -> (Color, String)\` — returns color + icon name
- COI severity thresholds: \`coi ≥ 0.6\` → red/\"exclamationmark.triangle\", \`0.3..<0.6\` → orange/\"minus.circle\", \`< 0.3\` → green/\"checkmark.shield\"

---

## Step 5 — \`AnalysisViewModel\` + \`AnalysisView\` + \`AnalysisViewStyle\`

**Files:** \`ViewModels/AnalysisViewModel.swift\`, \`Views/AnalysisView.swift\`, \`Views/Style/AnalysisViewStyle.swift\`

**\`AnalysisViewModel: @Observable @MainActor\`**
- Properties: \`stage: String\`, \`coiValue: Double\`, \`partialScores: ScoreResult\`, \`clauseIndex: Int\`, \`totalClauses: Int\`, \`isComplete: Bool\`, \`error: Error?\`, \`finalAnalysis: PolicyAnalysis?\`, \`classifiedClauses: [TierClassification]\`
- \`func startAnalysis(pdfURL: URL, deps: AppDependencies, context: ModelContext)\` — calls \`deps.makeAnalysisPipeline()\`, iterates \`AsyncStream<AnalysisProgress>\`:
  - \`.extracting\` → \`stage = \"Extracting text…\"\`
  - \`.classifying(clauseIndex:total:partialScores:)\` → update \`stage\`, \`clauseIndex\`, \`totalClauses\`, \`coiValue\`, \`partialScores\`; append to \`classifiedClauses\`
  - \`.complete(scoreResult)\` → build \`PolicyAnalysis\` + \`[AnalyzedClause]\` (populating \`architectureScores\`, \`proxyTerms\`, \`expandsOutgroup\`, \`wasSafetyFallback\` from \`TierClassification\`), \`context.insert\`, set \`finalAnalysis\`, \`isComplete = true\`
  - \`.failed(error)\` → set \`error\`
- \`func cancel()\` — cancels the pipeline task

**\`AnalysisView\`**
- Receives \`pdfURL: URL\`
- Filename in nav bar title
- Tier availability banner (same as \`PolicyHistoryView\`)
- Stage label
- COI gauge: circular \`Canvas\` or \`ZStack\` with \`Circle\` stroke arcs; animates from 0 to \`viewModel.coiValue\`
- Clause counter + \`ProgressView(value: Double(clauseIndex) / Double(max(totalClauses, 1)))\`
- Sub-score rows (DIS, ADS, EIS, CIS, OES): show value if \`clauseIndex > 0\`, else \"—\"; label \"Preliminary\" until \`isComplete\`
- On \`isComplete\`: show \"View Full Results\" \`Button\` + auto-navigate after 1 second via \`Task { try await Task.sleep(for: .seconds(1)); navigate() }\`
- Error banner with \"Go Back\" button
- \`.onAppear { viewModel.startAnalysis(pdfURL:deps:context:) }\`
- \`@AccessibilityFocusState\` — move focus to COI gauge when \`isComplete\` becomes \`true\`

**\`AnalysisViewStyle\`**
- \`static func gaugeAnimation(reduceMotion: Bool) -> Animation?\` — \`nil\` when \`reduceMotion\`, else \`.spring(duration: 0.6)\`
- \`static func scoreColor(_ score: Double, differentiateWithoutColor: Bool) -> (Color, String)\`

---

## Step 6 — \`ScoreCardView\` + \`ScoreCardViewModel\` + \`ScoreCardViewStyle\`

**Files:** \`ViewModels/ScoreCardViewModel.swift\`, \`Views/ScoreCardView.swift\`, \`Views/Style/ScoreCardViewStyle.swift\`

**\`ScoreCardViewModel: @Observable @MainActor\`**
- \`analysis: PolicyAnalysis\`
- \`isShowingExport: Bool\`
- \`interpretation: String\` — computed from \`analysis.scoreResult.coi\` (e.g., \"Highly Oppressive\" ≥ 0.6, \"Moderately Oppressive\" 0.3–0.6, \"Low Oppression\" < 0.3, \"Liberatory\" < 0)

**\`ScoreCardView\`**
- Large COI gauge (same \`Canvas\`/\`ZStack\` arc as \`AnalysisView\` but static/final)
- Interpretation label below gauge
- 5 \`NavigationLink\` rows: DIS → \`BenefitHierarchyView\`, ADS → \`ArchitectureRadarView\`, EIS → \`EliteInterestDetailView\`, CIS → \`CompoundingTrajectoryView\`, OES → \`OutgroupExpansionView\`
- \"Historical Comparison\" \`NavigationLink\` → \`HistoricalComparisonView\`
- Toolbar: \"Export\" button → \`.sheet(isPresented: \$viewModel.isShowingExport) { ExportView(analysis:) }\`
- Accessibility: \`.accessibilityElement(children: .combine)\` on gauge block; \`.accessibilityLabel(\"Composite Oppression Index\")\`; \`.accessibilityValue(\"\\(coi, format: .number.precision(.fractionLength(2))), \\(interpretation)\")\`; \`.accessibilityCustomContent\` for each sub-score; \`speechAdjustedPitch\`; custom \"Scores\" rotor; \`.accessibilitySortPriority\` ordering

**\`ScoreCardViewStyle\`**
- \`static func scoreRevealAnimation(reduceMotion: Bool) -> Animation?\`
- \`static func scoreColor(_ score: Double, differentiateWithoutColor: Bool) -> (Color, String)\`
- \`static func backgroundMaterial(reduceTransparency: Bool) -> Material\`
- \`static func scoreFont(dynamicTypeSize: DynamicTypeSize, legibilityWeight: LegibilityWeight?) -> Font\`

---

## Step 7 — Chart Views

Each chart view has a corresponding ViewModel and Style struct. Create under \`Views/Charts/\` and \`ViewModels/Charts/\`.

### \`BenefitHierarchyView\`
- Swift Charts \`BarMark\` stacked by \`TargetGroup\` (Elite / InGroupNonElite / Outgroup)
- Data: aggregate benefit/burden counts from \`analysis.clauses\` grouped by \`targetGroup\` and \`effectDirection\`
- \`BenefitChartDescriptor: AXChartDescriptorRepresentable\` — \`AXCategoricalDataAxisDescriptor\` for groups, \`AXNumericDataAxisDescriptor\` for percentage
- Pattern fills (\`.foregroundStyle(by:)\` + custom \`ChartSymbolShape\`) when \`differentiateWithoutColor\`
- \`.accessibilityLabel(\"Benefit Hierarchy Chart\")\`; \`.accessibilityValue\` with plain-English summary

### \`ArchitectureRadarView\`
- \`Canvas\` spider chart with 4 axes: AAR, SE, IJ, RSC
- Data: mean of each component across \`analysis.clauses\` (using the new \`architectureScores\` property on \`AnalyzedClause\`)
- \`.accessibilityRepresentation { VStack { ForEach(components) { Text(\"\\(\$0.name): \\(\$0.score, format: .percent)\") } } }\`
- \`.accessibilityLabel(\"Architecture Detection Radar Chart\")\`; \`.accessibilityHeading(.h2)\`
- \`.accessibilityAdjustableAction\` to swipe through the 4 component scores
- Distinct line patterns (dashed/dotted/solid) per axis when \`differentiateWithoutColor\`

### \`CompoundingTrajectoryView\`
- Swift Charts \`LineMark\` — X axis: year, Y axis: out-group capacity (0–1)
- Data: \`HistoricalPolicies.chain\` mapped to \`(year, capacity)\` points where capacity = \`1 - cumulativeCompoundingEffect\`; append current policy as the final point
- \`CompoundingChartDescriptor: AXChartDescriptorRepresentable\` — implement \`makeChartDescriptor()\` per Phase 7 plan
- \`.accessibilityLabel(\"Compounding Impact Trajectory\")\`; \`.accessibilityHint\`

### \`HistoricalComparisonView\`
- Swift Charts \`BarMark\` or \`PointMark\` — X axis: policy name, Y axis: COI
- Data: \`HistoricalPolicies.chain\` + current \`analysis\` as the highlighted bar
- \`.accessibilityElement(children: .contain)\`; per-baseline \`.accessibilityLabel\` + \`.accessibilityValue\`; current policy \`.accessibilityAddTraits(.isSelected)\`
- Custom \"Historical Policies\" rotor

### \`OutgroupExpansionView\`
- Three metric rows: expansion rate, proxy usage rate, proxy density (computed from \`analysis.clauses\`)
- Proxy term list: aggregate unique \`proxyTerms\` from all \`AnalyzedClause\` instances
- \`.accessibilityLabel(\"Outgroup Expansion Score\")\`

---

## Step 8 — \`ReportExporter\`

**File:** \`Export/ReportExporter.swift\`

\`nonisolated struct ReportExporter\`

**\`exportJSON(analysis: PolicyAnalysis) throws -> Data\`**
- Define \`PolicyAnalysisExport: Codable\` with all \`PolicyAnalysis\` fields + \`tierUsageStats: TierUsageStats\` + \`safetyFallbackCount: Int\`
- \`TierUsageStats: Codable\` — \`tier1Count: Int\`, \`tier2Count: Int\`, \`tier3Count: Int\`
- Compute counts by iterating \`analysis.clauses\` on \`tierUsed\`; \`safetyFallbackCount\` = count of clauses where \`wasSafetyFallback == true\`
- Encode with \`JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys])\`

**\`exportPDF(analysis: PolicyAnalysis) throws -> Data\`**
- On iOS (\`#if canImport(UIKit)\`): \`UIGraphicsPDFRenderer\` — render policy name, date, COI gauge summary, sub-score table, tier-usage stats, clause breakdown table
- On macOS (\`#if os(macOS)\`): \`NSGraphicsPDFContext\` equivalent
- Return \`Data\`

---

## Step 9 — \`ExportView\` + \`ExportViewModel\` + \`ExportViewStyle\`

**Files:** \`ViewModels/ExportViewModel.swift\`, \`Views/ExportView.swift\`, \`Views/Style/ExportViewStyle.swift\`

**\`ExportViewModel: @Observable @MainActor\`**
- \`isGenerating: Bool\`, \`error: Error?\`, \`exportedItem: ExportedItem?\` (wraps \`URL\` + \`UTType\`)
- \`func export(analysis: PolicyAnalysis, format: ExportFormat)\` — calls \`ReportExporter\`, writes to a temp file, sets \`exportedItem\`
- \`enum ExportFormat { case pdf, json }\`

**\`ExportView\`**
- Presented as \`.sheet\` (iOS) / \`.popover\` (macOS)
- Two format buttons: \"PDF Report\" and \"JSON Data\"
- \`ProgressView\` while \`isGenerating\`
- On success: \`ShareLink(item: exportedItem.url)\` or \`UIActivityViewController\` via \`UIViewControllerRepresentable\`
- Error banner with \"Try Again\" button
- Accessibility: \`.accessibilityLabel\` on format buttons; \`.accessibilityHint\` describing output format

---

## Step 10 — Accessibility Layer (applied across all views)

This is not a separate file but a pass over all views created above. Key items not yet covered in individual steps:

- **Heading hierarchy**: add \`.accessibilityHeading(.h1)\` to \"Policy Analysis Results\" in \`ScoreCardView\`; \`.accessibilityHeading(.h2)\` to each section title
- **\"Scores\" custom rotor** on \`ScoreCardView\`: \`AccessibilityRotorEntry\` for COI, DIS, ADS, EIS, CIS, OES
- **\"Clauses\" custom rotor** on a \`ClauseListView\` (optional detail view accessible from \`ScoreCardView\`): \"Oppressive Clauses\" and \"Liberatory Clauses\" rotors filtering by score threshold
- **\`accessibilitySortPriority\`**: \`ScoreCardView\` = 5, \`ArchitectureRadarView\` = 4, \`CompoundingTrajectoryView\` = 3, \`BenefitHierarchyView\` = 2, \`HistoricalComparisonView\` = 1
- **\`accessibilityLinkedGroup\`**: link each sub-score label in \`ScoreCardView\` to its corresponding chart view using a shared \`@Namespace\`
- **\`accessibilityShowsLargeContentViewer()\`** on the COI score number in \`ScoreCardView\`
- **\`speechSpellsOutCharacters(false)\`** + \`speechAdjustedPitch\` on score \`Text\` views

---

## Step 11 — macOS Sidebar Layout

In \`ContentView.swift\`, within the \`#if os(macOS)\` block:

- \`NavigationSplitView(sidebar:detail:)\` — sidebar renders a \`List\` bound to \`@State var selectedSidebarItem: SidebarItem?\`
- \`SidebarItem\` enum: \`.analyze\`, \`.training\` (placeholder), \`.validation\` (placeholder), \`.data\` (placeholder)
- Analyze detail: \`NavigationSplitView\` with \`PolicyHistoryView\` in the content column and \`ScoreCardView\`/chart views in the detail column (driven by \`viewModel.selectedAnalysis\`)
- Drill-down charts open in the detail column instead of pushing a new screen — \`ScoreCardView\` uses \`@State var selectedDrillDown: DrillDown?\` and renders the chart in a detail panel
- Training/Validation/Data items show \`ContentUnavailableView(\"Coming in T8\", ...)\` placeholders

---

## File Structure Summary

\`\`\`
app/decodingOppression/decodingOppression/
├── Models/
│   └── AnalyzedClause.swift          ← extend with architectureScores, proxyTerms, expandsOutgroup, wasSafetyFallback
├── Views/
│   ├── WelcomeView.swift
│   ├── PolicyHistoryView.swift
│   ├── AnalysisView.swift
│   ├── ScoreCardView.swift
│   ├── ExportView.swift
│   ├── Charts/
│   │   ├── BenefitHierarchyView.swift
│   │   ├── ArchitectureRadarView.swift
│   │   ├── CompoundingTrajectoryView.swift
│   │   ├── HistoricalComparisonView.swift
│   │   └── OutgroupExpansionView.swift
│   └── Style/
│       ├── WelcomeViewStyle.swift
│       ├── PolicyHistoryViewStyle.swift
│       ├── AnalysisViewStyle.swift
│       ├── ScoreCardViewStyle.swift
│       ├── ExportViewStyle.swift
│       └── Charts/
│           ├── BenefitHierarchyViewStyle.swift
│           ├── ArchitectureRadarViewStyle.swift
│           ├── CompoundingTrajectoryViewStyle.swift
│           ├── HistoricalComparisonViewStyle.swift
│           └── OutgroupExpansionViewStyle.swift
├── ViewModels/
│   ├── WelcomeViewModel.swift
│   ├── PolicyHistoryViewModel.swift
│   ├── AnalysisViewModel.swift
│   ├── ScoreCardViewModel.swift
│   ├── ExportViewModel.swift
│   └── Charts/
│       ├── BenefitHierarchyViewModel.swift
│       ├── ArchitectureRadarViewModel.swift
│       ├── CompoundingTrajectoryViewModel.swift
│       ├── HistoricalComparisonViewModel.swift
│       └── OutgroupExpansionViewModel.swift
├── Export/
│   └── ReportExporter.swift
└── ContentView.swift                  ← replace placeholder
\`\`\`

---

## Flow Coverage

\`\`\`mermaid
sequenceDiagram
    participant App as decodingOppressionApp
    participant CV as ContentView
    participant WV as WelcomeView
    participant PHV as PolicyHistoryView
    participant AV as AnalysisView
    participant SCV as ScoreCardView
    participant Charts as Chart Views
    participant EV as ExportView

    App->>CV: launch
    CV->>WV: !hasCompletedOnboarding
    WV->>CV: getStarted() → hasCompletedOnboarding=true
    CV->>PHV: root view
    PHV->>AV: fileImporter → pdfURL
    AV->>AV: AnalysisViewModel.startAnalysis()
    AV->>SCV: isComplete → navigate
    SCV->>Charts: tap sub-score row
    Charts-->>SCV: back
    SCV->>EV: tap Export
    EV-->>SCV: ShareLink / UIActivityViewController
\`\`\`
=== END ORIGINAL TASK ===

=== REFERENCE CONTEXT ===

=== SWIFT DOCUMENTATION ===

--- FILE: Navigation.md ---
# Navigation

**Enable people to move between different parts of your app’s view hierarchy within a scene.**


## Overview

Use navigation containers to provide structure to your app’s user interface, enabling people to easily move among the parts of your app.

![Image](navigation-hero)

For example, people can move forward and backward through a stack of views using a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack), or choose which view to display from a tab bar using a [doc://com.apple.SwiftUI/documentation/SwiftUI/TabView](https://developer.apple.com/documentation/SwiftUI/TabView).

Configure navigation containers by adding view modifiers like [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationSplitViewStyle(_:)) to the container. Use other modifiers on the views inside the container to affect the container’s behavior when showing that view. For example, you can use [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationTitle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationTitle(_:)) on a view to provide a toolbar title to display when showing that view.

## Topics

### Essentials

- [Understanding the navigation stack](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack) — Learn about the navigation stack, links, and how to manage navigation types in your app’s structure.
### Presenting views in columns

- [Bringing robust navigation structure to your SwiftUI app](https://developer.apple.com/documentation/swiftui/bringing-robust-navigation-structure-to-your-swiftui-app) — Use navigation links, stacks, destinations, and paths to provide a streamlined experience for all platforms, as well as behaviors such as deep linking and state restoration.
- [Migrating to new navigation types](https://developer.apple.com/documentation/swiftui/migrating-to-new-navigation-types) — Improve navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.
- [NavigationSplitView](https://developer.apple.com/documentation/swiftui/navigationsplitview) — A view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.
- [navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewstyle(_:)) — Sets the style for navigation split views within this view.
- [navigationSplitViewColumnWidth(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(_:)) — Sets a fixed, preferred width for the column containing this view.
- [navigationSplitViewColumnWidth(min:ideal:max:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(min:ideal:max:)) — Sets a flexible, preferred width for the column containing this view.
- [NavigationSplitViewVisibility](https://developer.apple.com/documentation/swiftui/navigationsplitviewvisibility) — The visibility of the leading columns in a navigation split view.
- [NavigationLink](https://developer.apple.com/documentation/swiftui/navigationlink) — A view that controls a navigation presentation.
### Stacking views in one column

- [NavigationStack](https://developer.apple.com/documentation/swiftui/navigationstack) — A view that displays a root view and enables you to present additional views over the root view.
- [NavigationPath](https://developer.apple.com/documentation/swiftui/navigationpath) — A type-erased list of data representing the content of a navigation stack.
- [navigationDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(for:destination:)) — Associates a destination view with a presented data type for use within a navigation stack.
- [navigationDestination(isPresented:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(ispresented:destination:)) — Associates a destination view with a binding that can be used to push the view onto a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack).
- [navigationDestination(item:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(item:destination:)) — Associates a destination view with a bound value for use within a navigation stack or navigation split view
### Managing column collapse

- [NavigationSplitViewColumn](https://developer.apple.com/documentation/swiftui/navigationsplitviewcolumn) — A view that represents a column in a navigation split view.
### Setting titles for navigation content

- [navigationTitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)) — Configures the view’s title for purposes of navigation, using a string binding.
- [navigationSubtitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)) — Configures the view’s subtitle for purposes of navigation.
- [navigationDocument(_:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:)) — Configures the view’s document for purposes of navigation.
- [navigationDocument(_:preview:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)) — Configures the view’s document for purposes of navigation.
### Configuring the navigation bar

- [navigationBarBackButtonHidden(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbarbackbuttonhidden(_:)) — Hides the navigation bar back button for the view.
- [navigationBarTitleDisplayMode(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbartitledisplaymode(_:)) — Configures the title display mode for this view.
- [NavigationBarItem](https://developer.apple.com/documentation/swiftui/navigationbaritem) — A configuration for a navigation bar that represents a view at the top of a navigation stack.
### Configuring the sidebar

- [sidebarRowSize](https://developer.apple.com/documentation/swiftui/environmentvalues/sidebarrowsize) — The current size of sidebar rows.
- [SidebarRowSize](https://developer.apple.com/documentation/swiftui/sidebarrowsize) — The standard sizes of sidebar rows.
### Presenting views in tabs

- [Enhancing your app’s content with tab navigation](https://developer.apple.com/documentation/swiftui/enhancing-your-app-content-with-tab-navigation) — Keep your app content front and center while providing quick access to navigation using the tab bar.
- [TabView](https://developer.apple.com/documentation/swiftui/tabview) — A view that switches between multiple child views using interactive user interface elements.
- [Tab](https://developer.apple.com/documentation/swiftui/tab) — The content for a tab and the tab’s associated tab item in a tab view.
- [TabRole](https://developer.apple.com/documentation/swiftui/tabrole) — A value that defines the purpose of the tab.
- [TabSection](https://developer.apple.com/documentation/swiftui/tabsection) — A container that you can use to add hierarchy within a tab view.
- [tabViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewstyle(_:)) — Sets the style for the tab view within the current environment.
### Configuring a tab bar

- [tabViewSidebarHeader(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarheader(content:)) — Adds a custom header to the sidebar of a tab view.
- [tabViewSidebarFooter(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarfooter(content:)) — Adds a custom footer to the sidebar of a tab view.
- [tabViewSidebarBottomBar(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarbottombar(content:)) — Adds a custom bottom bar to the sidebar of a tab view.
- [AdaptableTabBarPlacement](https://developer.apple.com/documentation/swiftui/adaptabletabbarplacement) — A placement for tabs in a tab view using the adaptable sidebar style.
- [tabBarPlacement](https://developer.apple.com/documentation/swiftui/environmentvalues/tabbarplacement) — The current placement of the tab bar.
- [TabBarPlacement](https://developer.apple.com/documentation/swiftui/tabbarplacement) — A placement for tabs in a tab view.
- [isTabBarShowingSections](https://developer.apple.com/documentation/swiftui/environmentvalues/istabbarshowingsections) — A Boolean value that determines whether a tab view shows the expanded contents of a tab section.
- [TabBarMinimizeBehavior](https://developer.apple.com/documentation/swiftui/tabbarminimizebehavior)
- [TabViewBottomAccessoryPlacement](https://developer.apple.com/documentation/swiftui/tabviewbottomaccessoryplacement) — A placement of the bottom accessory in a tab view. You can use this to adjust the content of the accessory view based on the placement.
### Configuring a tab

- [sectionActions(content:)](https://developer.apple.com/documentation/swiftui/view/sectionactions(content:)) — Adds custom actions to a section.
- [TabPlacement](https://developer.apple.com/documentation/swiftui/tabplacement) — A place that a tab can appear.
- [TabContentBuilder](https://developer.apple.com/documentation/swiftui/tabcontentbuilder) — A result builder that constructs tabs for a tab view that supports programmatic selection. This builder requires that all tabs in the tab view have the same selection type.
- [TabContent](https://developer.apple.com/documentation/swiftui/tabcontent) — A type that provides content for programmatically selectable tabs in a tab view.
- [AnyTabContent](https://developer.apple.com/documentation/swiftui/anytabcontent) — Type erased tab content.
### Enabling tab customization

- [tabViewCustomization(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewcustomization(_:)) — Specifies the customizations to apply to the sidebar representation of the tab view.
- [TabViewCustomization](https://developer.apple.com/documentation/swiftui/tabviewcustomization) — The customizations a person makes to an adaptable sidebar tab view.
- [TabCustomizationBehavior](https://developer.apple.com/documentation/swiftui/tabcustomizationbehavior) — The customization behavior of customizable tab view content.
### Displaying views in multiple panes

- [HSplitView](https://developer.apple.com/documentation/swiftui/hsplitview) — A layout container that arranges its children in a horizontal line and allows the user to resize them using dividers placed between them.
- [VSplitView](https://developer.apple.com/documentation/swiftui/vsplitview) — A layout container that arranges its children in a vertical line and allows the user to resize them using dividers placed between them.
### Deprecated Types

- [NavigationView](https://developer.apple.com/documentation/swiftui/navigationview) — A view for presenting a stack of views that represents a visible path in a navigation hierarchy.
- [tabItem(_:)](https://developer.apple.com/documentation/swiftui/view/tabitem(_:)) — Sets the tab bar item associated with this view.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation)*
--- END FILE ---

--- FILE: Adopting-SwiftData-for-a-Core-Data-app.md ---
# Adopting SwiftData for a Core Data app

**Persist data in your app intuitively with the Swift native persistence framework.**

## Availability

- **iOS** 26.0+
- **iPadOS** 26.0+
- **macOS** 26.0+
- **Xcode** 26.0+


## Overview

This sample project is designed to help you understand how to adopt SwiftData in an existing Core Data app. The SampleTrips app fetches and displays all upcoming trips from the store, and allows people to create or remove trips, and to add, update, or remove information from the itinerary for each trip. There are three versions of this app:

- A Core Data version that demonstrates Core Data best practices.

- A SwiftData version that shows the complete app conversion from Core Data to SwiftData.

- A coexistence version, where the sample app uses Core Data, and adds a widget extension that uses SwiftData. This version covers a scenario where you might want to adopt SwiftData incrementally, or for certain portions of your app.


### Configure the sample code project

Open the sample code project in Xcode. Before building it, do the following:

1. Set the developer team for all targets to your team so Xcode automatically manages the provisioning profile. For more information, see [https://help.apple.com/xcode/mac/current/#/dev23aab79b4](https://help.apple.com/xcode/mac/current/#/dev23aab79b4).

2. Replace the App Group container identifier — `group.com.example.apple-samplecode.SampleTrips` — with one specific to your team for the entire project. The identifier points to an App Group container that the app and widget use to share data. You can search for `group.com.example.apple-samplecode.SampleTrips` using the Find navigator in Xcode, and then change all of the occurrences. For more information, see [doc://com.apple.documentation/documentation/Xcode/configuring-app-groups](https://developer.apple.com/documentation/Xcode/configuring-app-groups).


### Adopt SwiftData

The SwiftData sample sets up the schema with Swift types that conform to the [doc://com.apple.documentation/documentation/SwiftData/PersistentModel](https://developer.apple.com/documentation/SwiftData/PersistentModel) protocol, which captures information about the app’s types, including properties and relationships. Each model file corresponds to an individual entity, with identical entity names, properties, and relationships as its Core Data counterpart.

Each model file in this sample uses the [doc://com.apple.documentation/documentation/SwiftData/Model()](https://developer.apple.com/documentation/SwiftData/Model()) macro to add necessary conformances for the `PersistentModel` and [doc://com.apple.documentation/documentation/Observation/Observable](https://developer.apple.com/documentation/Observation/Observable) protocols:

```swift
@Model class Trip {
    #Index<Trip>([\.name], [\.startDate], [\.endDate], [\.name, \.startDate, \.endDate])
    #Unique<Trip>([\.name, \.startDate, \.endDate])
    
    @Attribute(.preserveValueOnDeletion)
    var name: String
    var destination: String
    
    @Attribute(.preserveValueOnDeletion)
    var startDate: Date
    
    @Attribute(.preserveValueOnDeletion)
    var endDate: Date

    @Relationship(deleteRule: .cascade, inverse: \BucketListItem.trip)
    var bucketList: [BucketListItem] = [BucketListItem]()
    
    @Relationship(deleteRule: .cascade, inverse: \LivingAccommodation.trip)
    var livingAccommodation: LivingAccommodation?
    ...
```

Additionally, the app sets up the container using [doc://com.apple.documentation/documentation/SwiftData/ModelContainer](https://developer.apple.com/documentation/SwiftData/ModelContainer) to ensure that all views access the same `ModelContainer`.

```swift
.modelContainer(modelContainer)
```

Setting up the `ModelContainer` also creates and sets a default [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) in the environment. The app can access the `ModelContext` from any scene or view using an environment property.

```swift
@Environment(\.modelContext) private var modelContext
```


### Create a persisted data object

This app creates a new instance of a trip and inserts it into the [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) for persistence:

```swift
if newTripSegment == .personal {
    newTrip = PersonalTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, reason: reason)
} else if newTripSegment == .business {
    newTrip = BusinessTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, perdiem: perdiem)
} else {
    newTrip = Trip(name: name, destination: destination, startDate: startDate, endDate: endDate)
}
modelContext.insert(newTrip)
```


### Persist data

The app uses the SwiftData implicit save feature to persist data. This implicit save occurs on UI life cycle events and on a timer after the context changes. For more information about enabling autosave, see the [doc://com.apple.documentation/documentation/SwiftData/ModelContext/autosaveEnabled](https://developer.apple.com/documentation/SwiftData/ModelContext/autosaveEnabled) property.

The app calls [doc://com.apple.documentation/documentation/SwiftData/ModelContext/delete(_:)](https://developer.apple.com/documentation/SwiftData/ModelContext/delete(_:)) on the [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) with the instance to delete.

```swift
modelContext.delete(trip)
```


### Fetch persisted data

This sample app fetches the complete list of upcoming trips by wrapping an array of trips in a [doc://com.apple.documentation/documentation/SwiftData/Query](https://developer.apple.com/documentation/SwiftData/Query) macro, which fetches `Trip` objects from the container.

```swift
@Query(sort: \Trip.startDate, order: .forward)
var trips: [Trip]
```

This sample also fetches data by calling [doc://com.apple.documentation/documentation/SwiftData/ModelContext/fetch(_:)](https://developer.apple.com/documentation/SwiftData/ModelContext/fetch(_:)) on the [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) and passing in a [doc://com.apple.documentation/documentation/SwiftData/FetchDescriptor](https://developer.apple.com/documentation/SwiftData/FetchDescriptor) that specifies both the entity to retrieve data from as well as a corresponding [doc://com.apple.documentation/documentation/Foundation/Predicate](https://developer.apple.com/documentation/Foundation/Predicate) that specifies the conditions for the object to fetch.

```swift
var descriptor = FetchDescriptor<BucketListItem>()
let tripName = trip.name
descriptor.predicate = #Predicate { item in
    item.title.contains(searchText) && tripName == item.trip?.name
}
let filteredList = try? modelContext.fetch(descriptor)
```


### Inheritance

The SwiftData-Inheritance version of the app extends the `Trip` class into two distinct kinds of Trips, `PersonalTrip` and `BusinessTrip`, building on the basic `Trip` model to include more specialized properties for different kinds of Trips.

```swift
class PersonalTrip: Trip {...}
```

Both `PersonalTrip` and `BusinessTrip` inherit basic properties from their superclass, `Trip`, while defining their own specialized properties, as shown in the following code. For instance, `PersonalTrip`, has an additional property that describes the reason for the trip.

```swift
init(name: String, destination: String, startDate: Date = .now, endDate: Date = .distantFuture, reason: Reason) {
    self.reason = reason
    super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)
}
```


### Coexistence between Core Data and SwiftData

The coexistence version of the app has two persistence stacks: a Core Data persistence stack for the host app, and a SwiftData persistence stack for the widget extension. Both stacks write to the same store file.


### Namespace models

The namespaces in the coexistence sample use the pre-existing [doc://com.apple.documentation/documentation/CoreData/NSManagedObject](https://developer.apple.com/documentation/CoreData/NSManagedObject)-based entity subclasses so that they don’t conflict with the SwiftData classes. Note that this refers to the class name, not the entity name.

```swift
class CDTrip: NSManagedObject {...}
```

The sample then refers to the entity as `CDTrip` when accessing it in the Core Data host app. For instance, when adding a new `Trip`:

```swift
let newTrip = CDTrip(context: viewContext)
```


### Share the same store file

This sample ensures that both the Core Data and SwiftData persistent stacks write to the same store file by setting the persistent store URL for the container description:

```swift
if let description = container.persistentStoreDescriptions.first {
    description.url = url
    ...
}
```

Additionally, the coexistence sample must set the [doc://com.apple.documentation/documentation/CoreData/NSPersistentHistoryTrackingKey](https://developer.apple.com/documentation/CoreData/NSPersistentHistoryTrackingKey). Although SwiftData enables persistent history tracking automatically, Core Data does not, so the app enables persistent history manually.

```swift
description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
```

By default, SwiftData behaves in the following way when determining where it persists data:

- It persists data store to the app’s Application Support directory.

- This sample app uses App Groups to access shared containers and share data between the SwiftData widget extension and the Core Data host app. For an app that has the [doc://com.apple.documentation/documentation/BundleResources/Entitlements/com.apple.security.application-groups](https://developer.apple.com/documentation/BundleResources/Entitlements/com.apple.security.application-groups), it persists the data store to the root directory of the app group container. For apps that evolve from a version that doesn’t have any app group container to a version that has one, SwiftData copies the existing store to the app group container.

In this sample, the main app and widget share the same store via an app group container, and the store is located in the default location in the app group container. To ensure SwiftData accesses the same store, the main app and widget both share the [doc://com.apple.documentation/documentation/SwiftData/ModelContainer](https://developer.apple.com/documentation/SwiftData/ModelContainer).


### Detect relevant changes by consuming the SwiftData history

In the SwiftData version, people can confirm the living accommodation for the current trip by tapping the Accommodation button in the widget. The widget then updates `LivingAccommodation.isConfirmed` in SwiftData, and the main app, when entering the foreground, detects the changes and annotates the trip with a blue dot to indicate that it has unread changes.

There are multiple options for the main app to detect the changes from the widget:

1. Adding a key value pair to the shared `UserDefaults` ([doc://com.apple.documentation/documentation/Foundation/UserDefaults/init(suiteName:)](https://developer.apple.com/documentation/Foundation/UserDefaults/init(suiteName:)) for the widget and the main app to share the changes.

2. Adding a new attribute in `Trip` so the widget can mark the trip as “unread” when changing the living accommodation status.

3. Consuming the history of the store, which SwiftData generates by default, and picking up the relevant changes from there.

The first option introduces a new storage, and hence needs to maintain the consistency between SwiftData and the shared `UserDefaults`. The second option is easier to implement, but introduces and maintains a new attribute, which is redundant and consumes extra storage space; for real-world apps that manage more complicated changes and have larger data set, that may not be the favorite approach.

This sample chooses to detect the changes with the third option. To do so, it sets up a `HistoryDescriptor<DefaultHistoryTransaction>` with a history token (`DefaultHistoryToken`) and calls `fetchHistory(_:)` to retrieve the history transactions (`DefaultHistoryTransaction`) after the token, as shown in the following code:

```swift
private func findTransactions(after historyToken: DefaultHistoryToken?, author: String) -> [DefaultHistoryTransaction] {...}
```

After getting the transactions, it uses the following code to find the trips that have living accommodation changes:

```swift
private func findTrips(in transactions: [DefaultHistoryTransaction]) -> (Set<Trip>, DefaultHistoryToken?) {...}
```

---

*Source: [https://developer.apple.com/documentation/com.apple.coredata/documentation/CoreData/adopting-swiftdata-for-a-core-data-app](https://developer.apple.com/documentation/com.apple.coredata/documentation/CoreData/adopting-swiftdata-for-a-core-data-app)*
--- END FILE ---

--- FILE: SwiftData-Class-Inheritance.md ---
# Adopting Class Inheritance in Swift Data

## Overview

Swift Data supports class inheritance, allowing you to create hierarchical relationships between your model classes. This powerful feature enables you to build more flexible and specialized data models by creating subclasses that inherit properties and capabilities from a base class. Class inheritance in Swift Data follows the same principles as standard Swift inheritance but with additional considerations for persistence and querying.

Key concepts include:
- Base classes that define common properties and behaviors
- Specialized subclasses that extend functionality for specific use cases
- Type-based querying that can filter by specific model types
- Polymorphic relationships that work with different model types

## When to Use Inheritance in Swift Data

### Good Use Cases

- When you have a clear "IS-A" relationship between models (e.g., a `BusinessTrip` IS-A `Trip`)
- When models share fundamental properties but diverge as use cases become more specialized
- When your app needs to perform both deep searches (across all properties) and shallow searches (specific to subclass properties)
- When your data model naturally forms a hierarchical structure

```swift
// Example of a good inheritance relationship
@Model class Vehicle {
    var manufacturer: String
    var model: String
    var year: Int
}

@Model class Car: Vehicle {
    var numberOfDoors: Int
    var fuelType: FuelType
}

@Model class Motorcycle: Vehicle {
    var engineDisplacement: Int
    var hasABS: Bool
}
```

### When to Avoid Inheritance

- When specialized subclasses would only share a few common properties
- When your query strategy only focuses on specialized properties (shallow queries)
- When a Boolean flag or enumeration could represent the type distinction more efficiently
- When protocol conformance would be more appropriate for shared behavior

```swift
// Alternative to inheritance using an enum approach
@Model class Vehicle {
    var manufacturer: String
    var model: String
    var year: Int
    
    enum VehicleType: String, Codable {
        case car(numberOfDoors: Int, fuelType: FuelType)
        case motorcycle(engineDisplacement: Int, hasABS: Bool)
    }
    
    var type: VehicleType
}
```

## Designing Class Hierarchies

### Base Class Design

1. Identify common properties that all subclasses will share
2. Define relationships that apply to all subclasses
3. Use the `@Model` macro on the base class
4. Ensure the base class is declared as a `class` (not a struct)

```swift
import SwiftData

@Model class Trip {
    @Attribute(.preserveValueOnDeletion)
    var name: String
    var destination: String
    
    @Attribute(.preserveValueOnDeletion)
    var startDate: Date
    
    @Attribute(.preserveValueOnDeletion)
    var endDate: Date

    @Relationship(deleteRule: .cascade, inverse: \Accommodation.trip)
    var accommodation: Accommodation?
    
    init(name: String, destination: String, startDate: Date, endDate: Date) {
        self.name = name
        self.destination = destination
        self.startDate = startDate
        self.endDate = endDate
    }
}
```

### Subclass Design

1. Inherit from the base class using standard Swift inheritance syntax
2. Add the `@Model` macro to the subclass
3. Add specialized properties and relationships specific to the subclass
4. Override methods as needed
5. Consider availability annotations if needed

```swift
@Model class BusinessTrip: Trip {
    var purpose: String
    var expenseCode: String
    var perDiemRate: Double
    
    @Relationship(deleteRule: .cascade, inverse: \BusinessMeal.trip)
    var businessMeals: [BusinessMeal] = []
    
    @Relationship(deleteRule: .cascade, inverse: \MileageRecord.trip)
    var mileageRecords: [MileageRecord] = []
    
    init(name: String, destination: String, startDate: Date, endDate: Date,
         purpose: String, expenseCode: String, perDiemRate: Double) {
        self.purpose = purpose
        self.expenseCode = expenseCode
        self.perDiemRate = perDiemRate
        super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)
    }
}
```

```swift
@Model class PersonalTrip: Trip {
    enum Reason: String, CaseIterable, Codable, Identifiable {
        case family, vacation, wellness, other
        var id: Self { self }
    }
    
    var reason: Reason
    var notes: String?
    
    @Relationship(deleteRule: .cascade, inverse: \Attraction.trip)
    var attractions: [Attraction] = []
    
    init(name: String, destination: String, startDate: Date, endDate: Date,
         reason: Reason, notes: String? = nil) {
        self.reason = reason
        self.notes = notes
        super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)
    }
}
```

## Querying with Inheritance

### Basic Queries

You can query for all instances of a base class, which will include all subclass instances:

```swift
// Query for all trips (including BusinessTrip and PersonalTrip)
@Query(sort: \Trip.startDate)
var allTrips: [Trip]
```

### Type-Based Filtering

Filter by specific subclass types using the `is` operator in predicates:

```swift
// Query for only BusinessTrip instances
let businessTripPredicate = #Predicate<Trip> { $0 is BusinessTrip }
@Query(filter: businessTripPredicate)
var businessTrips: [Trip]
```

### Combined Filtering

Combine type filtering with property filtering:

```swift
// Query for PersonalTrip instances with a specific reason
let personalVacationPredicate = #Predicate<Trip> {
    if let personalTrip = $0 as? PersonalTrip {
        return personalTrip.reason == .vacation
    }
    return false
}

@Query(filter: personalVacationPredicate)
var vacationTrips: [Trip]
```

### Using Enums for Filtering

Create an enum to simplify filtering by type:

```swift
enum TripKind: String, CaseIterable {
    case all = "All"
    case personal = "Personal"
    case business = "Business"
}

struct TripListView: View {
    @Query var trips: [Trip]
    
    init(tripKind: TripKind, searchText: String = "") {
        // Create type predicate based on selected kind
        let typePredicate: Predicate<Trip>? = {
            switch tripKind {
            case .all:
                return nil
            case .personal:
                return #Predicate { $0 is PersonalTrip }
            case .business:
                return #Predicate { $0 is BusinessTrip }
            }
        }()
        
        // Create search predicate if needed
        let searchPredicate = searchText.isEmpty ? nil : #Predicate<Trip> {
            $0.name.localizedStandardContains(searchText) || 
            $0.destination.localizedStandardContains(searchText)
        }
        
        // Combine predicates if both exist
        let finalPredicate: Predicate<Trip>?
        if let typePredicate, let searchPredicate {
            finalPredicate = #Predicate { typePredicate.evaluate($0) && searchPredicate.evaluate($0) }
        } else {
            finalPredicate = typePredicate ?? searchPredicate
        }
        
        _trips = Query(filter: finalPredicate, sort: \.startDate)
    }
}
```

## Working with Subclass Properties

### Type Casting

When working with a collection of base class instances, you'll need to cast to access subclass-specific properties:

```swift
func calculateTotalExpenses(for trips: [Trip]) -> Double {
    var total = 0.0
    
    for trip in trips {
        if let businessTrip = trip as? BusinessTrip {
            // Access BusinessTrip-specific properties
            let perDiemTotal = businessTrip.perDiemRate * Double(Calendar.current.dateComponents([.day], from: businessTrip.startDate, to: businessTrip.endDate).day ?? 0)
            
            // Add meal expenses
            let mealExpenses = businessTrip.businessMeals.reduce(0.0) { $0 + $1.cost }
            
            total += perDiemTotal + mealExpenses
        }
    }
    
    return total
}
```

### Polymorphic Relationships

You can create relationships that work with the base class but contain instances of different subclasses:

```swift
@Model class TravelPlanner {
    var name: String
    
    @Relationship(deleteRule: .cascade)
    var upcomingTrips: [Trip] = []  // Can contain both BusinessTrip and PersonalTrip instances
    
    func addTrip(_ trip: Trip) {
        upcomingTrips.append(trip)
    }
}
```

## Best Practices

1. **Keep inheritance hierarchies shallow**: Avoid deep inheritance chains that can become difficult to maintain.

2. **Use meaningful IS-A relationships**: Only use inheritance when there's a true "is-a" relationship between models.

3. **Consider alternatives**: For simpler cases, enums or Boolean flags might be more appropriate than inheritance.

4. **Design for query patterns**: Consider how you'll query your data when designing your class hierarchy.

5. **Be mindful of schema migrations**: Changes to your inheritance hierarchy may require more complex migrations.

6. **Document the inheritance structure**: Make sure other developers understand the relationships between your models.

7. **Test with real data**: Verify that your inheritance structure works well with realistic data and query patterns.

## References

- [Adopting inheritance in SwiftData](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData)
- [Design for specialization](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData#Design-for-specialization)
- [Determine whether inheritance is right for your use case](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData#Determine-whether-inheritance-is-right-for-your-use-case)
- [Fetch and Query Data](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData#Fetch-and-Query-Data)
--- END FILE ---

--- FILE: charting-data.md ---
---
title: Charting data | Apple Developer Documentation
source_url: https://developer.apple.com/design/human-interface-guidelines/charting-data
scraped_date: '2025-10-25T18:04:03.312840Z'
extraction_method: Chrome DevTools MCP Server
content_length: 6930
filename: charting-data.md
---

# Charting data | Apple Developer Documentation

Charting data
Presenting data in a chart can help you communicate information with clarity and appeal.

Charts provide efficient ways to communicate complex information without requiring people to read and interpret a lot of text. The graphical nature of charts also gives you additional opportunities to express the personality of your experience and add visual interest to your interface. To learn about the components you use to create a chart, see Charts.

A chart can range from a simple graphic that provides glanceable information to a rich, interactive experience that can form the centerpiece of your app and encourage people to explore the data from various perspectives. Whether simple or complex, you can use charts to help people perform data-driven tasks that are important to them, such as:

Analyzing trends based on historical or predicted values

Visualizing the current state of a process, system, or quantity that changes over time

Evaluating different items — or the same item at different times — by comparing data across multiple categories

Not every collection of data needs to be displayed in a chart. If you simply need to provide data — and you don't need to convey information about it or help people analyze it — consider offering the data in other ways, such as in a list or table that people can scroll, search, and sort.

Best practices

Use a chart when you want to highlight important information about a dataset. Charts are visually prominent, so they tend to draw people's attention. Take advantage of this prominence by clearly communicating what people can learn from the data they care about.

Keep a chart simple, letting people choose when they want additional details. Resist the temptation to pack as much data as possible into a chart. Too much data can make a chart visually overwhelming and difficult to use, obscuring the relationships and other information you want to convey. If you have a lot of data to present — or a lot of functionality to provide — consider giving people a way to reveal it gradually. For example, you might let people choose to view different levels of detail or subsets of data to match their interest. To help people learn how to use an interactive chart, you might offer several versions of the chart, each with more functionality than the last.

Make every chart in your app accessible. A chart communicates visually through graphical representations of data and visual descriptions. In addition to the visual descriptions you display, it's crucial to provide both accessibility labels that describe chart values and components, and accessibility elements that help people interact with the chart. For guidance, see Enhancing the accessibility of a chart.

Designing effective charts

In general, prefer using common chart types. People tend to be familiar with common chart types — such as bar charts and line charts — so using one of these types in your app can make it more likely that people will already know how to read your chart. For guidance, see Charts.

If you need to create a chart that presents data in a novel way, help people learn how to interpret the chart. For example, when a Watch pairs with iPhone, Activity introduces the Activity rings by animating them individually, showing people how each ring maps to the move, exercise, and stand metrics.

Examine the data from multiple levels or perspectives to find details you can display to enhance the chart. For example, viewing the data from a macro level can help you determine high-level summaries that people might be interested in, like totals or averages. From a mid-level perspective, you might find ways to help people identify useful subsets of the data, whereas examining individual data points might help you find ways to draw people's attention to specific values or items. Displaying information that helps people view the chart from various perspectives can encourage them to engage with it.

Aid comprehension by adding descriptive text to the chart. Descriptive text titles, subtitles, and annotations help emphasize the most important information in a chart and can highlight actionable takeaways. You can also display brief descriptive text that serves as a headline or summary for a chart, helping people grasp essential information at a glance. For example, Weather displays text that summarizes the information people need right now — such as "Chance of light rain in the next hour" — above the scrolling list of hourly forecasts for the next 24 hours. Although a descriptive headline or summary can make a chart more accessible, it doesn't take the place of accessibility labels.

Match the size of a chart to its functionality, topic, and level of detail. In general, a chart needs to be large enough to comfortably display the details you need to include and expansive enough for the interactivity you want to support. For example, you always want to make it easy for people to read a chart's details and descriptive text — like labels and annotations — but you might also want to give people enough room to change the scope of a chart or investigate the data from different perspectives. On the other hand, you might want to use a small chart to offer glanceable information about an individual item or to provide a snapshot or preview of a larger version of the chart that people can reveal in a different view.

Prefer consistency across multiple charts, deviating only when you need to highlight differences. If multiple charts in your app serve a similar purpose, you generally don't want to imply that the charts are unrelated by using a different type or style for each one. Also, using a consistent visual approach for the charts in your app lets people use what they learn about one chart to help them understand another. Consider using different chart types and styles when you need to highlight meaningful differences between charts.

Maintain continuity among multiple charts that use the same data. When you use multiple charts to help people explore one dataset from different perspectives, it's important to use one chart type and consistent colors, annotations, layouts, and descriptive text to signal that the dataset remains the same. For example, the Health Trends screen shows small charts that each use a specific visual style to depict a recent trend in an area like steps or resting heart rate. When people choose a chart to reveal all their data in that area, the expanded version uses the same style, colors, marks, and annotations to strengthen the relationship between the versions.

Platform considerations

No additional considerations for iOS, iPadOS, macOS, tvOS, visionOS, or watchOS.

Resources
Related

Charts

Developer documentation

Swift Charts

Videos
Bring Swift Charts to the third dimension
Design app experiences with charts
Design an effective chart
Change log

Date

	

Changes




September 23, 2022

	

New page.
--- END FILE ---

--- FILE: Technology-specific-views.md ---
# Technology-specific views

**Use SwiftUI views that other Apple frameworks provide.**


## Overview

To access SwiftUI views that another framework defines, import both SwiftUI and the other framework into the file where you use the view. You can find the framework to import by looking at the availability information on the view’s documentation page.

![Image](technology-specific-views-hero)

For example, to use the [doc://com.apple.documentation/documentation/MapKit/Map](https://developer.apple.com/documentation/MapKit/Map) view in your app, import both SwiftUI and MapKit.

```swift
import SwiftUI
import MapKit

struct MyMapView: View {
    // Center the map on Joshua Tree National Park.
    var region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: 34.011_286, longitude: -116.166_868),
            span: MKCoordinateSpan(latitudeDelta: 0.2, longitudeDelta: 0.2)
        )

    var body: some View {
        Map(initialPosition: .region(region))
    }
}
```

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/technologies in the Human Interface Guidelines.

## Topics

### Displaying web content

- [WebView](https://developer.apple.com/documentation/WebKit/WebView-swift.struct) — A view that displays some web content.
- [WebPage](https://developer.apple.com/documentation/WebKit/WebPage) — An object that controls and manages the behavior of interactive web content.
- [webViewBackForwardNavigationGestures(_:)](https://developer.apple.com/documentation/swiftui/view/webviewbackforwardnavigationgestures(_:)) — Determines whether horizontal swipe gestures trigger backward and forward page navigation.
- [webViewContentBackground(_:)](https://developer.apple.com/documentation/swiftui/view/webviewcontentbackground(_:)) — Specifies the visibility of the webpage’s natural background color within this view.
- [webViewContextMenu(menu:)](https://developer.apple.com/documentation/swiftui/view/webviewcontextmenu(menu:)) — Adds an item-based context menu to a WebView, replacing the default set of context menu items.
- [webViewElementFullscreenBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/webviewelementfullscreenbehavior(_:)) — Determines whether a web view can display content full screen.
- [webViewLinkPreviews(_:)](https://developer.apple.com/documentation/swiftui/view/webviewlinkpreviews(_:)) — Determines whether pressing a link displays a preview of the destination for the link.
- [webViewMagnificationGestures(_:)](https://developer.apple.com/documentation/swiftui/view/webviewmagnificationgestures(_:)) — Determines whether magnify gestures change the view’s magnification.
- [webViewOnScrollGeometryChange(for:of:action:)](https://developer.apple.com/documentation/swiftui/view/webviewonscrollgeometrychange(for:of:action:)) — Adds an action to be performed when a value, created from a scroll geometry, changes.
- [webViewScrollInputBehavior(_:for:)](https://developer.apple.com/documentation/swiftui/view/webviewscrollinputbehavior(_:for:)) — Enables or disables scrolling in web views when using particular inputs.
- [webViewScrollPosition(_:)](https://developer.apple.com/documentation/swiftui/view/webviewscrollposition(_:)) — Associates a binding to a scroll position with the web view.
- [webViewTextSelection(_:)](https://developer.apple.com/documentation/swiftui/view/webviewtextselection(_:)) — Determines whether to allow people to select or otherwise interact with text.
### Accessing Apple Pay and Wallet

- [PayWithApplePayButton](https://developer.apple.com/documentation/PassKit/PayWithApplePayButton) — A type that provides a button to pay with Apple pay.
- [AddPassToWalletButton](https://developer.apple.com/documentation/PassKit/AddPassToWalletButton) — A type that provides a button that enables people to add a new or existing pass to Apple Wallet.
- [VerifyIdentityWithWalletButton](https://developer.apple.com/documentation/PassKit/VerifyIdentityWithWalletButton) — A type that displays a button to present the identity verification flow.
- [addOrderToWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/addordertowalletbuttonstyle(_:)) — Sets the button’s style.
- [addPassToWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/addpasstowalletbuttonstyle(_:)) — Sets the style to be used by the button. (see `PKAddPassButtonStyle`).
- [onApplePayCouponCodeChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepaycouponcodechange(perform:)) — Called when a user has entered or updated a coupon code. This is required if the user is being asked to provide a coupon code.
- [onApplePayPaymentMethodChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepaypaymentmethodchange(perform:)) — Called when a payment method has changed and asks for an update payment request. If this modifier isn’t provided Wallet will assume the payment method is valid.
- [onApplePayShippingContactChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepayshippingcontactchange(perform:)) — Called when a user selected a shipping address. This is required if the user is being asked to provide a shipping contact.
- [onApplePayShippingMethodChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepayshippingmethodchange(perform:)) — Called when a user selected a shipping method. This is required if the user is being asked to provide a shipping method.
- [payLaterViewAction(_:)](https://developer.apple.com/documentation/swiftui/view/paylaterviewaction(_:)) — Sets the action on the PayLaterView. See `PKPayLaterAction`.
- [payLaterViewDisplayStyle(_:)](https://developer.apple.com/documentation/swiftui/view/paylaterviewdisplaystyle(_:)) — Sets the display style on the PayLaterView. See `PKPayLaterDisplayStyle`.
- [payWithApplePayButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/paywithapplepaybuttonstyle(_:)) — Sets the style to be used by the button. (see `PayWithApplePayButtonStyle`).
- [verifyIdentityWithWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/verifyidentitywithwalletbuttonstyle(_:)) — Sets the style to be used by the button. (see `PKIdentityButtonStyle`).
- [AsyncShareablePassConfiguration](https://developer.apple.com/documentation/PassKit/AsyncShareablePassConfiguration)
- [transactionTask(_:action:)](https://developer.apple.com/documentation/swiftui/view/transactiontask(_:action:)) — Provides a task to perform before this view appears
### Authorizing and authenticating

- [LocalAuthenticationView](https://developer.apple.com/documentation/LocalAuthentication/LocalAuthenticationView) — A SwiftUI view that displays an authentication interface.
- [SignInWithAppleButton](https://developer.apple.com/documentation/AuthenticationServices/SignInWithAppleButton) — A SwiftUI view that creates the Sign in with Apple button for display.
- [signInWithAppleButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/signinwithapplebuttonstyle(_:)) — Sets the style used for displaying the control (see `SignInWithAppleButton.Style`).
- [authorizationController](https://developer.apple.com/documentation/swiftui/environmentvalues/authorizationcontroller) — A value provided in the SwiftUI environment that views can use to perform authorization requests.
- [webAuthenticationSession](https://developer.apple.com/documentation/swiftui/environmentvalues/webauthenticationsession) — A value provided in the SwiftUI environment that views can use to authenticate a user through a web service.
### Configuring Family Sharing

- [FamilyActivityPicker](https://developer.apple.com/documentation/FamilyControls/FamilyActivityPicker) — A view in which users specify applications, web domains, and categories without revealing their choices to the app.
- [familyActivityPicker(isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/familyactivitypicker(ispresented:selection:)) — Presents an activity picker view as a sheet.
- [familyActivityPicker(headerText:footerText:isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/familyactivitypicker(headertext:footertext:ispresented:selection:)) — Presents an activity picker view as a sheet.
### Reporting on device activity

- [DeviceActivityReport](https://developer.apple.com/documentation/DeviceActivity/DeviceActivityReport) — A view that reports the user’s application, category, and web domain activity in a privacy-preserving way.
### Working with managed devices

- [managedContentStyle(_:)](https://developer.apple.com/documentation/swiftui/view/managedcontentstyle(_:)) — Applies a managed content style to the view.
- [automatedDeviceEnrollmentAddition(isPresented:)](https://developer.apple.com/documentation/swiftui/view/automateddeviceenrollmentaddition(ispresented:)) — Presents a modal view that enables users to add devices to their organization.
### Creating graphics

- [Chart](https://developer.apple.com/documentation/Charts/Chart) — A SwiftUI view that displays a chart.
- [SceneView](https://developer.apple.com/documentation/SceneKit/SceneView) — A SwiftUI view for displaying 3D SceneKit content.
- [SpriteView](https://developer.apple.com/documentation/SpriteKit/SpriteView) — A SwiftUI view that renders a SpriteKit scene.
### Getting location information

- [LocationButton](https://developer.apple.com/documentation/CoreLocationUI/LocationButton) — A SwiftUI button that grants one-time location authorization.
- [Map](https://developer.apple.com/documentation/MapKit/Map) — A view that displays an embedded map interface.
- [mapStyle(_:)](https://developer.apple.com/documentation/swiftui/view/mapstyle(_:)) — Specifies the map style to be used.
- [mapScope(_:)](https://developer.apple.com/documentation/swiftui/view/mapscope(_:)) — Creates a mapScope that SwiftUI uses to connect map controls to an associated map.
- [mapFeatureSelectionDisabled(_:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectiondisabled(_:)) — Specifies which map features should have selection disabled.
- [mapFeatureSelectionAccessory(_:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectionaccessory(_:)) — Specifies the selection accessory to display for a `MapFeature`
- [mapFeatureSelectionContent(content:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectioncontent(content:)) — Specifies a custom presentation for the currently selected feature.
- [mapControls(_:)](https://developer.apple.com/documentation/swiftui/view/mapcontrols(_:)) — Configures all `Map` views in the associated environment to have standard size and position controls
- [mapControlVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/mapcontrolvisibility(_:)) — Configures all Map controls in the environment to have the specified visibility
- [mapCameraKeyframeAnimator(trigger:keyframes:)](https://developer.apple.com/documentation/swiftui/view/mapcamerakeyframeanimator(trigger:keyframes:)) — Uses the given keyframes to animate the camera of a `Map` when the given trigger value changes.
- [lookAroundViewer(isPresented:scene:allowsNavigation:showsRoadLabels:pointsOfInterest:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/lookaroundviewer(ispresented:scene:allowsnavigation:showsroadlabels:pointsofinterest:ondismiss:))
- [lookAroundViewer(isPresented:initialScene:allowsNavigation:showsRoadLabels:pointsOfInterest:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/lookaroundviewer(ispresented:initialscene:allowsnavigation:showsroadlabels:pointsofinterest:ondismiss:))
- [onMapCameraChange(frequency:_:)](https://developer.apple.com/documentation/swiftui/view/onmapcamerachange(frequency:_:)) — Performs an action when Map camera framing changes
- [mapItemDetailPopover(isPresented:item:displaysMap:attachmentAnchor:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(ispresented:item:displaysmap:attachmentanchor:)) — Presents a map item detail popover.
- [mapItemDetailPopover(isPresented:item:displaysMap:attachmentAnchor:arrowEdge:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(ispresented:item:displaysmap:attachmentanchor:arrowedge:)) — Presents a map item detail popover.
- [mapItemDetailPopover(item:displaysMap:attachmentAnchor:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(item:displaysmap:attachmentanchor:)) — Presents a map item detail popover.
- [mapItemDetailPopover(item:displaysMap:attachmentAnchor:arrowEdge:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(item:displaysmap:attachmentanchor:arrowedge:)) — Presents a map item detail popover.
- [mapItemDetailSheet(isPresented:item:displaysMap:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailsheet(ispresented:item:displaysmap:)) — Presents a map item detail sheet.
- [mapItemDetailSheet(item:displaysMap:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailsheet(item:displaysmap:)) — Presents a map item detail sheet.
### Displaying media

- [CameraView](https://developer.apple.com/documentation/HomeKit/CameraView) — A SwiftUI view into which a video stream or an image snapshot is rendered.
- [NowPlayingView](https://developer.apple.com/documentation/WatchKit/NowPlayingView) — A view that displays the system’s Now Playing interface so that the user can control audio.
- [VideoPlayer](https://developer.apple.com/documentation/AVKit/VideoPlayer) — A view that displays content from a player and a native user interface to control playback.
- [continuityDevicePicker(isPresented:onDidConnect:)](https://developer.apple.com/documentation/swiftui/view/continuitydevicepicker(ispresented:ondidconnect:)) — A `continuityDevicePicker` should be used to discover and connect nearby continuity device through a button interface or other form of activation. On tvOS, this presents a fullscreen continuity device picker experience when selected. The modal view covers as much the screen of `self` as possible when a given condition is true.
- [cameraAnchor(isActive:)](https://developer.apple.com/documentation/swiftui/view/cameraanchor(isactive:)) — Specifies the view that should act as the virtual camera for Apple Vision Pro 2D Persona stream.
### Selecting photos

- [PhotosPicker](https://developer.apple.com/documentation/PhotosUI/PhotosPicker) — A view that displays a Photos picker for choosing assets from the photo library.
- [photosPicker(isPresented:selection:matching:preferredItemEncoding:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:matching:preferreditemencoding:)) — Presents a Photos picker that selects a `PhotosPickerItem`.
- [photosPicker(isPresented:selection:matching:preferredItemEncoding:photoLibrary:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:matching:preferreditemencoding:photolibrary:)) — Presents a Photos picker that selects a `PhotosPickerItem` from a given photo library.
- [photosPicker(isPresented:selection:maxSelectionCount:selectionBehavior:matching:preferredItemEncoding:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:maxselectioncount:selectionbehavior:matching:preferreditemencoding:)) — Presents a Photos picker that selects a collection of `PhotosPickerItem`.
- [photosPicker(isPresented:selection:maxSelectionCount:selectionBehavior:matching:preferredItemEncoding:photoLibrary:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:maxselectioncount:selectionbehavior:matching:preferreditemencoding:photolibrary:)) — Presents a Photos picker that selects a collection of `PhotosPickerItem` from a given photo library.
- [photosPickerAccessoryVisibility(_:edges:)](https://developer.apple.com/documentation/swiftui/view/photospickeraccessoryvisibility(_:edges:)) — Sets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.
- [photosPickerDisabledCapabilities(_:)](https://developer.apple.com/documentation/swiftui/view/photospickerdisabledcapabilities(_:)) — Disables capabilities of the Photos picker.
- [photosPickerStyle(_:)](https://developer.apple.com/documentation/swiftui/view/photospickerstyle(_:)) — Sets the mode of the Photos picker.
### Previewing content

- [quickLookPreview(_:)](https://developer.apple.com/documentation/swiftui/view/quicklookpreview(_:)) — Presents a Quick Look preview of the contents of a single URL.
- [quickLookPreview(_:in:)](https://developer.apple.com/documentation/swiftui/view/quicklookpreview(_:in:)) — Presents a Quick Look preview of the URLs you provide.
### Interacting with networked devices

- [DevicePicker](https://developer.apple.com/documentation/DeviceDiscoveryUI/DevicePicker) — A SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.
- [devicePickerSupports](https://developer.apple.com/documentation/swiftui/environmentvalues/devicepickersupports) — Checks for support to present a DevicePicker.
### Configuring a Live Activity

- [activitySystemActionForegroundColor(_:)](https://developer.apple.com/documentation/swiftui/view/activitysystemactionforegroundcolor(_:)) — The text color for the auxiliary action button that the system shows next to a Live Activity on the Lock Screen.
- [activityBackgroundTint(_:)](https://developer.apple.com/documentation/swiftui/view/activitybackgroundtint(_:)) — Sets the tint color for the background of a Live Activity that appears on the Lock Screen.
- [isActivityFullscreen](https://developer.apple.com/documentation/swiftui/environmentvalues/isactivityfullscreen) — A Boolean value that indicates whether the Live Activity appears in a full-screen presentation.
- [activityFamily](https://developer.apple.com/documentation/swiftui/environmentvalues/activityfamily) — The size family of the current Live Activity.
### Interacting with the App Store and Apple Music

- [appStoreOverlay(isPresented:configuration:)](https://developer.apple.com/documentation/swiftui/view/appstoreoverlay(ispresented:configuration:)) — Presents a StoreKit overlay when a given condition is true.
- [manageSubscriptionsSheet(isPresented:)](https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:))
- [refundRequestSheet(for:isPresented:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/refundrequestsheet(for:ispresented:ondismiss:)) — Display the refund request sheet for the given transaction.
- [offerCodeRedemption(isPresented:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/offercoderedemption(ispresented:oncompletion:)) — Presents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.
- [musicSubscriptionOffer(isPresented:options:onLoadCompletion:)](https://developer.apple.com/documentation/swiftui/view/musicsubscriptionoffer(ispresented:options:onloadcompletion:)) — Initiates the process of presenting a sheet with subscription offers for Apple Music when the `isPresented` binding is `true`.
- [currentEntitlementTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/currententitlementtask(for:priority:action:)) — Declares the view as dependent on the entitlement of an In-App Purchase product, and returns a modified view.
- [inAppPurchaseOptions(_:)](https://developer.apple.com/documentation/swiftui/view/inapppurchaseoptions(_:)) — Add a function to call before initiating a purchase from StoreKit view within this view, providing a set of options for the purchase.
- [manageSubscriptionsSheet(isPresented:subscriptionGroupID:)](https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:subscriptiongroupid:))
- [onInAppPurchaseCompletion(perform:)](https://developer.apple.com/documentation/swiftui/view/oninapppurchasecompletion(perform:)) — Add an action to perform when a purchase initiated from a StoreKit view within this view completes.
- [onInAppPurchaseStart(perform:)](https://developer.apple.com/documentation/swiftui/view/oninapppurchasestart(perform:)) — Add an action to perform when a user triggers the purchase button on a StoreKit view within this view.
- [productIconBorder()](https://developer.apple.com/documentation/swiftui/view/producticonborder()) — Adds a standard border to an in-app purchase product’s icon .
- [productViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/productviewstyle(_:)) — Sets the style for In-App Purchase product views within a view.
- [productDescription(_:)](https://developer.apple.com/documentation/swiftui/view/productdescription(_:)) — Configure the visibility of labels displaying an in-app purchase product description within the view.
- [storeButton(_:for:)](https://developer.apple.com/documentation/swiftui/view/storebutton(_:for:)) — Specifies the visibility of auxiliary buttons that store view and subscription store view instances may use.
- [storeProductTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/storeproducttask(for:priority:action:)) — Declares the view as dependent on an In-App Purchase product and returns a modified view.
- [storeProductsTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/storeproductstask(for:priority:action:)) — Declares the view as dependent on a collection of In-App Purchase products and returns a modified view.
- [subscriptionStatusTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstatustask(for:priority:action:)) — Declares the view as dependent on the status of an auto-renewable subscription group, and returns a modified view.
- [subscriptionStoreButtonLabel(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorebuttonlabel(_:)) — Configures subscription store view instances within a view to use the provided button label.
- [subscriptionStoreControlIcon(icon:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolicon(icon:)) — Sets a view to use to decorate individual subscription options within a subscription store view.
- [subscriptionStoreControlStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolstyle(_:)) — Sets the control style for subscription store views within a view.
- [subscriptionStoreControlStyle(_:placement:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolstyle(_:placement:)) — Sets the control style and control placement for subscription store views within a view.
- [subscriptionStoreOptionGroupStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstoreoptiongroupstyle(_:)) — Sets the style subscription store views within this view use to display groups of subscription options.
- [subscriptionStorePickerItemBackground(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:)) — Sets the background style for picker items of the subscription store view instances within a view.
- [subscriptionStorePickerItemBackground(_:in:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:in:)) — Sets the background shape and style for subscription store view picker items within a view.
- [subscriptionStorePolicyDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(for:destination:)) — Configures a view as the destination for a policy button action in subscription store views.
- [subscriptionStorePolicyDestination(url:for:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(url:for:)) — Configures a URL as the destination for a policy button action in subscription store views.
- [subscriptionStorePolicyForegroundStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:)) — Sets the style for the terms of service and privacy policy buttons within a subscription store view.
- [subscriptionStorePolicyForegroundStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:_:)) — Sets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.
- [subscriptionStoreSignInAction(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstoresigninaction(_:)) — Adds an action to perform when a person uses the sign-in button on a subscription store view within a view.
- [subscriptionStoreControlBackground(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolbackground(_:)) — Set a standard effect to use for the background of subscription store view controls within the view.
- [subscriptionPromotionalOffer(offer:signature:)](https://developer.apple.com/documentation/swiftui/view/subscriptionpromotionaloffer(offer:signature:)) — Selects a promotional offer to apply to a purchase a customer makes from a subscription store view.
- [preferredSubscriptionOffer(_:)](https://developer.apple.com/documentation/swiftui/view/preferredsubscriptionoffer(_:)) — Selects a subscription offer to apply to a purchase that a customer makes from a subscription store view, a store view, or a product view.
### Accessing health data

- [healthDataAccessRequest(store:objectType:predicate:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:objecttype:predicate:trigger:completion:)) — Asynchronously requests permission to read a data type that requires per-object authorization (such as vision prescriptions).
- [healthDataAccessRequest(store:readTypes:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:readtypes:trigger:completion:)) — Requests permission to read the specified HealthKit data types.
- [healthDataAccessRequest(store:shareTypes:readTypes:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:sharetypes:readtypes:trigger:completion:)) — Requests permission to save and read the specified HealthKit data types.
- [workoutPreview(_:isPresented:)](https://developer.apple.com/documentation/swiftui/view/workoutpreview(_:ispresented:)) — Presents a preview of the workout contents as a modal sheet
### Providing tips

- [popoverTip(_:arrowEdge:action:)](https://developer.apple.com/documentation/swiftui/view/popovertip(_:arrowedge:action:)) — Presents a popover tip on the modified view.
- [tipBackground(_:)](https://developer.apple.com/documentation/swiftui/view/tipbackground(_:)) — Sets the tip’s view background to a style. Currently this only applies to inline tips, not popover tips.
- [tipCornerRadius(_:antialiased:)](https://developer.apple.com/documentation/swiftui/view/tipcornerradius(_:antialiased:)) — Sets the corner radius for an inline tip view.
- [tipImageSize(_:)](https://developer.apple.com/documentation/swiftui/view/tipimagesize(_:)) — Sets the size for a tip’s image.
- [tipViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tipviewstyle(_:)) — Sets the given style for TipView within the view hierarchy.
- [tipImageStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:)) — Sets the style for a tip’s image.
- [tipImageStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:_:)) — Sets the style for a tip’s image.
- [tipImageStyle(_:_:_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:_:_:)) — Sets the style for a tip’s image.
### Showing a translation

- [translationPresentation(isPresented:text:attachmentAnchor:arrowEdge:replacementAction:)](https://developer.apple.com/documentation/swiftui/view/translationpresentation(ispresented:text:attachmentanchor:arrowedge:replacementaction:)) — Presents a translation popover when a given condition is true.
- [translationTask(_:action:)](https://developer.apple.com/documentation/swiftui/view/translationtask(_:action:)) — Adds a task to perform before this view appears or when the translation configuration changes.
- [translationTask(source:target:action:)](https://developer.apple.com/documentation/swiftui/view/translationtask(source:target:action:)) — Adds a task to perform before this view appears or when the specified source or target languages change.
### Presenting journaling suggestions

- [journalingSuggestionsPicker(isPresented:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/journalingsuggestionspicker(ispresented:oncompletion:)) — Presents a visual picker interface that contains events and images that a person can select to retrieve more information.
### Managing contact access

- [contactAccessButtonCaption(_:)](https://developer.apple.com/documentation/swiftui/view/contactaccessbuttoncaption(_:))
- [contactAccessButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/contactaccessbuttonstyle(_:))
- [contactAccessPicker(isPresented:completionHandler:)](https://developer.apple.com/documentation/swiftui/view/contactaccesspicker(ispresented:completionhandler:)) — Modally present UI which allows the user to select which contacts your app has access to.
### Handling game controller events

- [handlesGameControllerEvents(matching:)](https://developer.apple.com/documentation/swiftui/view/handlesgamecontrollerevents(matching:)) — Specifies the game controllers events which should be delivered through the GameController framework when the view, or one of its descendants has focus.
### Creating a tabletop game

- [tabletopGame(_:parent:automaticUpdate:)](https://developer.apple.com/documentation/swiftui/view/tabletopgame(_:parent:automaticupdate:)) — Adds a tabletop game to a view.
- [tabletopGame(_:parent:automaticUpdate:interaction:)](https://developer.apple.com/documentation/swiftui/view/tabletopgame(_:parent:automaticupdate:interaction:)) — Supplies a closure which returns a new interaction whenever needed.
### Configuring camera controls

- [realityViewCameraControls](https://developer.apple.com/documentation/swiftui/environmentvalues/realityviewcameracontrols) — The camera controls for the reality view.
- [realityViewCameraControls(_:)](https://developer.apple.com/documentation/swiftui/view/realityviewcameracontrols(_:)) — Adds gestures that control the position and direction of a virtual camera.
### Interacting with transactions

- [transactionPicker(isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/transactionpicker(ispresented:selection:)) — Presents a picker that selects a collection of transactions.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Technology-specific-views](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Technology-specific-views)*
--- END FILE ---

--- FILE: Accessible-descriptions.md ---
# Accessible descriptions

**Describe interface elements to help people understand what they represent.**


## Overview

SwiftUI can often infer some information about your user interface elements, but you can use accessibility modifiers to provide even more information for users that need it.

![Image](accessible-descriptions-hero)

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/accessibility#Content-descriptions in the Accessibility section of the Human Interface Guidelines.

## Topics

### Applying labels

- [accessibilityLabel(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:)) — Adds a label to the view that describes its contents.
- [accessibilityLabel(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:isenabled:)) — Adds a label to the view that describes its contents.
- [accessibilityLabel(content:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(content:)) — Adds a label to the view that describes its contents.
- [accessibilityInputLabels(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:)) — Sets alternate input labels with which users identify a view.
- [accessibilityInputLabels(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:isenabled:)) — Sets alternate input labels with which users identify a view.
- [accessibilityLabeledPair(role:id:in:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabeledpair(role:id:in:)) — Pairs an accessibility element representing a label with the element for the matching content.
- [AccessibilityLabeledPairRole](https://developer.apple.com/documentation/swiftui/accessibilitylabeledpairrole) — The role of an accessibility element in a label / content pair.
### Describing values

- [accessibilityValue(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:)) — Adds a textual description of the value that the view contains.
- [accessibilityValue(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:isenabled:)) — Adds a textual description of the value that the view contains.
### Describing content

- [accessibilityTextContentType(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitytextcontenttype(_:)) — Sets an accessibility text content type.
- [accessibilityHeading(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityheading(_:)) — Sets the accessibility level of this heading.
- [AccessibilityHeadingLevel](https://developer.apple.com/documentation/swiftui/accessibilityheadinglevel) — The hierarchy of a heading in relation other headings.
- [AccessibilityTextContentType](https://developer.apple.com/documentation/swiftui/accessibilitytextcontenttype) — Textual context that assistive technologies can use to improve the presentation of spoken text.
### Describing charts

- [accessibilityChartDescriptor(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitychartdescriptor(_:)) — Adds a descriptor to a View that represents a chart to make the chart’s contents accessible to all users.
- [AXChartDescriptorRepresentable](https://developer.apple.com/documentation/swiftui/axchartdescriptorrepresentable) — A type to generate an `AXChartDescriptor` object that you use to provide information about a chart and its data for an accessible experience in VoiceOver or other assistive technologies.
### Adding custom descriptions

- [accessibilityCustomContent(_:_:importance:)](https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)) — Add additional accessibility information to the view.
- [AccessibilityCustomContentKey](https://developer.apple.com/documentation/swiftui/accessibilitycustomcontentkey) — Key used to specify the identifier and label associated with an entry of additional accessibility information.
### Assigning traits to content

- [accessibilityAddTraits(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaddtraits(_:)) — Adds the given traits to the view.
- [accessibilityRemoveTraits(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityremovetraits(_:)) — Removes the given traits from this view.
- [AccessibilityTraits](https://developer.apple.com/documentation/swiftui/accessibilitytraits) — A set of accessibility traits that describe how an element behaves.
### Offering hints

- [accessibilityHint(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:)) — Communicates to the user what happens after performing the view’s action.
- [accessibilityHint(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:isenabled:)) — Communicates to the user what happens after performing the view’s action.
### Configuring VoiceOver

- [speechAdjustedPitch(_:)](https://developer.apple.com/documentation/swiftui/view/speechadjustedpitch(_:)) — Raises or lowers the pitch of spoken text.
- [speechAlwaysIncludesPunctuation(_:)](https://developer.apple.com/documentation/swiftui/view/speechalwaysincludespunctuation(_:)) — Sets whether VoiceOver should always speak all punctuation in the text view.
- [speechAnnouncementsQueued(_:)](https://developer.apple.com/documentation/swiftui/view/speechannouncementsqueued(_:)) — Controls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.
- [speechSpellsOutCharacters(_:)](https://developer.apple.com/documentation/swiftui/view/speechspellsoutcharacters(_:)) — Sets whether VoiceOver should speak the contents of the text view character by character.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-descriptions](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-descriptions)*
--- END FILE ---

--- FILE: Accessible-navigation.md ---
# Accessible navigation

**Enable users to navigate to specific user interface elements using rotors.**


## Overview

An accessibility rotor is a shortcut that enables users to quickly navigate to specific elements of the user interface, and, optionally, to specific ranges of text within those elements.

![Image](accessible-navigation-hero)

The system automatically provides rotors for many navigable elements, but you can supply additional rotors for specific purposes, or replace system rotors when they don’t automatically pick up off-screen elements, like those far down in a [doc://com.apple.SwiftUI/documentation/SwiftUI/LazyVStack](https://developer.apple.com/documentation/SwiftUI/LazyVStack) or a [doc://com.apple.SwiftUI/documentation/SwiftUI/List](https://developer.apple.com/documentation/SwiftUI/List).

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/accessibility#Navigation in the Accessibility section of the Human Interface Guidelines.

## Topics

### Working with rotors

- [accessibilityRotor(_:entries:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:)) — Create an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.
- [accessibilityRotor(_:entries:entryID:entryLabel:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entryid:entrylabel:)) — Create an Accessibility Rotor with the specified user-visible label and entries.
- [accessibilityRotor(_:entries:entryLabel:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entrylabel:)) — Create an Accessibility Rotor with the specified user-visible label and entries.
- [accessibilityRotor(_:textRanges:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:textranges:)) — Create an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.
### Creating rotors

- [AccessibilityRotorContent](https://developer.apple.com/documentation/swiftui/accessibilityrotorcontent) — Content within an accessibility rotor.
- [AccessibilityRotorContentBuilder](https://developer.apple.com/documentation/swiftui/accessibilityrotorcontentbuilder) — Result builder you use to generate rotor entry content.
- [AccessibilityRotorEntry](https://developer.apple.com/documentation/swiftui/accessibilityrotorentry) — A struct representing an entry in an Accessibility Rotor.
### Replacing system rotors

- [AccessibilitySystemRotor](https://developer.apple.com/documentation/swiftui/accessibilitysystemrotor) — Designates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor.
### Configuring rotors

- [accessibilityRotorEntry(id:in:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotorentry(id:in:)) — Defines an explicit identifier tying an Accessibility element for this view to an entry in an Accessibility Rotor.
- [accessibilityLinkedGroup(id:in:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylinkedgroup(id:in:)) — Links multiple accessibility elements so that the user can quickly navigate from one element to another, even when the elements are not near each other in the accessibility hierarchy.
- [accessibilitySortPriority(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitysortpriority(_:)) — Sets the sort priority order for this view’s accessibility element, relative to other elements at the same level.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-navigation](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-navigation)*
--- END FILE ---

--- FILE: SwiftUI-Accessibility-beond-the-basics.md ---
Bass music playing ♪  ♪ Nathan Tannar: Hello, and welcome to WWDC! My name is Nathan, and I'm an engineer on the Accessibility team.

Today we'll be going beyond the basics to learn how to deliver exceptional and accessible SwiftUI apps.

This year marks a huge leap forward for accessibility in SwiftUI.

At Apple, accessibility is one of our core values.

Our assistive technologies across all our platforms make sure that anyone can use your app regardless of any physical, visual, audible, or motor impairment.

My team and I work to make sure most of your app is accessible by default, but there is always more you can do to enrich the experience.

Today I'll show you the new tools and APIs for SwiftUI that make enriching this experience easy.

Let's begin with the tooling improvements in Xcode.

SwiftUI Previews have changed how many of us develop apps.

It dramatically improves your ability to iterate upon your views across multiple environments, all without the need of running your app.

To make the most important accessibility modifiers just a click away, we've added a curated list of accessibility editors.

I hope this encourages everyone to always make their views accessible.

But there's more.

Since accessibility modifiers don't have visual changes in the previews, a new tool was developed that allows you to inspect the accessibility of your view without leaving Xcode.

Let's switch from the editor's panel to the new accessibility panel.

Shipping in Xcode 13, SwiftUI Previews will now also feature an Accessibility Preview.

With it, you can inspect the accessibility elements for a preview in real time.

And this is a game changer.

Accessibility Preview will help you make accessible apps even if you don't have a deep understanding of each assistive technology.

Let's take a closer look to see how changes are reflected in the Accessibility Preview.

This is a simplified version of the view we just saw.

After running the preview, I can select the VStack and the Accessibility Preview will update to display the elements in their sorted order.

Notice that each element will always display its basic properties -- such as a label and traits.

For example, the Text view will create an accessibility element with the string as its label.

It also gains the .isStaticText trait.

The preview will update for any accessibility changes we make, such as adding the .isHeader trait.

You will also be able to see some of the automatic accessibility that takes place behind the scenes, such as automatic SF Symbol labels.

For example, the checkmark.seal.fill symbol is labeled "Verified" by default.

If you're relying on a symbol's default label, it's important to check that it accurately describes your interface.

We'll continue to use the Accessibility Preview as we step through five importance areas that'll help you deliver an exceptional experience to all of your app's users.

We'll start by examining the best way to make custom controls accessible.

Next, we'll discuss how to make a view accessible with children.

I'll highlight how to audit your app for common navigation problems and how the Accessibility Preview can assist with this.

Then I'll show you how to supercharge your app's navigation with VoiceOver rotors.

And finally, we'll look at focus and how it relates to assistive technologies.

I've been working to prototype a new finance app I call Wallet Pal.

It's still in the early stages, but so far, I'm pretty happy with the initial design.

I was pleased to hear that early beta testers are also loving it.

Now that I've polished the UI, I should spend some time to polish the accessibility interface.

The accessibility interface compliments the visual experience to make sure that it’s usable by everyone.

I've asked some VoiceOver users to help test Wallet Pal and I've heard that the app is hard to navigate and not fully accessible.

If parts are not accessible to VoiceOver, then they are also not accessible to other assistive technologies.

It's important that anyone be able to use Wallet Pal, so let's investigate to see where we can improve the experience.

We'll begin with reports of users not being able to edit their budgets, a critical feature in Wallet Pal.

This is the Budget Planner view which allows users to edit their food, entertainment, and savings budgets.

To fit the design of Wallet Pal, I ended up needing to create custom sliders.

```swift
struct BudgetSlider: View {
    @Binding var value: Double
    var label: String

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text(label)
                Text(value.toDollars()).bold()
            }
            SliderShape(value: value)
                .gesture(DragGesture().onChanged(handle))
                .accessibilityRepresentation {
                    Slider(value: $value, in: 0...1) {
                        Text(label)
                    }
                    .accessibilityValue(value.toDollars())
                }
        }
    }
}

struct SliderShape: View {
    var value: Double

    private struct BackgroundTrack: View {
        var cornerRadius: CGFloat
        var body: some View {
            RoundedRectangle(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(Color(white: 0.2))
        }
    }

    private struct OverlayTrack: View {
        var cornerRadius: CGFloat
        var body: some View {
            RoundedRectangle(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(Color(white: 0.95))
        }
    }

    private struct Knob: View {
        var cornerRadius: CGFloat
        var body: some View {
            RoundedRectangle(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .strokeBorder(Color(white: 0.7), lineWidth: 1)
            .shadow(radius: 3)
        }
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                BackgroundTrack(cornerRadius: geometry.size.height / 2)

                OverlayTrack(cornerRadius: geometry.size.height / 2)
                    .frame(
                        width: max(geometry.size.height, geometry.size.width * CGFloat(value) + geometry.size.height / 2),
                        height: geometry.size.height)

                Knob(cornerRadius: geometry.size.height / 2)
                    .frame(
                        width: geometry.size.height,
                        height: geometry.size.height)
                    .offset(x: max(0, geometry.size.width * CGFloat(value) - geometry.size.height / 2), y: 0)
            }
        }
    }
}

extension Double {
    func toDollars() -> String {
        return "$\(Int(self))"
    }
}
```

This must be why some users are not able to edit their budgets.

We can confirm it's not accessible by running a SwiftUI preview and selecting the SliderShape.

The Accessibility Preview shows that there are no elements, so this control is not accessible.

Ideally, we should have a single labeled accessibility element with a value that can be changed.

In contrast, standard controls are accessible by default, meaning little to no extra effort is required to provide a great experience.

SwiftUI uses the view type and its initialization parameters to automatically derive the accessibility element's label, value, traits, and actions.

So what's the best way to make our custom budget slider accessible? Since the standard slider is accessible by default, my team and I thought it would be great to have an API that allows the accessibility of one view to be represented by another.

This is what led us to us to create accessibilityRepresentation(representation:).

It's an API that allows the accessibility of one view to be defined by another.

Since I want this to be perceived by assistive technologies as a slider, that's what I'll use for the accessibility representation.

With accessibilityRepresentation(representation:), we're now well on the way to making this budget slider accessible.

The only change needed to improve the experience of the slider is to describe the value in dollars.

And great, just like that, now our budget slider is perfectly accessible.

On macOS, the type of control will also be spoken to VoiceOver users.

So by using the slider view in our budget slider's representation, it will be announced as a slider.

It's recommended to use accessibilityRepresentation(representation:) when possible, to make custom controls accessible.

This is just one way to use accessibilityRepresentation(representation:).

Its flexibility allows for many more creative uses.

Let's see if we can use it to fix other accessibility bugs in our app.

While we have now fixed the functional ability to edit budgets, some users reported that they couldn't discover how to navigate to the Budget Planner view.

When designing Wallet Pal, we decided to use SF Symbols for all of our buttons.

While SF Symbols may have great default accessibility labels, they may not always fit the intended use case.

Let's investigate if the problem is a poorly labeled button.

The NavigationBarView contains the Edit Budgets button.

Since we rely on SF Symbols for so many of our buttons, I created a custom buttonStyle called SymbolButtonStyle.

But it appears that despite initializing the button with the label "Edit Budgets", the label for the button is slider.vertical.3.

So the accessibility label is being derived from the SF Symbol.

Let's take a closer look at the SymbolButtonStyle.

The SymbolButtonStyle's makeBody(configuration:) method returns an Image view.

The Edit Budgets string we initialize the button with would create a Text view as the configuration's label.

But this style completely ignores the configuration's label.

This is why the button is not labeled "Edit Budgets".

While we want an SF Symbol to appear visually, we want the accessibility of the button to be represented by the configuration's label.

And so this seems like a great use case for accessibilityRepresentation(representation:).

Using accessibilityRepresentation(representation:), I can substitute the accessibility of the Image view with another view, in this case, the configuration's label.

This way, we can preserve the label we used to create the button.

accessibilityRepresentation(representation:) is not just the ideal and recommended way to make custom controls accessible, it also opens up new creative possibilities to make views accessible.

Next, let's discuss the relationship between children and accessibility containers.

As you may recall, accessibility elements can be wrapped together in a group as children of an accessibility container.

This is done with the accessibilityElement(children:) modifier and the contain child behavior.

In case you're unfamiliar, the contain child behavior can be used to create an accessibility container, which wraps existing accessibility elements as children.

But what if instead you have an accessibility element and you want to set its children? I'm running into this case when trying to make the Budget History graph accessible.

Users reported the graph is completely inaccessible.

And so this means when assistive technologies are focused on the Budget History header and try to navigate to the next element, they end up at the Alerts header.

VoiceOver users would not even know that this graph exists.

I built the graph using the new Canvas view.

Canvas makes it easier to draw a collection of shapes.

For more on Canvas, please check out Jacob's presentation on how it can be used to add rich graphics to your app.

Canvas draws a collection of shapes and just like we saw with BudgetSlider, shapes are not accessible by default.

All users need to be able to view their budget history, so let's make this accessible for everyone.

Starting with the basics, let's give our Canvas a label.

This will automatically create a new accessibility element for the Canvas and assign its label.

Now, I'd like each bar in the graph to be represented by their own accessibility element.

This is a use case where we have an accessibility element and want to provide its children.

To do this, I'll use the new accessibilityChildren(children:) modifier.

This will transform the accessibility element into an accessibility container, preserving other accessibility properties, such as the label.

The modifier takes a ViewBuilder, which allows us to set new views as children of the accessibility container.

Recall that our Budget History graph is drawing a horizontal bar graph, so we'll use an HStack and return a view for each budget.

I'll use a Rectangle for each accessibility element so that the frame will fill all available vertical space.

This will make each accessibility element's frame bigger than what's displayed visually, and that's OK.

Having a large but consistent frame will make it easier to navigate on iOS when VoiceOver users drag their finger across the screen to scan for accessibility elements.

If I select the HStack from within the accessibilityChildren(children:) modifier, the Accessibility Preview confirms that an element has been created for each bar in the graph.

These will all be accessible as children of the Canvas accessibility container.

With these changes, the Budget History graph is now completely accessible, and assistive technologies can navigate through each bar in the graph.

Notice that the frame for each element is the same, which is ideal.

For more complex charts, we have other ways of making them accessible.

For that, please check out Preston's presentation on bringing accessibility to charts.

But with accessibility children, the accessibility elements of a view can differ from what's presented visually, allowing you to tailor a great experience.

But accessibility children can also be used to compose the accessibility with the help of the combine behavior.

As a quick refresh, the combine child behavior will merge properties from multiple accessibility elements into a new or existing accessibility element.

But with the addition of the accessibility children API, it can now also be used to compose accessibility in a generic way.

With accessibility representation, the original accessibility is completely replaced.

This means no composition can take place; whereas accessibility children is additive.

This means you could later combine the children to merge their properties into the original element.

This is a more advanced use case of the accessibilityChildren(children:) modifier, but it's a functionality I wanted to highlight.

Examples are featured in this presentation's Accessibility Catalog Sample Project.

I hope to see many of you explore what's possible with this kind of composition.

accessibilityChildren(children:) gives you control over the children of a container.

And with that, complex graphs drawn with Canvas can be made accessible with modifiers and views you're already familiar with.

And with the combine child behavior, the accessibility of a single view can be composed of many.

Now that we've learned how to make individual components of our app accessible, we can start putting things together to refine the navigation experience.

I've heard that navigating Wallet Pal with VoiceOver is confusing and difficult.

So we have some more work to do if we want to deliver a great accessible app.

Let's take a closer look at the Friends carousel at the top.

While I don't have this feature built yet, I plan to add some kind of gamification to Wallet Pal.

So I've added a challenge button at the top left of each friend view.

We already fixed the SymbolButtonStyle, so the challenge button will be properly labeled now.

But since users are reporting that navigation is confusing, are there other issues? To answer that, we must first understand how assistive technologies will navigate Wallet Pal.

By default, accessibility elements are sorted based off their geometric position in relation to other elements, from top left to bottom right.

This means that without accessibility containers to differentiate the content, VoiceOver would navigate through each of the challenge buttons, then the Image and Add Friend button, and finally, the text with the user's name.

A great feature of the Accessibility Preview is that it shows accessibility elements in their sorted order.

This makes it easy to visualize how assistive technologies will navigate right from within Xcode.

As expected, the sorted order matches what we previously saw.

And this order would certainly be confusing to navigate.

Now there are multiple ways we could fix the sort order of the accessibility elements.

One thing we could do is to introduce accessibility containers.

I'll add the accessibilityElement(children:) modifier with the contain behavior.

This will wrap the accessibility elements of each FriendCellView in an accessibility container.

This fixes the navigation order, because children of an accessibility container are navigated before moving to the next accessibility element.

With this change, VoiceOver will navigate through the children of the accessibility container before moving to the next accessibility element.

And so we achieve a much more desirable navigation order.

But could we do better to improve this experience? One problem is that the challenge button is navigated to before knowing who the user is.

A VoiceOver user would want to know the name of the user before sending a challenge, so this button should really be sorted last.

We can use the accessibilitySortPriority(_:) modifier to fix this.

accessibilitySortPriority(_:) can be used to change the order of elements within an accessibility container.

An element with a higher priority will be sorted first, whereas a lower priority will be sorted last.

Elements with equal priorities are then sorted based off their geometric positioning.

I'll add the accessibilitySortPriority(_:) modifier to the challenge button to improve the navigation order.

I'll use a priority of -1 since the default is 0, to force the sort order of the challenge button to be last.

Now the challenge button will be navigated to last.

This is a good improvement, since there is less chance a VoiceOver user would be confused as to who they are sending a challenge to, but it's still not great.

Rather than wrapping each FriendCellView in an accessibility container, we could combine the children into a single element.

```swift
struct User: Identifiable {
    var id: Int
    var name: String
    var photo: String
}

struct FriendCellView: View {
    var user: User

    var body: some View {
        ZStack(alignment: .topLeading) {
            VStack(alignment: .center) {
                Image(user.photo)
                Text(user.name)
            }

            Button("Send Challenge", action: { /* ... */ })
                .buttonStyle(
                    SymbolButtonStyle(
                        systemName: "gamecontroller.fill"))
        }
    }
}
      
struct FriendsView: View {
    var users: [User]

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack {
                ForEach(users) { user in
                    FriendCellView(user: user)
                        .accessibilityElement(children: .combine)
                        .onTapGesture { /* ... */ }
                }

                AddFriendButton()

                Spacer()
            }
        }
    }
}
  
struct AddFriendButton: View {
    var body: some View {
        Button(action: { /* ... */ }) {
            Circle()
                .foregroundColor(Color(white: 0.9))
                .frame(width: 50, height: 50)
                .overlay(
                    Image(systemName: "plus")
                        .resizable()
                        .foregroundColor(Color(white: 0.5))
                        .padding(15)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct SymbolButtonStyle: ButtonStyle {
    let systemName: String

    func makeBody(configuration: Configuration) -> some View {
                Image(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

This too fixes the navigation order and reduces the number of accessibility elements. 

---

### AlertView implicit Rotor

And so this seems like a great use case for accessibilityRotorEntry.

```swift
struct Alert: Identifiable {
    var id: Int
    var isUnread: Bool
    var isFlagged: Bool
    var subject: String
    var content: String
}

struct AlertsView: View {
    var alerts: [Alert]

    var body: some View {
        VStack {
            ForEach(alerts) { alert in
                AlertCellView(alert: alert)
                    .accessibilityElement(children: .combine)
            }
        }
        .accessibilityElement(children: .contain)
        .accessibilityRotor("Warnings") {
            ForEach(alerts) { alert in
                if alert.isWarning {
                    AccessibilityRotorEntry(alert.title, id: alert.id)
                }
            }
        }
    }
}

struct AlertCell: View {
    var alert: Alert

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                if alert.isUnread {
                    Circle()
                        .foregroundColor(.blue)
                        .frame(width: 10, height: 10)
                }
                if alert.isFlagged {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundColor(.orange)
                        .frame(width: 10, height: 10)
                }
                Text(alert.subject)
                    .font(.headline)
                    .fontWeight(.semibold)
                Spacer()
                Text("04/30/21")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Text(alert.content)
                .lineLimit(3)
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .foregroundColor(Color(white: 0.9))
        )
    }
}
```

These will all be accessible as children of the Canvas accessibility container. 

---

### AlertView Explicit Rotor

The identity of a view is important to understand for accessibility rotors.

```swift
struct Alert: Identifiable {
    var id: Int
    var isUnread: Bool
    var isFlagged: Bool
    var subject: String
    var content: String
}

struct AlertsView: View {
    var alerts: [Alert]
    @Namespace var namespace

    var body: some View {
        VStack {
            ForEach(alerts) { alert in
                VStack {
                    AlertCellView(alert: alert)
                        .accessibilityElement(children: .combine)
                        .accessibilityRotorEntry(id: alert.id, in: namespace)
                    AlertActionsView(alert: alert)
                }
            }
        }
        .accessibilityElement(children: .contain)
        .accessibilityRotor("Warnings") {
            ForEach(alerts) { alert in
                if alert.isWarning {
                    AccessibilityRotorEntry(alert.title, id: alert.id, in: namespace)
                }
            }
        }
    }
}

struct AlertCell: View {
    var alert: Alert

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                if alert.isUnread {
                    Circle()
                        .foregroundColor(.blue)
                        .frame(width: 10, height: 10)
                }
                if alert.isFlagged {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundColor(.orange)
                        .frame(width: 10, height: 10)
                }
                Text(alert.subject)
                    .font(.headline)
                    .fontWeight(.semibold)
                Spacer()
                Text("04/30/21")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Text(alert.content)
                .lineLimit(3)
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .foregroundColor(Color(white: 0.9))
        )
    }
}
```

This simple case works elegantly because there is a single accessibility element -- due to the combine -- for the AlertCellView. 

---

### AlertNotifcationView

AccessibilityFocusState is the last piece you need.

```swift
struct Notification: Equatable {
    enum Priority {
        case low, high
    }
    var content: String
    var priority: Priority
}

struct AlertNotificationView<Content: View>: View {
    @ViewBuilder var content: Content
    @Binding var notification: Notification?
    @AccessibilityFocusState var isNotificationFocused: Bool

    var body: some View {
        ZStack(alignment: .top) {
            content

            if let notification = $notification {
                NotificationBanner(notification: notification)
                    .accessibilityFocused($isNotificationFocused)
            }
        }
        .onChange(of: notification) { notification in
            if notification?.priority == .high {
                isNotificationFocused = true
            } else {
                postAccessibilityNotification()
            }
        }
    }

    func postAccessibilityNotification() {
        guard let announcement = notification?.content else {
            return
        }
        #if os(macOS)
        NSAccessibility.post(
            element: NSApp.accessibilityWindow(),
            notification: .announcementRequested,
            userInfo: [.announcement: announcement])
        #else
        UIAccessibility.post(notification: .announcement, argument: announcement)
        #endif
    }
}

struct NotificationBanner: View {
    @Binding var notification: Notification?
    @State var timer: Timer?
    @AccessibilityFocusState var isNotificationFocused: Bool

    var body: some View {
        if let notification = notification {
            Text(notification.content)
                .accessibilityFocused($isNotificationFocused)
                .onAppear { startTimer() }
                .onDisappear { stopTimer() }
        } else {
            EmptyView()
        }
    }

    func startTimer() {
        timer = Timer.scheduledTimer(
            withTimeInterval: 3,
            repeats: true) { _ in
            if !isNotificationFocused {
                notification = nil
            }
        }
    }

    func stopTimer() {
        timer?.invalidate()
    }
}
```

With it, you can read and direct the focus of assistive technologies to create smooth transitions between views.
--- END FILE ---

--- FILE: Drawing.md ---
# Drawing

**Configure your app’s drawing environment using colors, renderers, draw paths, strings, and shadows.**


## Topics

### UI updates

- [UIUpdateLink](https://developer.apple.com/documentation/uikit/uiupdatelink) — An object you use to observe, participate in, and affect the UI update process.
- [UIUpdateInfo](https://developer.apple.com/documentation/uikit/uiupdateinfo) — An object that contains detailed information about the current UI update state.
- [UIUpdateActionPhase](https://developer.apple.com/documentation/uikit/uiupdateactionphase) — An object that defines specific phases of the UI update process.
### Color

- [UIColor](https://developer.apple.com/documentation/uikit/uicolor) — An object that stores color data and sometimes opacity.
### Graphics contexts

- [UIGraphicsRenderer](https://developer.apple.com/documentation/uikit/uigraphicsrenderer) — An abstract base class for creating graphics renderers.
- [UIGraphicsRendererContext](https://developer.apple.com/documentation/uikit/uigraphicsrenderercontext) — The base class for the drawing environments for graphics renderers.
- [UIGraphicsRendererFormat](https://developer.apple.com/documentation/uikit/uigraphicsrendererformat) — A set of drawing attributes that represents the configuration of a graphics renderer context.
- [UIGraphicsImageRenderer](https://developer.apple.com/documentation/uikit/uigraphicsimagerenderer) — A graphics renderer for creating Core Graphics-backed images.
- [UIGraphicsImageRendererContext](https://developer.apple.com/documentation/uikit/uigraphicsimagerenderercontext) — The drawing environment for an image renderer.
- [UIGraphicsImageRendererFormat](https://developer.apple.com/documentation/uikit/uigraphicsimagerendererformat) — A set of drawing attributes that represents the configuration of an image renderer context.
- [UIGraphicsPDFRenderer](https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer) — A graphics renderer for creating PDFs.
- [UIGraphicsPDFRendererContext](https://developer.apple.com/documentation/uikit/uigraphicspdfrenderercontext) — The drawing environment for a PDF renderer.
- [UIGraphicsPDFRendererFormat](https://developer.apple.com/documentation/uikit/uigraphicspdfrendererformat) — A set of drawing attributes that represents the configuration of a PDF renderer context.
### Paths

- [UIBezierPath](https://developer.apple.com/documentation/uikit/uibezierpath) — A path that consists of straight and curved line segments that you can render in your custom views.
- [UIRectFill(_:)](https://developer.apple.com/documentation/uikit/uirectfill(_:)) — Fills the specified rectangle with the current color.
- [UIRectFillUsingBlendMode(_:_:)](https://developer.apple.com/documentation/uikit/uirectfillusingblendmode(_:_:)) — Fills a rectangle with the current fill color using the specified blend mode.
- [UIRectFrame(_:)](https://developer.apple.com/documentation/uikit/uirectframe(_:)) — Draws a frame around the inside of the specified rectangle.
- [UIRectFrameUsingBlendMode(_:_:)](https://developer.apple.com/documentation/uikit/uirectframeusingblendmode(_:_:)) — Draws a frame around the inside of a rectangle using the specified blend mode.
### Strings

- [NSStringDrawingContext](https://developer.apple.com/documentation/uikit/nsstringdrawingcontext) — An object that manages metrics for drawing attributed strings.
- [NSStringDrawingOptions](https://developer.apple.com/documentation/uikit/nsstringdrawingoptions) — Constants that specify the rendering options for drawing a string.
- [UIBaselineAdjustment](https://developer.apple.com/documentation/uikit/uibaselineadjustment) — Vertical adjustment options.
### Shadows

- [NSShadow](https://developer.apple.com/documentation/uikit/nsshadow) — An object you use to specify attributes to create and style a drop shadow during drawing operations.
### Graphics context primitives

- [UIGraphicsGetCurrentContext()](https://developer.apple.com/documentation/uikit/uigraphicsgetcurrentcontext()) — Returns the current graphics context.
- [UIGraphicsPushContext(_:)](https://developer.apple.com/documentation/uikit/uigraphicspushcontext(_:)) — Makes the specified graphics context the current context.
- [UIGraphicsPopContext()](https://developer.apple.com/documentation/uikit/uigraphicspopcontext()) — Removes the current graphics context from the top of the stack, restoring the previous context.
- [UIGraphicsBeginImageContextWithOptions(_:_:_:)](https://developer.apple.com/documentation/uikit/uigraphicsbeginimagecontextwithoptions(_:_:_:)) — Creates a bitmap-based graphics context with the specified options.
- [UIRectClip(_:)](https://developer.apple.com/documentation/uikit/uirectclip(_:)) — Modifies the current clipping path by intersecting it with the specified rectangle.
### Primitive type conversions

- [cgAffineTransform(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/cgAffineTransform(for:)) — Returns a Core Graphics affine transform structure corresponding to the data in a given string.
- [cgPoint(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/cgPoint(for:)) — Returns a Core Graphics point structure corresponding to the data in a given string.
- [cgRect(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/cgRect(for:)) — Returns a Core Graphics rectangle structure corresponding to the data in a given string.
- [cgSize(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/cgSize(for:)) — Returns a Core Graphics size structure corresponding to the data in a given string.
- [cgVector(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/cgVector(for:)) — Returns a Core Graphics vector corresponding to the data in a given string.
- [string(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/string(for:)-6yx6n) — Returns a string formatted to contain the data from an affine transform.
- [string(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/string(for:)-6ix86) — Returns a string formatted to contain the data from a point.
- [string(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/string(for:)-4qz0a) — Returns a string formatted to contain the data from a rectangle.
- [string(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/string(for:)-2f1xb) — Returns a string formatted to contain the data from a size data structure.
- [string(for:)](https://developer.apple.com/documentation/Foundation/NSCoder/string(for:)-4omzv) — Returns a string formatted to contain the data from a vector data structure.

---

*Source: [https://developer.apple.com/documentation/com.apple.uikit/documentation/UIKit/drawing](https://developer.apple.com/documentation/com.apple.uikit/documentation/UIKit/drawing)*
--- END FILE ---

--- FILE: Drawing-and-graphics.md ---
# Drawing and graphics

**Enhance your views with graphical effects and customized drawings.**


## Overview

You create rich, dynamic user interfaces with the built-in views and [doc://com.apple.SwiftUI/documentation/SwiftUI/Shapes](https://developer.apple.com/documentation/SwiftUI/Shapes) that SwiftUI provides. To enhance any view, you can apply many of the graphical effects typically associated with a graphics context, like setting colors, adding masks, and creating composites.

![Image](drawing-and-graphics-hero)

When you need the flexibility of immediate mode drawing in a graphics context, use a [doc://com.apple.SwiftUI/documentation/SwiftUI/Canvas](https://developer.apple.com/documentation/SwiftUI/Canvas) view. This can be particularly helpful when you want to draw an extremely large number of dynamic shapes — for example, to create particle effects.

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/materials and doc://com.apple.documentation/design/Human-Interface-Guidelines/color in the Human Interface Guidelines.

## Topics

### Immediate mode drawing

- [Add rich graphics to your SwiftUI app](https://developer.apple.com/documentation/swiftui/add-rich-graphics-to-your-swiftui-app) — Make your apps stand out by adding background materials, vibrancy, custom graphics, and animations.
- [Canvas](https://developer.apple.com/documentation/swiftui/canvas) — A view type that supports immediate mode drawing.
- [GraphicsContext](https://developer.apple.com/documentation/swiftui/graphicscontext) — An immediate mode drawing destination, and its current state.
### Setting a color

- [tint(_:)](https://developer.apple.com/documentation/swiftui/view/tint(_:)) — Sets the tint color within this view.
- [Color](https://developer.apple.com/documentation/swiftui/color) — A representation of a color that adapts to a given context.
### Styling content

- [border(_:width:)](https://developer.apple.com/documentation/swiftui/view/border(_:width:)) — Adds a border to this view with the specified style and width.
- [foregroundStyle(_:)](https://developer.apple.com/documentation/swiftui/view/foregroundstyle(_:)) — Sets a view’s foreground elements to use a given style.
- [foregroundStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/foregroundstyle(_:_:)) — Sets the primary and secondary levels of the foreground style in the child view.
- [foregroundStyle(_:_:_:)](https://developer.apple.com/documentation/swiftui/view/foregroundstyle(_:_:_:)) — Sets the primary, secondary, and tertiary levels of the foreground style.
- [backgroundStyle(_:)](https://developer.apple.com/documentation/swiftui/view/backgroundstyle(_:)) — Sets the specified style to render backgrounds within the view.
- [backgroundStyle](https://developer.apple.com/documentation/swiftui/environmentvalues/backgroundstyle) — An optional style that overrides the default system background style when set.
- [ShapeStyle](https://developer.apple.com/documentation/swiftui/shapestyle) — A color or pattern to use when rendering a shape.
- [AnyShapeStyle](https://developer.apple.com/documentation/swiftui/anyshapestyle) — A type-erased ShapeStyle value.
- [Gradient](https://developer.apple.com/documentation/swiftui/gradient) — A color gradient represented as an array of color stops, each having a parametric location value.
- [MeshGradient](https://developer.apple.com/documentation/swiftui/meshgradient) — A two-dimensional gradient defined by a 2D grid of positioned colors.
- [AnyGradient](https://developer.apple.com/documentation/swiftui/anygradient) — A color gradient.
- [ShadowStyle](https://developer.apple.com/documentation/swiftui/shadowstyle) — A style to use when rendering shadows.
- [Glass](https://developer.apple.com/documentation/swiftui/glass) — A structure that defines the configuration of the Liquid Glass material.
### Transforming colors

- [brightness(_:)](https://developer.apple.com/documentation/swiftui/view/brightness(_:)) — Brightens this view by the specified amount.
- [contrast(_:)](https://developer.apple.com/documentation/swiftui/view/contrast(_:)) — Sets the contrast and separation between similar colors in this view.
- [colorInvert()](https://developer.apple.com/documentation/swiftui/view/colorinvert()) — Inverts the colors in this view.
- [colorMultiply(_:)](https://developer.apple.com/documentation/swiftui/view/colormultiply(_:)) — Adds a color multiplication effect to this view.
- [saturation(_:)](https://developer.apple.com/documentation/swiftui/view/saturation(_:)) — Adjusts the color saturation of this view.
- [grayscale(_:)](https://developer.apple.com/documentation/swiftui/view/grayscale(_:)) — Adds a grayscale effect to this view.
- [hueRotation(_:)](https://developer.apple.com/documentation/swiftui/view/huerotation(_:)) — Applies a hue rotation effect to this view.
- [luminanceToAlpha()](https://developer.apple.com/documentation/swiftui/view/luminancetoalpha()) — Adds a luminance to alpha effect to this view.
- [materialActiveAppearance(_:)](https://developer.apple.com/documentation/swiftui/view/materialactiveappearance(_:)) — Sets an explicit active appearance for materials in this view.
- [materialActiveAppearance](https://developer.apple.com/documentation/swiftui/environmentvalues/materialactiveappearance) — The behavior materials should use for their active state, defaulting to `automatic`.
- [MaterialActiveAppearance](https://developer.apple.com/documentation/swiftui/materialactiveappearance) — The behavior for how materials appear active and inactive.
### Scaling, rotating, or transforming a view

- [scaledToFill()](https://developer.apple.com/documentation/swiftui/view/scaledtofill()) — Scales this view to fill its parent.
- [scaledToFit()](https://developer.apple.com/documentation/swiftui/view/scaledtofit()) — Scales this view to fit its parent.
- [scaleEffect(_:anchor:)](https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)) — Scales this view’s rendered output by the given amount in both the horizontal and vertical directions, relative to an anchor point.
- [scaleEffect(x:y:anchor:)](https://developer.apple.com/documentation/swiftui/view/scaleeffect(x:y:anchor:)) — Scales this view’s rendered output by the given horizontal and vertical amounts, relative to an anchor point.
- [scaleEffect(x:y:z:anchor:)](https://developer.apple.com/documentation/swiftui/view/scaleeffect(x:y:z:anchor:)) — Scales this view by the specified horizontal, vertical, and depth factors, relative to an anchor point.
- [aspectRatio(_:contentMode:)](https://developer.apple.com/documentation/swiftui/view/aspectratio(_:contentmode:)) — Constrains this view’s dimensions to the specified aspect ratio.
- [rotationEffect(_:anchor:)](https://developer.apple.com/documentation/swiftui/view/rotationeffect(_:anchor:)) — Rotates a view’s rendered output in two dimensions around the specified point.
- [rotation3DEffect(_:axis:anchor:anchorZ:perspective:)](https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:axis:anchor:anchorz:perspective:)) — Renders a view’s content as if it’s rotated in three dimensions around the specified axis.
- [perspectiveRotationEffect(_:axis:anchor:anchorZ:perspective:)](https://developer.apple.com/documentation/swiftui/view/perspectiverotationeffect(_:axis:anchor:anchorz:perspective:)) — Renders a view’s content as if it’s rotated in three dimensions around the specified axis.
- [rotation3DEffect(_:anchor:)](https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:anchor:)) — Rotates the view’s content by the specified 3D rotation value.
- [rotation3DEffect(_:axis:anchor:)](https://developer.apple.com/documentation/swiftui/view/rotation3deffect(_:axis:anchor:)) — Rotates the view’s content by an angle about an axis that you specify as a tuple of elements.
- [transformEffect(_:)](https://developer.apple.com/documentation/swiftui/view/transformeffect(_:)) — Applies an affine transformation to this view’s rendered output.
- [transform3DEffect(_:)](https://developer.apple.com/documentation/swiftui/view/transform3deffect(_:)) — Applies a 3D transformation to this view’s rendered output.
- [projectionEffect(_:)](https://developer.apple.com/documentation/swiftui/view/projectioneffect(_:)) — Applies a projection transformation to this view’s rendered output.
- [ProjectionTransform](https://developer.apple.com/documentation/swiftui/projectiontransform)
- [ContentMode](https://developer.apple.com/documentation/swiftui/contentmode) — Constants that define how a view’s content fills the available space.
### Masking and clipping

- [mask(alignment:_:)](https://developer.apple.com/documentation/swiftui/view/mask(alignment:_:)) — Masks this view using the alpha channel of the given view.
- [clipped(antialiased:)](https://developer.apple.com/documentation/swiftui/view/clipped(antialiased:)) — Clips this view to its bounding rectangular frame.
- [clipShape(_:style:)](https://developer.apple.com/documentation/swiftui/view/clipshape(_:style:)) — Sets a clipping shape for this view.
### Applying blur and shadows

- [blur(radius:opaque:)](https://developer.apple.com/documentation/swiftui/view/blur(radius:opaque:)) — Applies a Gaussian blur to this view.
- [shadow(color:radius:x:y:)](https://developer.apple.com/documentation/swiftui/view/shadow(color:radius:x:y:)) — Adds a shadow to this view.
- [ColorMatrix](https://developer.apple.com/documentation/swiftui/colormatrix) — A matrix to use in an RGBA color transformation.
### Applying effects based on geometry

- [visualEffect(_:)](https://developer.apple.com/documentation/swiftui/view/visualeffect(_:)) — Applies effects to this view, while providing access to layout information through a geometry proxy.
- [visualEffect3D(_:)](https://developer.apple.com/documentation/swiftui/view/visualeffect3d(_:)) — Applies effects to this view, while providing access to layout information through a 3D geometry proxy.
- [VisualEffect](https://developer.apple.com/documentation/swiftui/visualeffect) — Visual Effects change the visual appearance of a view without changing its ancestors or descendents.
- [EmptyVisualEffect](https://developer.apple.com/documentation/swiftui/emptyvisualeffect) — The base visual effect that you apply additional effect to.
### Compositing views

- [blendMode(_:)](https://developer.apple.com/documentation/swiftui/view/blendmode(_:)) — Sets the blend mode for compositing this view with overlapping views.
- [compositingGroup()](https://developer.apple.com/documentation/swiftui/view/compositinggroup()) — Wraps this view in a compositing group.
- [drawingGroup(opaque:colorMode:)](https://developer.apple.com/documentation/swiftui/view/drawinggroup(opaque:colormode:)) — Composites this view’s contents into an offscreen image before final display.
- [BlendMode](https://developer.apple.com/documentation/swiftui/blendmode) — Modes for compositing a view with overlapping content.
- [ColorRenderingMode](https://developer.apple.com/documentation/swiftui/colorrenderingmode) — The set of possible working color spaces for color-compositing operations.
- [CompositorContent](https://developer.apple.com/documentation/swiftui/compositorcontent)
- [CompositorContentBuilder](https://developer.apple.com/documentation/swiftui/compositorcontentbuilder) — A result builder for composing a collection of [doc://com.apple.SwiftUI/documentation/SwiftUI/CompositorContent](https://developer.apple.com/documentation/SwiftUI/CompositorContent) elements.
- [AnyCompositorContent](https://developer.apple.com/documentation/swiftui/anycompositorcontent) — Type erased compositor content.
### Measuring a view

- [GeometryReader](https://developer.apple.com/documentation/swiftui/geometryreader) — A container view that defines its content as a function of its own size and coordinate space.
- [GeometryReader3D](https://developer.apple.com/documentation/swiftui/geometryreader3d) — A container view that defines its content as a function of its own size and coordinate space.
- [GeometryProxy](https://developer.apple.com/documentation/swiftui/geometryproxy) — A proxy for access to the size and coordinate space (for anchor resolution) of the container view.
- [GeometryProxy3D](https://developer.apple.com/documentation/swiftui/geometryproxy3d) — A proxy for access to the size and coordinate space of the container view.
- [coordinateSpace(_:)](https://developer.apple.com/documentation/swiftui/view/coordinatespace(_:)) — Assigns a name to the view’s coordinate space, so other code can operate on dimensions like points and sizes relative to the named space.
- [CoordinateSpace](https://developer.apple.com/documentation/swiftui/coordinatespace) — A resolved coordinate space created by the coordinate space protocol.
- [CoordinateSpaceProtocol](https://developer.apple.com/documentation/swiftui/coordinatespaceprotocol) — A frame of reference within the layout system.
- [PhysicalMetric](https://developer.apple.com/documentation/swiftui/physicalmetric) — Provides access to a value in points that corresponds to the specified physical measurement.
- [PhysicalMetricsConverter](https://developer.apple.com/documentation/swiftui/physicalmetricsconverter) — A physical metrics converter provides conversion between point values and their extent in 3D space, in the form of physical length measurements.
### Responding to a geometry change

- [onGeometryChange(for:of:action:)](https://developer.apple.com/documentation/swiftui/view/ongeometrychange(for:of:action:)) — Adds an action to be performed when a value, created from a geometry proxy, changes.
### Accessing Metal shaders

- [colorEffect(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/coloreffect(_:isenabled:)) — Returns a new view that applies `shader` to `self` as a filter effect on the color of each pixel.
- [distortionEffect(_:maxSampleOffset:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/distortioneffect(_:maxsampleoffset:isenabled:)) — Returns a new view that applies `shader` to `self` as a geometric distortion effect on the location of each pixel.
- [layerEffect(_:maxSampleOffset:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/layereffect(_:maxsampleoffset:isenabled:)) — Returns a new view that applies `shader` to `self` as a filter on the raster layer created from `self`.
- [Shader](https://developer.apple.com/documentation/swiftui/shader) — A reference to a function in a Metal shader library, along with its bound uniform argument values.
- [ShaderFunction](https://developer.apple.com/documentation/swiftui/shaderfunction) — A reference to a function in a Metal shader library.
- [ShaderLibrary](https://developer.apple.com/documentation/swiftui/shaderlibrary) — A Metal shader library.
### Accessing geometric constructs

- [Axis](https://developer.apple.com/documentation/swiftui/axis) — The horizontal or vertical dimension in a 2D coordinate system.
- [Angle](https://developer.apple.com/documentation/swiftui/angle) — A geometric angle whose value you access in either radians or degrees.
- [UnitPoint](https://developer.apple.com/documentation/swiftui/unitpoint) — A normalized 2D point in a view’s coordinate space.
- [UnitPoint3D](https://developer.apple.com/documentation/swiftui/unitpoint3d) — A normalized 3D point in a view’s coordinate space.
- [Anchor](https://developer.apple.com/documentation/swiftui/anchor) — An opaque value derived from an anchor source and a particular view.
- [DepthAlignmentID](https://developer.apple.com/documentation/swiftui/depthalignmentid)
- [Alignment3D](https://developer.apple.com/documentation/swiftui/alignment3d) — An alignment in all three axes.
- [GeometryProxyCoordinateSpace3D](https://developer.apple.com/documentation/swiftui/geometryproxycoordinatespace3d) — A representation of a `GeometryProxy3D` which can be used for `CoordinateSpace3D` based conversions.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Drawing-and-graphics](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Drawing-and-graphics)*
--- END FILE ---

--- FILE: Controls-and-indicators.md ---
# Controls and indicators

**Display values and get user selections.**


## Overview

SwiftUI provides controls that enable user interaction specific to each platform and context. For example, people can initiate events with buttons and links, or choose among a set of discrete values with different kinds of pickers. You can also display information to the user with indicators like progress views and gauges.

![Image](controls-and-indicators-hero)

Use these built-in controls and indicators when composing custom views, and style them to match the needs of your app’s user interface. For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/menus-and-actions, doc://com.apple.documentation/design/Human-Interface-Guidelines/selection-and-input, and doc://com.apple.documentation/design/Human-Interface-Guidelines/status in the Human Interface Guidelines.

## Topics

### Creating buttons

- [Button](https://developer.apple.com/documentation/swiftui/button) — A control that initiates an action.
- [buttonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/buttonstyle(_:)) — Sets the style for buttons within this view to a button style with a custom appearance and standard interaction behavior.
- [buttonBorderShape(_:)](https://developer.apple.com/documentation/swiftui/view/buttonbordershape(_:)) — Sets the border shape for buttons in this view.
- [buttonRepeatBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/buttonrepeatbehavior(_:)) — Sets whether buttons in this view should repeatedly trigger their actions on prolonged interactions.
- [buttonRepeatBehavior](https://developer.apple.com/documentation/swiftui/environmentvalues/buttonrepeatbehavior) — Whether buttons with this associated environment should repeatedly trigger their actions on prolonged interactions.
- [ButtonBorderShape](https://developer.apple.com/documentation/swiftui/buttonbordershape) — A shape used to draw a button’s border.
- [ButtonRole](https://developer.apple.com/documentation/swiftui/buttonrole) — A value that describes the purpose of a button.
- [ButtonRepeatBehavior](https://developer.apple.com/documentation/swiftui/buttonrepeatbehavior) — The options for controlling the repeatability of button actions.
- [ButtonSizing](https://developer.apple.com/documentation/swiftui/buttonsizing) — The sizing behavior of `Button`s and other button-like controls.
### Creating special-purpose buttons

- [EditButton](https://developer.apple.com/documentation/swiftui/editbutton) — A button that toggles the edit mode environment value.
- [PasteButton](https://developer.apple.com/documentation/swiftui/pastebutton) — A system button that reads items from the pasteboard and delivers it to a closure.
- [RenameButton](https://developer.apple.com/documentation/swiftui/renamebutton) — A button that triggers a standard rename action.
### Linking to other content

- [Link](https://developer.apple.com/documentation/swiftui/link) — A control for navigating to a URL.
- [ShareLink](https://developer.apple.com/documentation/swiftui/sharelink) — A view that controls a sharing presentation.
- [SharePreview](https://developer.apple.com/documentation/swiftui/sharepreview) — A representation of a type to display in a share preview.
- [TextFieldLink](https://developer.apple.com/documentation/swiftui/textfieldlink) — A control that requests text input from the user when pressed.
- [HelpLink](https://developer.apple.com/documentation/swiftui/helplink) — A button with a standard appearance that opens app-specific help documentation.
### Getting numeric inputs

- [Slider](https://developer.apple.com/documentation/swiftui/slider) — A control for selecting a value from a bounded linear range of values.
- [Stepper](https://developer.apple.com/documentation/swiftui/stepper) — A control that performs increment and decrement actions.
- [Toggle](https://developer.apple.com/documentation/swiftui/toggle) — A control that toggles between on and off states.
- [toggleStyle(_:)](https://developer.apple.com/documentation/swiftui/view/togglestyle(_:)) — Sets the style for toggles in a view hierarchy.
### Choosing from a set of options

- [Picker](https://developer.apple.com/documentation/swiftui/picker) — A control for selecting from a set of mutually exclusive values.
- [pickerStyle(_:)](https://developer.apple.com/documentation/swiftui/view/pickerstyle(_:)) — Sets the style for pickers within this view.
- [horizontalRadioGroupLayout()](https://developer.apple.com/documentation/swiftui/view/horizontalradiogrouplayout()) — Sets the style for radio group style pickers within this view to be horizontally positioned with the radio buttons inside the layout.
- [defaultWheelPickerItemHeight(_:)](https://developer.apple.com/documentation/swiftui/view/defaultwheelpickeritemheight(_:)) — Sets the default wheel-style picker item height.
- [defaultWheelPickerItemHeight](https://developer.apple.com/documentation/swiftui/environmentvalues/defaultwheelpickeritemheight) — The default height of an item in a wheel-style picker, such as a date picker.
- [paletteSelectionEffect(_:)](https://developer.apple.com/documentation/swiftui/view/paletteselectioneffect(_:)) — Specifies the selection effect to apply to a palette item.
- [PaletteSelectionEffect](https://developer.apple.com/documentation/swiftui/paletteselectioneffect) — The selection effect to apply to a palette item.
### Choosing dates

- [DatePicker](https://developer.apple.com/documentation/swiftui/datepicker) — A control for selecting an absolute date.
- [datePickerStyle(_:)](https://developer.apple.com/documentation/swiftui/view/datepickerstyle(_:)) — Sets the style for date pickers within this view.
- [MultiDatePicker](https://developer.apple.com/documentation/swiftui/multidatepicker) — A control for picking multiple dates.
- [calendar](https://developer.apple.com/documentation/swiftui/environmentvalues/calendar) — The current calendar that views should use when handling dates.
- [timeZone](https://developer.apple.com/documentation/swiftui/environmentvalues/timezone) — The current time zone that views should use when handling dates.
### Choosing a color

- [ColorPicker](https://developer.apple.com/documentation/swiftui/colorpicker) — A control used to select a color from the system color picker UI.
### Indicating a value

- [Gauge](https://developer.apple.com/documentation/swiftui/gauge) — A view that shows a value within a range.
- [gaugeStyle(_:)](https://developer.apple.com/documentation/swiftui/view/gaugestyle(_:)) — Sets the style for gauges within this view.
- [ProgressView](https://developer.apple.com/documentation/swiftui/progressview) — A view that shows the progress toward completion of a task.
- [progressViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/progressviewstyle(_:)) — Sets the style for progress views in this view.
- [DefaultDateProgressLabel](https://developer.apple.com/documentation/swiftui/defaultdateprogresslabel) — The default type of the current value label when used by a date-relative progress view.
- [DefaultButtonLabel](https://developer.apple.com/documentation/swiftui/defaultbuttonlabel) — The default label to use for a button.
### Indicating missing content

- [ContentUnavailableView](https://developer.apple.com/documentation/swiftui/contentunavailableview) — An interface, consisting of a label and additional content, that you display when the content of your app is unavailable to users.
### Providing haptic feedback

- [sensoryFeedback(_:trigger:)](https://developer.apple.com/documentation/swiftui/view/sensoryfeedback(_:trigger:)) — Plays the specified `feedback` when the provided `trigger` value changes.
- [sensoryFeedback(trigger:_:)](https://developer.apple.com/documentation/swiftui/view/sensoryfeedback(trigger:_:)) — Plays feedback when returned from the `feedback` closure after the provided `trigger` value changes.
- [sensoryFeedback(_:trigger:condition:)](https://developer.apple.com/documentation/swiftui/view/sensoryfeedback(_:trigger:condition:)) — Plays the specified `feedback` when the provided `trigger` value changes and the `condition` closure returns `true`.
- [SensoryFeedback](https://developer.apple.com/documentation/swiftui/sensoryfeedback) — Represents a type of haptic and/or audio feedback that can be played.
### Sizing controls

- [controlSize(_:)](https://developer.apple.com/documentation/swiftui/view/controlsize(_:)) — Sets the size for controls within this view.
- [controlSize](https://developer.apple.com/documentation/swiftui/environmentvalues/controlsize) — The size to apply to controls within a view.
- [ControlSize](https://developer.apple.com/documentation/swiftui/controlsize) — The size classes, like regular or small, that you can apply to controls within a view.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Controls-and-indicators](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Controls-and-indicators)*
--- END FILE ---

--- FILE: Modal-presentations.md ---
# Modal presentations

**Present content in a separate view that offers focused interaction.**


## Overview

To draw attention to an important, narrowly scoped task, you display a modal presentation, like an alert, popover, sheet, or confirmation dialog.

![Image](modal-presentations-hero)

In SwiftUI, you create a modal presentation using a view modifier that defines how the presentation looks and the condition under which SwiftUI presents it. SwiftUI detects when the condition changes and makes the presentation for you. Because you provide a [doc://com.apple.SwiftUI/documentation/SwiftUI/Binding](https://developer.apple.com/documentation/SwiftUI/Binding) to the condition that initiates the presentation, SwiftUI can reset the underlying value when the user dismisses the presentation.

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/modality in the Human Interface Guidelines.

## Topics

### Configuring a dialog

- [DialogSeverity](https://developer.apple.com/documentation/swiftui/dialogseverity) — The severity of an alert or confirmation dialog.
### Showing a sheet, cover, or popover

- [sheet(isPresented:onDismiss:content:)](https://developer.apple.com/documentation/swiftui/view/sheet(ispresented:ondismiss:content:)) — Presents a sheet when a binding to a Boolean value that you provide is true.
- [sheet(item:onDismiss:content:)](https://developer.apple.com/documentation/swiftui/view/sheet(item:ondismiss:content:)) — Presents a sheet using the given item as a data source for the sheet’s content.
- [fullScreenCover(isPresented:onDismiss:content:)](https://developer.apple.com/documentation/swiftui/view/fullscreencover(ispresented:ondismiss:content:)) — Presents a modal view that covers as much of the screen as possible when binding to a Boolean value you provide is true.
- [fullScreenCover(item:onDismiss:content:)](https://developer.apple.com/documentation/swiftui/view/fullscreencover(item:ondismiss:content:)) — Presents a modal view that covers as much of the screen as possible using the binding you provide as a data source for the sheet’s content.
- [popover(item:attachmentAnchor:arrowEdge:content:)](https://developer.apple.com/documentation/swiftui/view/popover(item:attachmentanchor:arrowedge:content:)) — Presents a popover using the given item as a data source for the popover’s content.
- [popover(isPresented:attachmentAnchor:arrowEdge:content:)](https://developer.apple.com/documentation/swiftui/view/popover(ispresented:attachmentanchor:arrowedge:content:)) — Presents a popover when a given condition is true.
- [PopoverAttachmentAnchor](https://developer.apple.com/documentation/swiftui/popoverattachmentanchor) — An attachment anchor for a popover.
### Adapting a presentation size

- [presentationCompactAdaptation(horizontal:vertical:)](https://developer.apple.com/documentation/swiftui/view/presentationcompactadaptation(horizontal:vertical:)) — Specifies how to adapt a presentation to horizontally and vertically compact size classes.
- [presentationCompactAdaptation(_:)](https://developer.apple.com/documentation/swiftui/view/presentationcompactadaptation(_:)) — Specifies how to adapt a presentation to compact size classes.
- [PresentationAdaptation](https://developer.apple.com/documentation/swiftui/presentationadaptation) — Strategies for adapting a presentation to a different size class.
- [presentationSizing(_:)](https://developer.apple.com/documentation/swiftui/view/presentationsizing(_:)) — Sets the sizing of the containing presentation.
- [PresentationSizing](https://developer.apple.com/documentation/swiftui/presentationsizing) — A type that defines the size of the presentation content and how the presentation size adjusts to its content’s size changing.
- [PresentationSizingRoot](https://developer.apple.com/documentation/swiftui/presentationsizingroot) — A proxy to a view provided to the presentation with a defined presentation size.
- [PresentationSizingContext](https://developer.apple.com/documentation/swiftui/presentationsizingcontext) — Contextual information about a presentation.
### Configuring a sheet’s height

- [presentationDetents(_:)](https://developer.apple.com/documentation/swiftui/view/presentationdetents(_:)) — Sets the available detents for the enclosing sheet.
- [presentationDetents(_:selection:)](https://developer.apple.com/documentation/swiftui/view/presentationdetents(_:selection:)) — Sets the available detents for the enclosing sheet, giving you programmatic control of the currently selected detent.
- [presentationContentInteraction(_:)](https://developer.apple.com/documentation/swiftui/view/presentationcontentinteraction(_:)) — Configures the behavior of swipe gestures on a presentation.
- [presentationDragIndicator(_:)](https://developer.apple.com/documentation/swiftui/view/presentationdragindicator(_:)) — Sets the visibility of the drag indicator on top of a sheet.
- [PresentationDetent](https://developer.apple.com/documentation/swiftui/presentationdetent) — A type that represents a height where a sheet naturally rests.
- [CustomPresentationDetent](https://developer.apple.com/documentation/swiftui/custompresentationdetent) — The definition of a custom detent with a calculated height.
- [PresentationContentInteraction](https://developer.apple.com/documentation/swiftui/presentationcontentinteraction) — A behavior that you can use to influence how a presentation responds to swipe gestures.
### Styling a sheet and its background

- [presentationCornerRadius(_:)](https://developer.apple.com/documentation/swiftui/view/presentationcornerradius(_:)) — Requests that the presentation have a specific corner radius.
- [presentationBackground(_:)](https://developer.apple.com/documentation/swiftui/view/presentationbackground(_:)) — Sets the presentation background of the enclosing sheet using a shape style.
- [presentationBackground(alignment:content:)](https://developer.apple.com/documentation/swiftui/view/presentationbackground(alignment:content:)) — Sets the presentation background of the enclosing sheet to a custom view.
- [presentationBackgroundInteraction(_:)](https://developer.apple.com/documentation/swiftui/view/presentationbackgroundinteraction(_:)) — Controls whether people can interact with the view behind a presentation.
- [PresentationBackgroundInteraction](https://developer.apple.com/documentation/swiftui/presentationbackgroundinteraction) — The kinds of interaction available to views behind a presentation.
### Presenting an alert

- [AlertScene](https://developer.apple.com/documentation/swiftui/alertscene) — A scene that renders itself as a standalone alert dialog.
- [alert(_:isPresented:actions:)](https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:)) — Presents an alert when a given condition is true, using a text view for the title.
- [alert(_:isPresented:presenting:actions:)](https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:)) — Presents an alert using the given data to produce the alert’s content and a text view as a title.
- [alert(isPresented:error:actions:)](https://developer.apple.com/documentation/swiftui/view/alert(ispresented:error:actions:)) — Presents an alert when an error is present.
- [alert(_:isPresented:actions:message:)](https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:actions:message:)) — Presents an alert with a message when a given condition is true using a text view as a title.
- [alert(_:isPresented:presenting:actions:message:)](https://developer.apple.com/documentation/swiftui/view/alert(_:ispresented:presenting:actions:message:)) — Presents an alert with a message using the given data to produce the alert’s content and a text view for a title.
- [alert(isPresented:error:actions:message:)](https://developer.apple.com/documentation/swiftui/view/alert(ispresented:error:actions:message:)) — Presents an alert with a message when an error is present.
### Getting confirmation for an action

- [confirmationDialog(_:isPresented:titleVisibility:actions:)](https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:)) — Presents a confirmation dialog when a given condition is true, using a text view for the title.
- [confirmationDialog(_:isPresented:titleVisibility:presenting:actions:)](https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:)) — Presents a confirmation dialog using data to produce the dialog’s content and a text view for the title.
- [dismissalConfirmationDialog(_:shouldPresent:actions:)](https://developer.apple.com/documentation/swiftui/view/dismissalconfirmationdialog(_:shouldpresent:actions:)) — Presents a confirmation dialog when a dismiss action has been triggered.
### Showing a confirmation dialog with a message

- [confirmationDialog(_:isPresented:titleVisibility:actions:message:)](https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:actions:message:)) — Presents a confirmation dialog with a message when a given condition is true, using a text view for the title.
- [confirmationDialog(_:isPresented:titleVisibility:presenting:actions:message:)](https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:message:)) — Presents a confirmation dialog with a message using data to produce the dialog’s content and a text view for the message.
- [dismissalConfirmationDialog(_:shouldPresent:actions:message:)](https://developer.apple.com/documentation/swiftui/view/dismissalconfirmationdialog(_:shouldpresent:actions:message:)) — Presents a confirmation dialog when a dismiss action has been triggered.
### Configuring a dialog

- [dialogIcon(_:)](https://developer.apple.com/documentation/swiftui/view/dialogicon(_:)) — Configures the icon used by dialogs within this view.
- [dialogIcon(_:)](https://developer.apple.com/documentation/swiftui/scene/dialogicon(_:)) — Configures the icon used by alerts.
- [dialogSeverity(_:)](https://developer.apple.com/documentation/swiftui/view/dialogseverity(_:))
- [dialogSeverity(_:)](https://developer.apple.com/documentation/swiftui/scene/dialogseverity(_:)) — Sets the severity for alerts.
- [dialogSuppressionToggle(isSuppressed:)](https://developer.apple.com/documentation/swiftui/view/dialogsuppressiontoggle(issuppressed:)) — Enables user suppression of dialogs and alerts presented within `self`, with a default suppression message on macOS. Unused on other platforms.
- [dialogSuppressionToggle(isSuppressed:)](https://developer.apple.com/documentation/swiftui/scene/dialogsuppressiontoggle(issuppressed:)) — Enables user suppression of an alert with a custom suppression message.
- [dialogSuppressionToggle(_:isSuppressed:)](https://developer.apple.com/documentation/swiftui/view/dialogsuppressiontoggle(_:issuppressed:)) — Enables user suppression of dialogs and alerts presented within `self`, with a custom suppression message on macOS. Unused on other platforms.
### Exporting to file

- [fileExporter(isPresented:document:contentType:defaultFilename:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:document:contenttype:defaultfilename:oncompletion:)) — Presents a system interface for exporting a document that’s stored in a value type, like a structure, to a file on disk.
- [fileExporter(isPresented:documents:contentType:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:documents:contenttype:oncompletion:)) — Presents a system interface for exporting a collection of value type documents to files on disk.
- [fileExporter(isPresented:document:contentTypes:defaultFilename:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:document:contenttypes:defaultfilename:oncompletion:oncancellation:)) — Presents a system interface for allowing the user to export a `FileDocument` to a file on disk.
- [fileExporter(isPresented:documents:contentTypes:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:documents:contenttypes:oncompletion:oncancellation:)) — Presents a system dialog for allowing the user to export a collection of documents that conform to `FileDocument` to files on disk.
- [fileExporter(isPresented:item:contentTypes:defaultFilename:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:item:contenttypes:defaultfilename:oncompletion:oncancellation:)) — Presents a system interface allowing the user to export a `Transferable` item to file on disk.
- [fileExporter(isPresented:items:contentTypes:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/fileexporter(ispresented:items:contenttypes:oncompletion:oncancellation:)) — Presents a system interface allowing the user to export a collection of items to files on disk.
- [fileExporterFilenameLabel(_:)](https://developer.apple.com/documentation/swiftui/view/fileexporterfilenamelabel(_:)) — On macOS, configures the `fileExporter` with a label for the file name field.
### Importing from file

- [fileImporter(isPresented:allowedContentTypes:allowsMultipleSelection:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/fileimporter(ispresented:allowedcontenttypes:allowsmultipleselection:oncompletion:)) — Presents a system interface for allowing the user to import multiple files.
- [fileImporter(isPresented:allowedContentTypes:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/fileimporter(ispresented:allowedcontenttypes:oncompletion:)) — Presents a system interface for allowing the user to import an existing file.
- [fileImporter(isPresented:allowedContentTypes:allowsMultipleSelection:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/fileimporter(ispresented:allowedcontenttypes:allowsmultipleselection:oncompletion:oncancellation:)) — Presents a system dialog for allowing the user to import multiple files.
### Moving a file

- [fileMover(isPresented:file:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:file:oncompletion:)) — Presents a system interface for allowing the user to move an existing file to a new location.
- [fileMover(isPresented:files:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:files:oncompletion:)) — Presents a system interface for allowing the user to move a collection of existing files to a new location.
- [fileMover(isPresented:file:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:file:oncompletion:oncancellation:)) — Presents a system dialog for allowing the user to move an existing file to a new location.
- [fileMover(isPresented:files:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/filemover(ispresented:files:oncompletion:oncancellation:)) — Presents a system dialog for allowing the user to move a collection of existing files to a new location.
### Configuring a file dialog

- [fileDialogBrowserOptions(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogbrowseroptions(_:)) — On macOS, configures the `fileExporter`, `fileImporter`, or `fileMover` to provide a refined URL search experience: include or exclude hidden files, allow searching by tag, etc.
- [fileDialogConfirmationLabel(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogconfirmationlabel(_:)) — On macOS, configures the the `fileExporter`, `fileImporter`, or `fileMover` with a custom confirmation button label.
- [fileDialogCustomizationID(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogcustomizationid(_:)) — On macOS, configures the `fileExporter`, `fileImporter`, or `fileMover` to persist and restore the file dialog configuration.
- [fileDialogDefaultDirectory(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogdefaultdirectory(_:)) — Configures the `fileExporter`, `fileImporter`, or `fileMover` to open with the specified default directory.
- [fileDialogImportsUnresolvedAliases(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogimportsunresolvedaliases(_:)) — On macOS, configures the `fileExporter`, `fileImporter`, or `fileMover` behavior when a user chooses an alias.
- [fileDialogMessage(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogmessage(_:)) — On macOS, configures the the `fileExporter`, `fileImporter`, or `fileMover` with a custom text that is presented to the user, similar to a title.
- [fileDialogURLEnabled(_:)](https://developer.apple.com/documentation/swiftui/view/filedialogurlenabled(_:)) — On macOS, configures the the `fileImporter` or `fileMover` to conditionally disable presented URLs.
- [FileDialogBrowserOptions](https://developer.apple.com/documentation/swiftui/filedialogbrowseroptions) — The way that file dialogs present the file system.
### Presenting an inspector

- [inspector(isPresented:content:)](https://developer.apple.com/documentation/swiftui/view/inspector(ispresented:content:)) — Inserts an inspector at the applied position in the view hierarchy.
- [inspectorColumnWidth(_:)](https://developer.apple.com/documentation/swiftui/view/inspectorcolumnwidth(_:)) — Sets a fixed, preferred width for the inspector containing this view when presented as a trailing column.
- [inspectorColumnWidth(min:ideal:max:)](https://developer.apple.com/documentation/swiftui/view/inspectorcolumnwidth(min:ideal:max:)) — Sets a flexible, preferred width for the inspector in a trailing-column presentation.
### Dismissing a presentation

- [isPresented](https://developer.apple.com/documentation/swiftui/environmentvalues/ispresented) — A Boolean value that indicates whether the view associated with this environment is currently presented.
- [dismiss](https://developer.apple.com/documentation/swiftui/environmentvalues/dismiss) — An action that dismisses the current presentation.
- [DismissAction](https://developer.apple.com/documentation/swiftui/dismissaction) — An action that dismisses a presentation.
- [interactiveDismissDisabled(_:)](https://developer.apple.com/documentation/swiftui/view/interactivedismissdisabled(_:)) — Conditionally prevents interactive dismissal of presentations like popovers, sheets, and inspectors.
### Deprecated modal presentations

- [Alert](https://developer.apple.com/documentation/swiftui/alert) — A representation of an alert presentation.
- [ActionSheet](https://developer.apple.com/documentation/swiftui/actionsheet) — A representation of an action sheet presentation.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Modal-presentations](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Modal-presentations)*
--- END FILE ---

--- FILE: Building-a-document-based-app-with-SwiftUI.md ---
# Building a document-based app with SwiftUI

**Create, save, and open documents in a multiplatform app.**

## Availability

- **iOS** 18.0+
- **iPadOS** 18.0+
- **macOS** 15.0+
- **Xcode** 16.0+


## Overview

The Writing App sample builds a document-based app for iOS, iPadOS, and macOS. In the app definition, it has a [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroup](https://developer.apple.com/documentation/SwiftUI/DocumentGroup) scene, and its document type conforms to the [doc://com.apple.SwiftUI/documentation/SwiftUI/FileDocument](https://developer.apple.com/documentation/SwiftUI/FileDocument) protocol. People can create a writing app document, modify the title and contents of the document, and read the story in focus mode.

![Image](writing-app-ipad.png)


## Configure the sample code project

To build and run this sample on your device, select your development team for the project’s target using these steps:

1. Open the sample with the latest version of Xcode.

2. Select the top-level project.

3. For the project’s target, choose your team from the Team pop-up menu in the Signing & Capabilities pane to let Xcode automatically manage your provisioning profile.


## Define the app’s scene

A document-based SwiftUI app returns a `DocumentGroup` scene from its `body` property. The `newDocument` parameter that an app supplies to the document group’s [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroup/init(newDocument:editor:)-4toe2](https://developer.apple.com/documentation/SwiftUI/DocumentGroup/init(newDocument:editor:)-4toe2) initializer conforms to either [doc://com.apple.SwiftUI/documentation/SwiftUI/FileDocument](https://developer.apple.com/documentation/SwiftUI/FileDocument) or [doc://com.apple.SwiftUI/documentation/SwiftUI/ReferenceFileDocument](https://developer.apple.com/documentation/SwiftUI/ReferenceFileDocument). In this sample, the document type conforms to `FileDocument`. The trailing closure of the initializer returns a view that renders the document’s contents:

```swift
@main
struct WritingApp: App {
    var body: some Scene {
        DocumentGroup(newDocument: WritingAppDocument()) { file in
            StoryView(document: file.$document)
        }
    }
}
```


## Customize the iOS and iPadOS launch experience

You can update the default launch experience on iOS and iPadOS with a custom title, action buttons, and screen background. To add an action button with a custom label, use [doc://com.apple.SwiftUI/documentation/SwiftUI/NewDocumentButton](https://developer.apple.com/documentation/SwiftUI/NewDocumentButton) to replace the default label. You can customize the background in many ways such as adding a view or a `backgroundStyle` with an initializer, for example [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:backgroundStyle:_:backgroundAccessoryView:overlayAccessoryView:)-2d13c](https://developer.apple.com/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:backgroundStyle:_:backgroundAccessoryView:overlayAccessoryView:)-2d13c). This sample customizes the background of the title view, using the [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:)-2iefz](https://developer.apple.com/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:)-2iefz) initializer:

```swift
DocumentGroupLaunchScene("Writing App") {
    NewDocumentButton("Start Writing")
} background: {
    Image(.pinkJungle)
    .resizable()
    .scaledToFill()
    .ignoresSafeArea()
} 
```

You can also add accessories to the scene using initializers such as [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:backgroundAccessoryView:)-1valf](https://developer.apple.com/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:backgroundAccessoryView:)-1valf) and [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:overlayAccessoryView:)-1143c](https://developer.apple.com/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:overlayAccessoryView:)-1143c) depending on the positioning.

```swift
overlayAccessoryView: { _ in
    AccessoryView()
}
```

This sample contains two accessories in the overlay position that it defines in `AccessoryView`. It customizes the accessories by applying modifiers, including [doc://com.apple.SwiftUI/documentation/SwiftUI/View/offset(x:y:)](https://developer.apple.com/documentation/SwiftUI/View/offset(x:y:)) and [doc://com.apple.SwiftUI/documentation/SwiftUI/View/frame(width:height:alignment:)](https://developer.apple.com/documentation/SwiftUI/View/frame(width:height:alignment:)).

```swift
ZStack {
    Image(.robot)
        .resizable()
        .offset(x: size.width / 2 - 450, y: size.height / 2 - 300)
        .scaledToFit()
        .frame(width: 200)
        .opacity(horizontal == .compact ? 0 : 1)
    Image(.plant)
        .resizable()
        .offset(x: size.width / 2 + 250, y: size.height / 2 - 225)
        .scaledToFit()
        .frame(width: 200)
        .opacity(horizontal == .compact ? 0 : 1)
}
```

To add both background and overlay accessories, use an initializer, such as [doc://com.apple.SwiftUI/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:backgroundAccessoryView:overlayAccessoryView:)-1re6d](https://developer.apple.com/documentation/SwiftUI/DocumentGroupLaunchScene/init(_:_:background:backgroundAccessoryView:overlayAccessoryView:)-1re6d). If you don’t provide any accessories, the system displays two faded sheets below the title view by default. In macOS, this sample displays the default system document browser on launch. You may wish to add an additional experience on launch.


## Create the data model

This sample has a data model that defines a story as a `String`, it initializes `story` with an empty string:

```swift
var story: String

init(text: String = "") {
    self.story = text
}
```


## Adopt the file document protocol

The `WritingAppDocument` structure adopts the `FileDocument` protocol to serialize documents to and from files. The [doc://com.apple.SwiftUI/documentation/SwiftUI/FileDocument/readableContentTypes](https://developer.apple.com/documentation/SwiftUI/FileDocument/readableContentTypes) property defines the types that the sample can read and write, specifically, the `.writingAppDocument` type:

```swift
static var readableContentTypes: [UTType] { [.writingAppDocument] }
```

The [doc://com.apple.SwiftUI/documentation/SwiftUI/FileDocument/init(configuration:)](https://developer.apple.com/documentation/SwiftUI/FileDocument/init(configuration:)) initializer loads documents from a file. After reading the file’s data using the [doc://com.apple.SwiftUI/documentation/SwiftUI/FileDocumentReadConfiguration/file](https://developer.apple.com/documentation/SwiftUI/FileDocumentReadConfiguration/file) property of the `configuration` input, it deserializes the data and stores it in the document’s data model:

```swift
init(configuration: ReadConfiguration) throws {
    guard let data = configuration.file.regularFileContents,
          let string = String(data: data, encoding: .utf8)
    else {
        throw CocoaError(.fileReadCorruptFile)
    }
    story = string
}
```

When a person writes a document, SwiftUI calls the [doc://com.apple.SwiftUI/documentation/SwiftUI/FileDocument/fileWrapper(configuration:)](https://developer.apple.com/documentation/SwiftUI/FileDocument/fileWrapper(configuration:)) function to serialize the data model into a `FileWrapper` value that represents the data in the file system:

```swift
func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
    let data = Data(story.utf8)
    return .init(regularFileWithContents: data)
}
```

Because the document type conforms to `FileDocument`, this sample handles undo actions automatically.


## Export a custom document type

The app defines and exports a custom content type for the documents it creates. It declares this custom type in the project’s [doc://com.apple.documentation/documentation/BundleResources/Information-Property-List](https://developer.apple.com/documentation/BundleResources/Information-Property-List) file under the [doc://com.apple.documentation/documentation/BundleResources/Information-Property-List/UTExportedTypeDeclarations](https://developer.apple.com/documentation/BundleResources/Information-Property-List/UTExportedTypeDeclarations) key. This sample uses `com.example.writingAppDocument` as the identifier in the `Info.plist` file:

```swift
<key>CFBundleDocumentTypes</key>
<array>
    <dict>
        <key>CFBundleTypeRole</key>
        <string>Editor</string>
        <key>LSHandlerRank</key>
        <string>Default</string>
        <key>LSItemContentTypes</key>
        <array>
            <string>com.example.writingAppDocument</string>
        </array>
        <key>NSUbiquitousDocumentUserActivityType</key>
        <string>$(PRODUCT_BUNDLE_IDENTIFIER).exampledocument</string>
    </dict>
</array>
<key>UTExportedTypeDeclarations</key>
<array>
    <dict>
        <key>UTTypeConformsTo</key>
        <array>
            <string>public.utf8-plain-text</string>
        </array>
        <key>UTTypeDescription</key>
        <string>Writing App Document</string>
        <key>UTTypeIconFiles</key>
        <array/>
        <key>UTTypeIdentifier</key>
        <string>com.example.writingAppDocument</string>
        <key>UTTypeTagSpecification</key>
        <dict>
            <key>public.filename-extension</key>
            <array>
                <string>story</string>
            </array>
        </dict>
    </dict>
</array>
```

For convenience, you can also define the content type in code. For example:

```swift
extension UTType {
    static var writingapp: UTType {
        UTType(exportedAs: "com.example.writingAppDocument")
    }
}
```

To make sure that the operating system knows that your application can open files with the format described in the `Info.plist`, it defines the file extension `story` for the content type. For more information about custom file and data types, see [doc://com.apple.documentation/documentation/UniformTypeIdentifiers/defining-file-and-data-types-for-your-app](https://developer.apple.com/documentation/UniformTypeIdentifiers/defining-file-and-data-types-for-your-app).


#### Related samples


### Related Links

- doc://com.apple.SwiftUI/documentation/SwiftUI/Building-a-document-based-app-using-SwiftData


#### Related articles


### Related Links

- doc://com.apple.documentation/documentation/UniformTypeIdentifiers/defining-file-and-data-types-for-your-app

- doc://com.apple.documentation/documentation/UIKit/customizing-a-document-based-app-s-launch-experience


#### Related videos


### Related Links

- doc://com.apple.documentation/videos/play/wwdc2024/10132

### Related Resources

- [Building a document-based app using SwiftData](/documentation/swiftui/building-a-document-based-app-using-swiftdata)

### Related Resources

- [Defining file and data types for your app](/documentation/UniformTypeIdentifiers/defining-file-and-data-types-for-your-app)
- [Customizing a document-based app’s launch experience](/documentation/UIKit/customizing-a-document-based-app-s-launch-experience)

### Related Resources

- [Evolve your document launch experience](https://developer.apple.com/videos/play/wwdc2024/10132)

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Building-a-document-based-app-with-SwiftUI](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Building-a-document-based-app-with-SwiftUI)*
--- END FILE ---

--- FILE: Navigation.md ---
# Navigation

**Enable people to move between different parts of your app’s view hierarchy within a scene.**


## Overview

Use navigation containers to provide structure to your app’s user interface, enabling people to easily move among the parts of your app.

![Image](navigation-hero)

For example, people can move forward and backward through a stack of views using a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack), or choose which view to display from a tab bar using a [doc://com.apple.SwiftUI/documentation/SwiftUI/TabView](https://developer.apple.com/documentation/SwiftUI/TabView).

Configure navigation containers by adding view modifiers like [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationSplitViewStyle(_:)) to the container. Use other modifiers on the views inside the container to affect the container’s behavior when showing that view. For example, you can use [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationTitle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationTitle(_:)) on a view to provide a toolbar title to display when showing that view.

## Topics

### Essentials

- [Understanding the navigation stack](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack) — Learn about the navigation stack, links, and how to manage navigation types in your app’s structure.
### Presenting views in columns

- [Bringing robust navigation structure to your SwiftUI app](https://developer.apple.com/documentation/swiftui/bringing-robust-navigation-structure-to-your-swiftui-app) — Use navigation links, stacks, destinations, and paths to provide a streamlined experience for all platforms, as well as behaviors such as deep linking and state restoration.
- [Migrating to new navigation types](https://developer.apple.com/documentation/swiftui/migrating-to-new-navigation-types) — Improve navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.
- [NavigationSplitView](https://developer.apple.com/documentation/swiftui/navigationsplitview) — A view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.
- [navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewstyle(_:)) — Sets the style for navigation split views within this view.
- [navigationSplitViewColumnWidth(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(_:)) — Sets a fixed, preferred width for the column containing this view.
- [navigationSplitViewColumnWidth(min:ideal:max:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(min:ideal:max:)) — Sets a flexible, preferred width for the column containing this view.
- [NavigationSplitViewVisibility](https://developer.apple.com/documentation/swiftui/navigationsplitviewvisibility) — The visibility of the leading columns in a navigation split view.
- [NavigationLink](https://developer.apple.com/documentation/swiftui/navigationlink) — A view that controls a navigation presentation.
### Stacking views in one column

- [NavigationStack](https://developer.apple.com/documentation/swiftui/navigationstack) — A view that displays a root view and enables you to present additional views over the root view.
- [NavigationPath](https://developer.apple.com/documentation/swiftui/navigationpath) — A type-erased list of data representing the content of a navigation stack.
- [navigationDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(for:destination:)) — Associates a destination view with a presented data type for use within a navigation stack.
- [navigationDestination(isPresented:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(ispresented:destination:)) — Associates a destination view with a binding that can be used to push the view onto a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack).
- [navigationDestination(item:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(item:destination:)) — Associates a destination view with a bound value for use within a navigation stack or navigation split view
### Managing column collapse

- [NavigationSplitViewColumn](https://developer.apple.com/documentation/swiftui/navigationsplitviewcolumn) — A view that represents a column in a navigation split view.
### Setting titles for navigation content

- [navigationTitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)) — Configures the view’s title for purposes of navigation, using a string binding.
- [navigationSubtitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)) — Configures the view’s subtitle for purposes of navigation.
- [navigationDocument(_:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:)) — Configures the view’s document for purposes of navigation.
- [navigationDocument(_:preview:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)) — Configures the view’s document for purposes of navigation.
### Configuring the navigation bar

- [navigationBarBackButtonHidden(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbarbackbuttonhidden(_:)) — Hides the navigation bar back button for the view.
- [navigationBarTitleDisplayMode(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbartitledisplaymode(_:)) — Configures the title display mode for this view.
- [NavigationBarItem](https://developer.apple.com/documentation/swiftui/navigationbaritem) — A configuration for a navigation bar that represents a view at the top of a navigation stack.
### Configuring the sidebar

- [sidebarRowSize](https://developer.apple.com/documentation/swiftui/environmentvalues/sidebarrowsize) — The current size of sidebar rows.
- [SidebarRowSize](https://developer.apple.com/documentation/swiftui/sidebarrowsize) — The standard sizes of sidebar rows.
### Presenting views in tabs

- [Enhancing your app’s content with tab navigation](https://developer.apple.com/documentation/swiftui/enhancing-your-app-content-with-tab-navigation) — Keep your app content front and center while providing quick access to navigation using the tab bar.
- [TabView](https://developer.apple.com/documentation/swiftui/tabview) — A view that switches between multiple child views using interactive user interface elements.
- [Tab](https://developer.apple.com/documentation/swiftui/tab) — The content for a tab and the tab’s associated tab item in a tab view.
- [TabRole](https://developer.apple.com/documentation/swiftui/tabrole) — A value that defines the purpose of the tab.
- [TabSection](https://developer.apple.com/documentation/swiftui/tabsection) — A container that you can use to add hierarchy within a tab view.
- [tabViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewstyle(_:)) — Sets the style for the tab view within the current environment.
### Configuring a tab bar

- [tabViewSidebarHeader(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarheader(content:)) — Adds a custom header to the sidebar of a tab view.
- [tabViewSidebarFooter(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarfooter(content:)) — Adds a custom footer to the sidebar of a tab view.
- [tabViewSidebarBottomBar(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarbottombar(content:)) — Adds a custom bottom bar to the sidebar of a tab view.
- [AdaptableTabBarPlacement](https://developer.apple.com/documentation/swiftui/adaptabletabbarplacement) — A placement for tabs in a tab view using the adaptable sidebar style.
- [tabBarPlacement](https://developer.apple.com/documentation/swiftui/environmentvalues/tabbarplacement) — The current placement of the tab bar.
- [TabBarPlacement](https://developer.apple.com/documentation/swiftui/tabbarplacement) — A placement for tabs in a tab view.
- [isTabBarShowingSections](https://developer.apple.com/documentation/swiftui/environmentvalues/istabbarshowingsections) — A Boolean value that determines whether a tab view shows the expanded contents of a tab section.
- [TabBarMinimizeBehavior](https://developer.apple.com/documentation/swiftui/tabbarminimizebehavior)
- [TabViewBottomAccessoryPlacement](https://developer.apple.com/documentation/swiftui/tabviewbottomaccessoryplacement) — A placement of the bottom accessory in a tab view. You can use this to adjust the content of the accessory view based on the placement.
### Configuring a tab

- [sectionActions(content:)](https://developer.apple.com/documentation/swiftui/view/sectionactions(content:)) — Adds custom actions to a section.
- [TabPlacement](https://developer.apple.com/documentation/swiftui/tabplacement) — A place that a tab can appear.
- [TabContentBuilder](https://developer.apple.com/documentation/swiftui/tabcontentbuilder) — A result builder that constructs tabs for a tab view that supports programmatic selection. This builder requires that all tabs in the tab view have the same selection type.
- [TabContent](https://developer.apple.com/documentation/swiftui/tabcontent) — A type that provides content for programmatically selectable tabs in a tab view.
- [AnyTabContent](https://developer.apple.com/documentation/swiftui/anytabcontent) — Type erased tab content.
### Enabling tab customization

- [tabViewCustomization(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewcustomization(_:)) — Specifies the customizations to apply to the sidebar representation of the tab view.
- [TabViewCustomization](https://developer.apple.com/documentation/swiftui/tabviewcustomization) — The customizations a person makes to an adaptable sidebar tab view.
- [TabCustomizationBehavior](https://developer.apple.com/documentation/swiftui/tabcustomizationbehavior) — The customization behavior of customizable tab view content.
### Displaying views in multiple panes

- [HSplitView](https://developer.apple.com/documentation/swiftui/hsplitview) — A layout container that arranges its children in a horizontal line and allows the user to resize them using dividers placed between them.
- [VSplitView](https://developer.apple.com/documentation/swiftui/vsplitview) — A layout container that arranges its children in a vertical line and allows the user to resize them using dividers placed between them.
### Deprecated Types

- [NavigationView](https://developer.apple.com/documentation/swiftui/navigationview) — A view for presenting a stack of views that represents a visible path in a navigation hierarchy.
- [tabItem(_:)](https://developer.apple.com/documentation/swiftui/view/tabitem(_:)) — Sets the tab bar item associated with this view.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation)*
--- END FILE ---

--- FILE: Swift-Charts-3D-Visualization.md ---
# Using 3D Charts with Swift Charts

## Overview

Swift Charts provides powerful 3D visualization capabilities through the `Chart3D` component, allowing developers to create immersive three-dimensional data visualizations. This guide covers how to create, customize, and interact with 3D charts in SwiftUI applications using the Swift Charts framework.

Key components for 3D charts include:
- `Chart3D`: The main container view for 3D chart content
- `SurfacePlot`: For visualizing 3D surface data
- `Chart3DPose`: For controlling the viewing angle and perspective
- `Chart3DSurfaceStyle`: For styling the appearance of 3D surfaces

## Basic Setup

### Importing Required Frameworks

```swift
import SwiftUI
import Charts
```

### Creating a Simple 3D Chart

The most basic 3D chart can be created using a mathematical function that maps x,y coordinates to z values:

```swift
struct Basic3DChartView: View {
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    // Simple mathematical function: z = sin(x) * cos(y)
                    sin(x) * cos(y)
                }
            )
        }
    }
}
```

### Creating a 3D Chart from Data

You can also create 3D charts from collections of data:

```swift
struct DataPoint3D: Identifiable {
    var x: Double
    var y: Double
    var z: Double
    var id = UUID()
}

struct Data3DChartView: View {
    let dataPoints: [DataPoint3D] = [
        // Your 3D data points
    ]
    
    var body: some View {
        Chart3D(dataPoints) { point in
            // Create appropriate 3D visualization for each point
        }
    }
}
```

## Customizing 3D Charts

### Setting the Chart Pose (Viewing Angle)

Control the viewing angle of your 3D chart using `Chart3DPose`:

```swift
struct CustomPose3DChartView: View {
    // Create a state variable to store the pose
    @State private var chartPose: Chart3DPose = .default
    
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    sin(x) * cos(y)
                }
            )
        }
        // Apply the pose to the chart
        .chart3DPose(chartPose)
    }
}
```

You can use predefined poses:
- `.default`: The default viewing angle
- `.front`: View from the front
- `.back`: View from the back
- `.top`: View from the top
- `.bottom`: View from the bottom
- `.right`: View from the right side
- `.left`: View from the left side

Or create a custom pose with specific azimuth and inclination angles:

```swift
Chart3DPose(azimuth: .degrees(45), inclination: .degrees(30))
```

### Interactive Pose Control

Allow users to interact with the chart by binding the pose to a state variable:

```swift
struct Interactive3DChartView: View {
    @State private var chartPose: Chart3DPose = .default
    
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    sin(x) * cos(y)
                }
            )
        }
        // Bind the pose to enable interactive rotation
        .chart3DPose($chartPose)
    }
}
```

### Setting the Camera Projection

Control the camera projection of the points in a 3D chart using `Chart3DCameraProjection`:

```swift
struct CustomProjection3DChartView: View {
    // Create a state variable to store the pose
    @State private var cameraProjection: Chart3DCameraProjection = .perspective
    
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    sin(x) * cos(y)
                }
            )
        }
        // Apply the camera projection to the chart
        .chart3DCameraProjection(cameraProjection)
    }
}
```

You can use the following camera projection styles:
- `.automatic`: Automatically determines the camera projection
- `.orthographic`: Objects maintain size regardless of depth
- `.perspective`: Objects appear smaller with distance

## Working with Surface Plots

### Basic Surface Plot

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        // Mathematical function defining the surface
        sin(sqrt(x*x + y*y))
    }
)
```

### Styling Surface Plots

Apply different styles to your surface plots:

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(Color.blue)
```

Available surface styles:
- `.heightBased`: Colors the surface based on the height (y-value)
- `.normalBased`: Colors the surface based on the surface normal direction

### Custom Gradient Surface Style

Create a custom gradient for your surface:

```swift
let customGradient = Gradient(colors: [.blue, .purple, .red])

SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(LinearGradient(gradient: customGradient, startPoint: .topLeading, endPoint: .bottomTrailing))
```

### Controlling Surface Roughness

Adjust the roughness of the surface:

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.roughness(0.3) // 0 is smooth, 1 is completely rough
```

## Advanced Techniques

### Combining Multiple Surface Plots

```swift
Chart3D {
    // First surface plot
    SurfacePlot(
        x: "X",
        y: "Y",
        z: "Z",
        function: { x, y in
            sin(x) * cos(y)
        }
    )
    
    // Second surface plot
    SurfacePlot(
        x: "X",
        y: "Y",
        z: "Z",
        function: { x, y in
            cos(x) * sin(y) + 2 // Offset to avoid overlap
        }
    )
}
```

### Specifying Y-Range for Height-Based Styling

Control the color mapping by specifying the y-range:

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(Chart3DSurfaceStyle.heightBased(yRange: -1.0...1.0))
```

### Custom Gradient with Y-Range

```swift
let customGradient = Gradient(colors: [.blue, .green, .yellow, .red])

SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(Chart3DSurfaceStyle.heightBased(customGradient, yRange: -1.0...1.0))
```

## Complete Example: Interactive 3D Visualization

Here's a complete example that demonstrates an interactive 3D chart with customized styling:

```swift
import SwiftUI
import Charts

struct Interactive3DSurfaceView: View {
    // State for interactive rotation
    @State private var chartPose: Chart3DPose = .default
    
    // Custom gradient for surface coloring
    let surfaceGradient = Gradient(colors: [
        .blue,
        .cyan,
        .green,
        .yellow,
        .orange,
        .red
    ])
    
    var body: some View {
        VStack {
            Text("Interactive 3D Surface Visualization")
                .font(.headline)
            
            Chart3D {
                SurfacePlot(
                    x: "X Value",
                    y: "Y Value",
                    z: "Result",
                    function: { x, y in
                        // Interesting mathematical function
                        sin(sqrt(x*x + y*y)) / sqrt(x*x + y*y + 0.1)
                    }
                )
                .roughness(0.2)
            }
            .chart3DPose($chartPose)
            .frame(height: 400)
            
            Text("Drag to rotate the visualization")
                .font(.caption)
                .foregroundColor(.secondary)
            
            HStack {
                Button("Front View") {
                    withAnimation {
                        chartPose = .front
                    }
                }
                
                Button("Top View") {
                    withAnimation {
                        chartPose = .top
                    }
                }
                
                Button("Default View") {
                    withAnimation {
                        chartPose = .default
                    }
                }
            }
            .buttonStyle(.bordered)
        }
        .padding()
    }
}
```

## References

- [Apple Developer Documentation: Chart3D](https://developer.apple.com/documentation/Charts/Chart3D)
- [Apple Developer Documentation: SurfacePlot](https://developer.apple.com/documentation/Charts/SurfacePlot)
- [Apple Developer Documentation: Chart3DPose](https://developer.apple.com/documentation/Charts/Chart3DPose)
- [Apple Developer Documentation: Chart3DSurfaceStyle](https://developer.apple.com/documentation/Charts/Chart3DSurfaceStyle)
- [Apple Developer Documentation: Creating a chart using Swift Charts](https://developer.apple.com/documentation/Charts/Creating-a-chart-using-Swift-Charts)
--- END FILE ---
=== END SWIFT DOCUMENTATION ===
=== END CONTEXT ===

=== BUILD ATTEMPT 1 FAILED ===
The previous implementation failed with the following errors:

codex CLI invocation failed. Please try again.

=== INSTRUCTIONS FOR ATTEMPT 2 ===
1. Analyze what went wrong in the previous approach
2. Try a DIFFERENT approach or fix the specific issues
3. Do NOT repeat the same mistakes
4. If the same approach keeps failing, consider an alternative implementation strategy
5. Write the corrected code directly - do not explain, just implement

Please fix the issues and provide the corrected implementation.