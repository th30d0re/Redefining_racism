OpenAI Codex v0.104.0 (research preview)
--------
workdir: /Users/emmanuel/Documents/Theory/Redefining_racism
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019c870f-819b-7713-bde0-41d9ebcc7495
--------
user
You are a Swift/SwiftUI developer. A previous attempt to complete a task failed.

TESTING & DEBUGGING REFERENCE:
For building, testing, and debugging iOS/macOS apps, reference this workflow guide:
/Users/emmanuel/Dev/Tools/Eocon-Foundation-V1/.Foundation/Docs/swiftDocs/Testing/XCODEBUILD_MCP_WORKFLOW.md

This guide covers:
- XcodeBuild MCP server tools for programmatic Xcode interaction
- Building for simulator, booting simulators, installing/launching apps
- UI automation: screenshots, accessibility hierarchy, tap simulation
- Debugging UI issues (button taps, gestures, navigation)

=== ORIGINAL TASK ===
I have the following verification comments after thorough review and exploration of the codebase. Implement the comments by following the instructions in the comments verbatim.

---
## Comment 1: Tier2/ModelDownloadManager never instantiated or started; Tier2 classification cannot run

In \`decodingOppressionApp\` (or a top-level environment container) create a shared \`ModelDownloadManager\` instance, call \`startDownload()\` based on UI intent, and inject it into a shared \`Tier2Engine\`. Plumb that engine through your pipeline/view-model so clause classification requests use it. Ensure the background URLSession identifier matches the manager‚Äôs \`sessionIdentifier\`.

### Referred Files
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/ContentView.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
---
## Comment 2: Embedding engine is unused and similarity API is missing from Tier2

Add a public async method on \`Tier2Engine\` that calls \`embeddingEngine.loadModel()\` and returns similarity or embeddings as required, and wire that into the pipeline or callers that need taxonomy matching. If not needed, remove the unused \`embeddingEngine\` property to avoid dead code.

### Referred Files
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
---
=== END ORIGINAL TASK ===

=== REFERENCE CONTEXT ===

=== SWIFT DOCUMENTATION ===

--- FILE: generating-content-and-performing-tasks.md ---
# Generating content and performing tasks with Foundation Models

**Enhance the experience in your app by prompting an on-device large language model.**


## Overview

The Foundation Models framework lets you tap into the on-device large models at the core of Apple Intelligence. You can enhance your app by using generative models to create content or perform tasks. The framework supports language understanding and generation based on model capabilities.

For design guidance, see Human Interface Guidelines > Technologies > [https://developer.apple.com/design/human-interface-guidelines/generative-ai](https://developer.apple.com/design/human-interface-guidelines/generative-ai).


## Understand model capabilities

When considering features for your app, it helps to know what the on-device language model can do. The on-device model supports text generation and understanding that you can use to:

The on-device language model may not be suitable for handling all requests, like:

The model can complete complex generative tasks when you use guided generation or tool calling. For more on handling complex tasks, or tasks that require extensive world-knowledge, see [doc://com.apple.foundationmodels/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation](https://developer.apple.com/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation) and [doc://com.apple.foundationmodels/documentation/FoundationModels/expanding-generation-with-tool-calling](https://developer.apple.com/documentation/FoundationModels/expanding-generation-with-tool-calling).


## Check for availability

Before you use the on-device model in your app, check that the model is available by creating an instance of [doc://com.apple.foundationmodels/documentation/FoundationModels/SystemLanguageModel](https://developer.apple.com/documentation/FoundationModels/SystemLanguageModel) with the [doc://com.apple.foundationmodels/documentation/FoundationModels/SystemLanguageModel/default](https://developer.apple.com/documentation/FoundationModels/SystemLanguageModel/default) property.

Model availability depends on device factors like:

- The device must support Apple Intelligence.

- The device must have Apple Intelligence turned on in Settings.


> **NOTE**: It can take some time for the model to download and become available when a person turns on Apple Intelligence.


Always verify model availability first, and plan for a fallback experience in case the model is unavailable.

```swift
struct GenerativeView: View {
    // Create a reference to the system language model.
    private var model = SystemLanguageModel.default

    var body: some View {
        switch model.availability {
        case .available:
            // Show your intelligence UI.
        case .unavailable(.deviceNotEligible):
            // Show an alternative UI.
        case .unavailable(.appleIntelligenceNotEnabled):
            // Ask the person to turn on Apple Intelligence.
        case .unavailable(.modelNotReady):
            // The model isn't ready because it's downloading or because of other system reasons.
        case .unavailable(let other):
            // The model is unavailable for an unknown reason.
        }
    }
}
```


## Create a session

After confirming that the model is available, create a [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession) object to call the model. For a single-turn interaction, create a new session each time you call the model:

```swift
// Create a session with the system model.
let session = LanguageModelSession()
```

For a multiturn interaction ‚Äî where the model retains some knowledge of what it produced ‚Äî reuse the same session each time you call the model.


## Provide a prompt to the model

A [doc://com.apple.foundationmodels/documentation/FoundationModels/Prompt](https://developer.apple.com/documentation/FoundationModels/Prompt) is an input that the model responds to. Prompt engineering is the art of designing high-quality prompts so that the model generates a best possible response for the request you make. A prompt can be as short as ‚Äúhello‚Äù, or as long as multiple paragraphs. The process of designing a prompt involves a lot of exploration to discover the best prompt, and involves optimizing prompt length and writing style.

When thinking about the prompt you want to use in your app, consider using conversational language in the form of a question or command. For example, ‚ÄúWhat‚Äôs a good month to visit Paris?‚Äù or ‚ÄúGenerate a food truck menu.‚Äù

Write prompts that focus on a single and specific task, like ‚ÄúWrite a profile for the dog breed Siberian Husky‚Äù. When a prompt is long and complicated, the model takes longer to respond, and may respond in unpredictable ways. If you have a complex generation task in mind, break the task down into a series of specific prompts.

You can refine your prompt by telling the model exactly how much content it should generate. A prompt like, ‚ÄúWrite a profile for the dog breed Siberian Husky‚Äù often takes a long time to process as the model generates a full multi-paragraph essay. If you specify ‚Äúusing three sentences‚Äù, it speeds up processing and generates a concise summary. Use phrases like ‚Äúin a single sentence‚Äù or ‚Äúin a few words‚Äù to shorten the generation time and produce shorter text.

```swift
// Generate a longer response for a specific command.
let simple = "Write me a story about pears."

// Quickly generate a concise response.
let quick = "Write the profile for the dog breed Siberian Husky using three sentences."
```


## Provide instructions to the model

[doc://com.apple.foundationmodels/documentation/FoundationModels/Instructions](https://developer.apple.com/documentation/FoundationModels/Instructions) help steer the model in a way that fits the use case of your app. The model obeys prompts at a lower priority than the instructions you provide. When you provide instructions to the model, consider specifying details like:

- What the model‚Äôs role is; for example, ‚ÄúYou are a mentor,‚Äù or ‚ÄúYou are a movie critic‚Äù.

- What the model should do, like ‚ÄúHelp the person extract calendar events,‚Äù or ‚ÄúHelp the person by recommending search suggestions‚Äù.

- What the style preferences are, like ‚ÄúRespond as briefly as possible‚Äù.

- What the possible safety measures are, like ‚ÄúRespond with ‚ÄòI can‚Äôt help with that‚Äô if you‚Äôre asked to do something dangerous‚Äù.

Use content you trust in instructions because the model follows them more closely than the prompt itself. When you initialize a session with instructions, it affects all prompts the model responds to in that session. Instructions can also include example responses to help steer the model. When you add examples to your prompt, you provide the model with a template that shows the model what a good response looks like.


## Generate a response

To call the model with a prompt, call [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession/respond(to:options:)-b2re](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession/respond(to:options:)-b2re) on your session. The response call is asynchronous because it may take a few seconds for the on-device foundation model to generate the response.

```swift
let instructions = """
    Suggest five related topics. Keep them concise (three to seven words) and make sure they \
    build naturally from the person's topic.
    """

let session = LanguageModelSession(instructions: instructions)

let prompt = "Making homemade bread"
let response = try await session.respond(to: prompt)
```


> **NOTE**: A session can only handle a single request at a time, and causes a runtime error if you call it again before the previous request finishes. Check [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession/isResponding](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession/isResponding) to verify the session is done processing the previous request before sending a new one.


Instead of working with raw string output from the model, the framework offers guided generation to generate a custom Swift data structure you define. For more information about guided generation, see [doc://com.apple.foundationmodels/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation](https://developer.apple.com/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation).

When you make a request to the model, you can provide custom tools to help the model complete the request. If the model determines that a [doc://com.apple.foundationmodels/documentation/FoundationModels/Tool](https://developer.apple.com/documentation/FoundationModels/Tool) can assist with the request, the framework calls your [doc://com.apple.foundationmodels/documentation/FoundationModels/Tool](https://developer.apple.com/documentation/FoundationModels/Tool) to perform additional actions like retrieving content from your local database. For more information about tool calling, see [doc://com.apple.foundationmodels/documentation/FoundationModels/expanding-generation-with-tool-calling](https://developer.apple.com/documentation/FoundationModels/expanding-generation-with-tool-calling)


## Consider context size limits per session

The *context window size* is a limit on how much data the model can process for a session instance. A token is a chunk of text the model processes, and the system model supports up to 4,096 tokens. A single token corresponds to three or four characters in languages like English, Spanish, or German, and one token per character in languages like Japanese, Chinese, or Korean. In a single session, the sum of all tokens in the instructions, all prompts, and all outputs count toward the context window size.

If your session processes a large amount of tokens that exceed the context window, the framework throws the error [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession/GenerationError/exceededContextWindowSize(_:)](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession/GenerationError/exceededContextWindowSize(_:)). When you encounter the error, start a new session and try shortening your prompts. If you need to process a large amount of data that won‚Äôt fit in a single context window limit, break your data into smaller chunks, process each chunk in a separate session, and then combine the results.


## Tune generation options and optimize performance

To get the best results for your prompt, experiment with different generation options. [doc://com.apple.foundationmodels/documentation/FoundationModels/GenerationOptions](https://developer.apple.com/documentation/FoundationModels/GenerationOptions) affects the runtime parameters of the model, and you can customize them for every request you make.

```swift
// Customize the temperature to increase creativity.
let options = GenerationOptions(temperature: 2.0)

let session = LanguageModelSession()

let prompt = "Write me a story about coffee."
let response = try await session.respond(
    to: prompt,
    options: options
)
```

When you test apps that use the framework, use Xcode Instruments to understand more about the requests you make, like the time it takes to perform a request. When you make a request, you can access the [doc://com.apple.foundationmodels/documentation/FoundationModels/Transcript](https://developer.apple.com/documentation/FoundationModels/Transcript) entries that describe the actions the model takes during your [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession).

---

*Source: [https://developer.apple.com/documentation/com.apple.foundationmodels/documentation/FoundationModels/generating-content-and-performing-tasks-with-foundation-models](https://developer.apple.com/documentation/com.apple.foundationmodels/documentation/FoundationModels/generating-content-and-performing-tasks-with-foundation-models)*
--- END FILE ---

--- FILE: FINAL-COLLECTION-SUMMARY.md ---
# üéâ Complete Apple Documentation Collection - Final Summary

**Date**: October 8, 2025  
**Status**: ‚úÖ **100% SUCCESS - ALL FRAMEWORKS SCRAPED!**

---

## üèÜ Mission Accomplished!

Successfully scraped **ALL 32 FRAMEWORKS** including the two that initially failed!

### üìä Final Statistics

- **Total Frameworks**: 32 (100% success!)
- **Total Documentation Files**: 848 Markdown files
- **Success Rate**: 100% üéâ
- **Collection Location**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/`
- **Total Content Size**: ~5.2 MB

---

## ‚úÖ All 32 Frameworks Successfully Scraped

### AI & Machine Learning (6 frameworks) ‚úÖ
1. ‚úÖ **Foundation Models** (21 files) - Apple's AI foundation models
2. ‚úÖ **Core ML** (42 files) - On-device machine learning
3. ‚úÖ **Vision** (38 files) - Computer vision & image analysis
4. ‚úÖ **Create ML** (30 files) - ML model training
5. ‚úÖ **Speech** (25 files) - Speech recognition & synthesis
6. ‚úÖ **Natural Language** (31 files) - NLP & text analysis ‚≠ê **FIXED!**

### Swift & SwiftUI (2 frameworks) ‚úÖ
7. ‚úÖ **Swift** (27 files) - Swift language documentation
8. ‚úÖ **SwiftUI** (57 files) - Modern declarative UI

### Core Apple Frameworks (3 frameworks) ‚úÖ
9. ‚úÖ **Foundation** (60 files) - Essential data types
10. ‚úÖ **UIKit** (46 files) - iOS UI framework
11. ‚úÖ **AppKit** (60 files) - macOS UI framework

### Graphics & Media (6 frameworks) ‚úÖ
12. ‚úÖ **Metal** (42 files) - Low-level graphics API
13. ‚úÖ **AVFoundation** (50 files) - Audio/video processing
14. ‚úÖ **Core Graphics** (40 files) - 2D graphics
15. ‚úÖ **Core Animation** (41 files) - Animation framework ‚≠ê **FIXED!**
16. ‚úÖ **ARKit** (15 files) - Augmented reality
17. ‚úÖ **RealityKit** (30 files) - 3D rendering for AR

### System & Security (2 frameworks) ‚úÖ
18. ‚úÖ **Security** (30 files) - Cryptography & secure storage
19. ‚úÖ **Network** (30 files) - Modern networking

### App Services (5 frameworks) ‚úÖ
20. ‚úÖ **CloudKit** (30 files) - Cloud data storage
21. ‚úÖ **HealthKit** (25 files) - Health & fitness data
22. ‚úÖ **StoreKit** (25 files) - In-app purchases
23. ‚úÖ **WatchKit** (30 files) - Apple Watch apps
24. ‚úÖ **WidgetKit** (20 files) - Home screen widgets

### Data & Storage (1 framework) ‚úÖ
25. ‚úÖ **Core Data** (40 files) - Object persistence

### System Integration (1 framework) ‚úÖ
26. ‚úÖ **Intents** (25 files) - Siri integration

### Game Development (2 frameworks) ‚úÖ
27. ‚úÖ **SpriteKit** (30 files) - 2D game engine
28. ‚úÖ **SceneKit** (30 files) - 3D game engine

### Development Tools (1 framework) ‚úÖ
29. ‚úÖ **XCTest** (30 files) - Unit testing

### Hardware & Sensors (3 frameworks) ‚úÖ
30. ‚úÖ **Core Motion** (25 files) - Motion & sensor data
31. ‚úÖ **Core Bluetooth** (25 files) - Bluetooth LE
32. ‚úÖ **Core Location** (25 files) - Location services

---

## üîß How We Fixed the Failed Frameworks

### Problem 1: Natural Language (Failed as "natural")
**Solution**: Used the full framework name `naturallanguage` instead of `natural`
```bash
python3 apple_doc_crawler.py "naturallanguage" -m 30 -d 0.5
```
**Result**: ‚úÖ 31 files successfully scraped!

### Problem 2: Core Animation (Failed as "coreanimation")
**Solution**: Used the original framework name `quartzcore` instead of `coreanimation`
```bash
python3 apple_doc_crawler.py "quartzcore" -m 40 -d 0.5
```
**Result**: ‚úÖ 41 files successfully scraped!

---

## üìà Collection Growth

| Metric | Before Retry | After Retry | Improvement |
|--------|-------------|-------------|-------------|
| Frameworks | 30/32 | 32/32 | +2 frameworks |
| Success Rate | 93.8% | 100% | +6.2% |
| Total Files | 802 | 848 | +46 files |
| Content Size | ~4.6 MB | ~5.2 MB | +0.6 MB |

---

## üéØ Verified Documentation

### Speech Framework ‚úÖ
- **Files**: 19 documentation files
- **URL**: https://developer.apple.com/documentation/speech
- **Content**: Speech recognition, synthesis, analysis
- **Location**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/`

### Vision Framework ‚úÖ
- **Files**: 38 documentation files
- **URL**: https://developer.apple.com/documentation/vision
- **Content**: Computer vision, image analysis, object detection
- **Location**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/`

---

## üìÅ Complete Collection Structure

```
/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/
‚îú‚îÄ‚îÄ README.md                                  # Main index
‚îú‚îÄ‚îÄ 848 Framework Documentation Files          # All scraped content
‚îÇ
‚îú‚îÄ‚îÄ AI & Machine Learning (6 frameworks, 187 files)
‚îÇ   ‚îú‚îÄ‚îÄ Foundation Models (21 files)
‚îÇ   ‚îú‚îÄ‚îÄ Core ML (42 files)
‚îÇ   ‚îú‚îÄ‚îÄ Vision (38 files)
‚îÇ   ‚îú‚îÄ‚îÄ Create ML (30 files)
‚îÇ   ‚îú‚îÄ‚îÄ Speech (25 files)
‚îÇ   ‚îî‚îÄ‚îÄ Natural Language (31 files) ‚≠ê NEW
‚îÇ
‚îú‚îÄ‚îÄ Swift & SwiftUI (2 frameworks, 84 files)
‚îÇ   ‚îú‚îÄ‚îÄ Swift (27 files)
‚îÇ   ‚îî‚îÄ‚îÄ SwiftUI (57 files)
‚îÇ
‚îú‚îÄ‚îÄ Core Frameworks (3 frameworks, 166 files)
‚îÇ   ‚îú‚îÄ‚îÄ Foundation (60 files)
‚îÇ   ‚îú‚îÄ‚îÄ UIKit (46 files)
‚îÇ   ‚îî‚îÄ‚îÄ AppKit (60 files)
‚îÇ
‚îú‚îÄ‚îÄ Graphics & Media (6 frameworks, 226 files)
‚îÇ   ‚îú‚îÄ‚îÄ Metal (42 files)
‚îÇ   ‚îú‚îÄ‚îÄ AVFoundation (50 files)
‚îÇ   ‚îú‚îÄ‚îÄ Core Graphics (40 files)
‚îÇ   ‚îú‚îÄ‚îÄ Core Animation (41 files) ‚≠ê NEW
‚îÇ   ‚îú‚îÄ‚îÄ ARKit (15 files)
‚îÇ   ‚îî‚îÄ‚îÄ RealityKit (30 files)
‚îÇ
‚îî‚îÄ‚îÄ ... (15 more frameworks, 185 files)
```

---

## üöÄ Quick Start Commands

### Navigate to Collection
```bash
cd /Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection
```

### Search for AI/ML Content
```bash
# Core ML
grep -r "MLModel" . --include="*.md" | head -20

# Vision
grep -r "VNImageRequest" . --include="*.md" | head -20

# Natural Language (NEW!)
grep -r "NLTagger\|Natural Language" . --include="*.md" | head -20

# Speech
grep -r "SFSpeechRecognizer\|Speech" . --include="*.md" | head -20
```

### Search for Graphics & Animation
```bash
# Core Animation (NEW!)
grep -r "CALayer\|CAAnimation" . --include="*.md" | head -20

# Metal
grep -r "MTL\|Metal" . --include="*.md" | head -20

# ARKit
grep -r "ARKit\|ARSession" . --include="*.md" | head -20
```

### Search for Swift/SwiftUI
```bash
# SwiftUI
grep -r "@State\|@Binding" . --include="*.md" | head -20

# Swift language features
grep -r "async\|await" . --include="*.md" | head -20
```

---

## üìä Coverage by Category

| Category | Frameworks | Files | Percentage |
|----------|-----------|-------|-----------|
| AI & Machine Learning | 6 | 187 | 22% |
| Swift & SwiftUI | 2 | 84 | 10% |
| Core Frameworks | 3 | 166 | 20% |
| Graphics & Media | 6 | 226 | 27% |
| System & Security | 2 | 60 | 7% |
| App Services | 5 | 130 | 15% |
| Other | 8 | 95 | 11% |
| **Total** | **32** | **848** | **100%** |

---

## üéì What You Can Do Now

### 1. AI/ML Development
- **Foundation Models**: Build AI-powered apps with Apple's LLMs
- **Core ML**: Integrate machine learning models
- **Vision**: Add computer vision capabilities
- **Natural Language**: Process and analyze text
- **Speech**: Add voice recognition and synthesis

### 2. UI Development
- **SwiftUI**: Build modern, declarative interfaces
- **UIKit**: iOS app development
- **AppKit**: macOS app development
- **Core Animation**: Create smooth animations

### 3. Graphics & Gaming
- **Metal**: GPU programming and compute
- **ARKit/RealityKit**: Augmented reality experiences
- **SpriteKit/SceneKit**: 2D/3D game development

### 4. System Integration
- **CloudKit**: Sync data across devices
- **HealthKit**: Health and fitness apps
- **Intents/Siri**: Voice integration
- **Core Location**: Location-based features

---

## üîÑ Keep Your Documentation Updated

To get the latest documentation in the future:

```bash
# Navigate to tools directory
cd /Users/emmanuel/Dev/Tools/getMDfromURL

# Re-run the essentials scraper
python3 scrape_essentials.py

# Add the newly fixed frameworks
python3 apple_doc_crawler.py "naturallanguage" -m 30
python3 apple_doc_crawler.py "quartzcore" -m 40

# Copy to research directory
rsync -av output/apple-docs-*/ /Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/
```

---

## üìö Additional Resources

- **Quick Start Guide**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/QUICK-START.md`
- **Scraping Summary**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/SCRAPING-SUMMARY.md`
- **Collection README**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/README.md`
- **Tools Location**: `/Users/emmanuel/Dev/Tools/getMDfromURL`

---

## üéâ Summary

**You now have the most comprehensive Apple documentation collection possible!**

- ‚úÖ All 32 essential frameworks
- ‚úÖ 848 documentation files
- ‚úÖ 100% success rate
- ‚úÖ Fully searchable and offline
- ‚úÖ Perfect for AI/ML, Swift, SwiftUI, and all Apple development

**Ready for any Apple development project! üöÄ**

---

**Generated**: October 8, 2025  
**Status**: ‚úÖ COMPLETE COLLECTION - 100% SUCCESS!  
**Total**: 32 frameworks, 848 files, ~5.2 MB
--- END FILE ---

--- FILE: NLEmbedding.md ---
# NLEmbedding

**A map of strings to vectors, which locates neighboring, similar strings.**

## Availability

- **iOS** 13.0+
- **iPadOS** 13.0+
- **Mac Catalyst** 13.1+
- **macOS** 10.15+
- **tvOS** 13.0+
- **visionOS** 1.0+
- **watchOS** 6.0+


## Overview

Use an [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) to find similar strings based on the proximity of their vectors. The *vocabulary* is the entire set of strings in an embedding. Each string in the vocabulary has a vector, which is an array of doubles, and each double corresponds to a dimension in the embedding. An [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) uses these vectors to determine the distance between two strings, or to find the nearest neighbors of a string in the vocabulary. The higher the similarity of any two strings, the smaller the distance is between them.

[doc://com.apple.naturallanguage/documentation/NaturalLanguage](https://developer.apple.com/documentation/NaturalLanguage) provides built-in word embeddings that you can retrieve by using the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)) method. You can also compile your own custom embedding into an efficient, searchable, on-disk representation. Typically, you compile an embedding by using Create ML‚Äôs [doc://com.apple.documentation/documentation/CreateML/MLWordEmbedding](https://developer.apple.com/documentation/CreateML/MLWordEmbedding) and save it as a file for your Xcode project at development time. Alternatively, you can compile an embedding at runtime by using Natural Language‚Äôs [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/writeEmbeddingForDictionary:language:revision:toURL:error:](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/writeEmbeddingForDictionary:language:revision:toURL:error:) method.

Your custom embedding can use any kind of string that‚Äôs useful to your app, such as phrases, brand names, serial numbers, and so on. For example, you could make an embedding of movie titles. Each movie title could have a vector that places similar movies close together in the embedding.

## Topics

### Creating a word embedding

- [wordEmbedding(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/wordembedding(for:)) ‚Äî Retrieves a word embedding for a given language.
- [wordEmbedding(for:revision:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/wordembedding(for:revision:)) ‚Äî Retrieves a word embedding for a given language and revision.
- [init(contentsOf:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/init(contentsof:)) ‚Äî Creates a word embedding from a model file.
### Creating a sentence embedding

- [sentenceEmbedding(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/sentenceembedding(for:)) ‚Äî Retrieves a sentence embedding for a given language.
- [sentenceEmbedding(for:revision:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/sentenceembedding(for:revision:)) ‚Äî Retrieves a sentence embedding for a given language and revision.
### Finding strings and their distances in an embedding

- [neighbors(for:maximumCount:distanceType:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/neighbors(for:maximumcount:distancetype:)-8f1jc) ‚Äî Retrieves a limited number of strings near a string in the vocabulary.
- [neighbors(for:maximumCount:distanceType:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/neighbors(for:maximumcount:distancetype:)-8lp4z) ‚Äî Retrieves a limited number of strings near a location in the vocabulary space.
- [enumerateNeighbors(for:maximumCount:distanceType:using:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/enumerateneighbors(for:maximumcount:distancetype:using:)-72jda) ‚Äî Passes the nearest strings of a string in the vocabulary to a closure.
- [enumerateNeighbors(for:maximumCount:distanceType:using:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/enumerateneighbors(for:maximumcount:distancetype:using:)-6dy4x) ‚Äî Passes the nearest strings of a location in the vocabulary space to a closure.
- [distance(between:and:distanceType:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/distance(between:and:distancetype:)) ‚Äî Calculates the distance between two strings in the vocabulary space.
- [NLDistance](https://developer.apple.com/documentation/naturallanguage/nldistance) ‚Äî The distance between two strings in a text embedding.
### Inspecting the vocabulary of an embedding

- [dimension](https://developer.apple.com/documentation/naturallanguage/nlembedding/dimension) ‚Äî The number of dimensions in the vocabulary‚Äôs vector space.
- [vocabularySize](https://developer.apple.com/documentation/naturallanguage/nlembedding/vocabularysize) ‚Äî The number of words in the vocabulary.
- [language](https://developer.apple.com/documentation/naturallanguage/nlembedding/language) ‚Äî The language of the text in the word embedding.
- [contains(_:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/contains(_:)) ‚Äî Requests a Boolean value that indicates whether the term is in the vocabulary.
- [vector(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/vector(for:)) ‚Äî Requests the vector for the given term.
- [revision](https://developer.apple.com/documentation/naturallanguage/nlembedding/revision) ‚Äî The revision of the word embedding.
### Saving an embedding

- [write(_:language:revision:to:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/write(_:language:revision:to:)) ‚Äî Exports the word embedding contained within a Core ML model file at the given URL.
### Checking for Natural Language support

- [currentRevision(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/currentrevision(for:)) ‚Äî Retrieves the current version of a word embedding for the given language.
- [supportedRevisions(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/supportedrevisions(for:)) ‚Äî Retrieves all version numbers of a word embedding for the given language.
- [currentSentenceEmbeddingRevision(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/currentsentenceembeddingrevision(for:)) ‚Äî Retrieves the current version of a sentence embedding for the given language.
- [supportedSentenceEmbeddingRevisions(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/supportedsentenceembeddingrevisions(for:)) ‚Äî Retrieves all version numbers of a sentence embedding for the given language.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding)*
--- END FILE ---

--- FILE: Finding-similarities-between-pieces-of-text.md ---
# Finding similarities between pieces of text

**Calculate the semantic distance between words or sentences.**


## Overview

Finding semantic similarities between words or sentences can help you create a better user experience for your app. For example, you might enhance the experience of searching for specific photos by knowing that the search term ‚Äúcloud‚Äù is related to the word ‚Äúsky,‚Äù and expanding the search query to return more relevant results.

To find similarities between pieces of natural language text, you use text embeddings. An *embedding* is a map from strings‚Äîwords or sentences‚Äîinto a vector space. Strings that are semantically similar have similar vectors, which means they‚Äôre closer together in vector space.

![Image](media-3687947)

You use embeddings for tasks like:

- Searching for the nearest neighbors to a given term‚Äîfor example, to expand a search query.

- Calculating the distance between terms, as a measure of semantic similarity.

- Using the vectors as an input layer for a model.

In Natural Language, [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) represents an embedding, stored in a space- and time-efficient format. [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) provides pretrained word embeddings for a number of languages, trained on large bodies of general text.


### Find similar words

To calculate the distance between individual words, use a word embedding.

1. Create an instance of [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) with [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)), specifying the language for which to generate a word embedding.

2. Call the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/vector(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/vector(for:)) method of the embedding with a specific input word to see the vector generated for that word.

3. To find the distance between your input word and another word, use `distance(between:and:distanceType:)`.

4. To find the nearest neighbors to your input word, enumerate over the word‚Äôs neighbors by calling the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/enumerateNeighborsForString:maximumCount:distanceType:usingBlock:](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/enumerateNeighborsForString:maximumCount:distanceType:usingBlock:) method, specifying the maximum number of nearest neighbors to look at.

```swift
if let embedding = NLEmbedding.wordEmbedding(for: .english) {
    let word = "bicycle"
    
    if let vector = embedding.vector(for: word) {
        print(vector)
    }
    
    let specificDistance = embedding.distance(between: word, and: "motorcycle")
    print(specificDistance.description)
    
    embedding.enumerateNeighbors(for: word, maximumCount: 5) { neighbor, distance in
        print("\(neighbor): \(distance.description)")
        return true
    }
}
```


### Find similar sentences

To calculate the distance between phrases, use a sentence embedding. You might use it to measure similarity between sentences for tasks like text retrieval, or for detecting paraphrases. For example, if a user searches a food-delivery app using the text, ‚ÄúWhere is my order?‚Äù you could use a sentence embedding to suggest a result from the FAQ with the similar title, ‚ÄúHow do I check the status of my order?‚Äù

1. Create an instance of [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) with [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/sentenceEmbedding(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/sentenceEmbedding(for:)), specifying the language for which to generate a sentence embedding.

2. Call the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/vector(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/vector(for:)) method of the embedding with a specific input sentence to see the vector generated for that sentence.

3. To find the distance between your input sentence and another sentence, use [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/distanceBetweenString:andString:distanceType:](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/distanceBetweenString:andString:distanceType:).

```swift
if let sentenceEmbedding = NLEmbedding.sentenceEmbedding(for: .english) {
    let sentence = "This is a sentence."

    if let vector = sentenceEmbedding.vector(for: sentence) {
        print(vector)
    }
    
    let distance = sentenceEmbedding.distance(between: sentence, and: "That is a sentence.")
    print(distance.description)
}
```

Sentence embeddings are dynamic. They don‚Äôt have a fixed vocabulary, and they can return results for arbitrary sentences. Nearest-neighbor search therefore doesn‚Äôt apply to sentence embeddings.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/finding-similarities-between-pieces-of-text](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/finding-similarities-between-pieces-of-text)*
--- END FILE ---

--- FILE: NLContextualEmbedding.md ---
# NLContextualEmbedding

**A model that computes sequences of embedding vectors for natural language utterances.**

## Availability

- **iOS** 17.0+
- **iPadOS** 17.0+
- **Mac Catalyst** 17.0+
- **macOS** 14.0+
- **tvOS** 17.0+
- **visionOS** 1.0+
- **watchOS** 10.0+


## Overview

Starting in iOS 17 and macOS 14, the framework supports 27 languages across three models:

- Latin ‚Äî including Croatian, Czech, Danish, Dutch, English, Finnish, French, German, Hungarian, Indonesian, Italian, Norwegian, Polish, Portuguese, Romanian, Slovak, Swedish, Spanish, Turkish, and Vietnamese

- Cyrillic ‚Äî including Bulgarian, Kazakh, Russian, and Ukrainian

- Chinese, Japanese, and Korean

In iOS 18 and macOS 15, the framework expands language support to include three additional models:

- Arabic

- Thai

- Indic ‚Äî including Hindi, Marathi, Bangla, Urdu, Punjabi, Gujarati, Tamil, Telugu, Kannada, and Malayalam

## Topics

### Creating a contextual embedding

- [init(modelIdentifier:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/init(modelidentifier:)) ‚Äî Creates a contextual embedding from a model identifier.
- [init(language:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/init(language:)) ‚Äî Creates a contextual embedding from a language.
- [init(script:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/init(script:)) ‚Äî Creates a contextual embedding from a script.
### Inspecting the contextual embedding

- [dimension](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/dimension) ‚Äî The number of dimensions in the script‚Äôs vector space.
- [hasAvailableAssets](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/hasavailableassets) ‚Äî A Boolean value that indicates whether assets are available to load.
- [languages](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/languages) ‚Äî The languages of the text in the contextual embedding.
- [maximumSequenceLength](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/maximumsequencelength) ‚Äî The maximum number of embedding vectors the model generates, in sequence.
- [modelIdentifier](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/modelidentifier) ‚Äî The model identifier.
- [revision](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/revision) ‚Äî The revision of the contextual embedding.
- [scripts](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/scripts) ‚Äî The scripts of the text in the contextual embedding.
### Requesting assets

- [requestAssets(completionHandler:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/requestassets(completionhandler:)) ‚Äî Requests assets for an embedding, if available.
- [NLContextualEmbedding.AssetsResult](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/assetsresult) ‚Äî The status of an asset request.
### Loading and unloading assets

- [load()](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/load()) ‚Äî Loads the embedding model.
- [unload()](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/unload()) ‚Äî Unloads the embedding model.
### Applying an embedding

- [embeddingResult(for:language:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/embeddingresult(for:language:)) ‚Äî Applies an embedding to a string and obtains the resulting embedding vectors.
- [NLContextualEmbeddingResult](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingresult) ‚Äî An object that represents the embedding vector result from applying a contextual embedding to a string.
### Type Methods

- [contextualEmbeddings(forValues:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/contextualembeddings(forvalues:))

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbedding](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbedding)*
--- END FILE ---

--- FILE: NLContextualEmbeddingKey.md ---
# NLContextualEmbeddingKey

**Contextual embedding keys.**

## Availability

- **iOS** 12.0+
- **iPadOS** 12.0+
- **Mac Catalyst** 13.0+
- **macOS** 10.14+
- **tvOS** 12.0+
- **visionOS** 1.0+
- **watchOS** 5.0+


## Topics

### Getting embedding keys

- [languages](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/languages) ‚Äî A key that identifies the languages in a contextual embedding.
- [revision](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/revision) ‚Äî A key that identifies the revision for a contextual embedding.
- [scripts](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/scripts) ‚Äî A key that identifies the scripts in a contextual embedding.
### Creating embedding keys

- [init(_:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/init(_:)) ‚Äî Creates an embedding key with the given string.
- [init(rawValue:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/init(rawvalue:)) ‚Äî Creates an embedding key with the given string as its raw value.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbeddingKey](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbeddingKey)*
--- END FILE ---

--- FILE: Natural-Language.md ---
# Natural Language

**Analyze natural language text and deduce its language-specific metadata.**

## Availability

- **iOS** 12.0+
- **iPadOS** 12.0+
- **Mac Catalyst** 13.0+
- **macOS** 10.14+
- **tvOS** 12.0+
- **visionOS** 1.0+
- **watchOS** 5.0+


## Overview

The Natural Language framework provides a variety of natural language processing (NLP) functionality with support for many different languages and scripts. Use this framework to segment natural language text into paragraphs, sentences, or words, and tag information about those segments, such as part of speech, lexical class, lemma, script, and language.

![Image](media-3597579)

Use this framework to perform tasks like:

- *Language identification*, automatically detecting the language of a piece of text.

- *Tokenization*, breaking up a piece of text into linguistic units or tokens.

- *Parts-of-speech tagging*, marking up individual words with their part of speech.

- *Lemmatization*, deducing a word‚Äôs stem based on its morphological analysis.

- *Named entity recognition*, identifying tokens as names of people, places, or organizations.

You can also use this framework with Create ML to train and deploy custom natural language models. For more information, see [doc://com.apple.documentation/documentation/CreateML/creating-a-text-classifier-model](https://developer.apple.com/documentation/CreateML/creating-a-text-classifier-model) and [doc://com.apple.naturallanguage/documentation/NaturalLanguage/creating-a-word-tagger-model](https://developer.apple.com/documentation/NaturalLanguage/creating-a-word-tagger-model).

## Topics

### Tokenization

- [Tokenizing natural language text](https://developer.apple.com/documentation/naturallanguage/tokenizing-natural-language-text) ‚Äî Enumerate the words in a string.
- [NLTokenizer](https://developer.apple.com/documentation/naturallanguage/nltokenizer) ‚Äî A tokenizer that segments natural language text into semantic units.
### Language identification

- [Identifying the language in text](https://developer.apple.com/documentation/naturallanguage/identifying-the-language-in-text) ‚Äî Detect the language in a piece of text by using a language recognizer.
- [NLLanguageRecognizer](https://developer.apple.com/documentation/naturallanguage/nllanguagerecognizer) ‚Äî The language of a body of text.
- [NLLanguage](https://developer.apple.com/documentation/naturallanguage/nllanguage) ‚Äî The languages that the Natural Language framework supports.
### Linguistic tags

- [Identifying parts of speech](https://developer.apple.com/documentation/naturallanguage/identifying-parts-of-speech) ‚Äî Classify nouns, verbs, adjectives, and other parts of speech in a string.
- [Identifying people, places, and organizations](https://developer.apple.com/documentation/naturallanguage/identifying-people-places-and-organizations) ‚Äî Use a linguistic tagger to perform named entity recognition on a string.
- [NLTagger](https://developer.apple.com/documentation/naturallanguage/nltagger) ‚Äî A tagger that analyzes natural language text.
### Text embedding

- [Finding similarities between pieces of text](https://developer.apple.com/documentation/naturallanguage/finding-similarities-between-pieces-of-text) ‚Äî Calculate the semantic distance between words or sentences.
- [NLEmbedding](https://developer.apple.com/documentation/naturallanguage/nlembedding) ‚Äî A map of strings to vectors, which locates neighboring, similar strings.
### Contextual embedding

- [NLContextualEmbedding](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding) ‚Äî A model that computes sequences of embedding vectors for natural language utterances.
- [NLContextualEmbeddingKey](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey) ‚Äî Contextual embedding keys.
- [NLScript](https://developer.apple.com/documentation/naturallanguage/nlscript) ‚Äî The writing scripts that the Natural Language framework supports.
### Natural language models

- [Creating a text classifier model](https://developer.apple.com/documentation/CreateML/creating-a-text-classifier-model) ‚Äî Train a machine learning model to classify natural language text.
- [Creating a word tagger model](https://developer.apple.com/documentation/naturallanguage/creating-a-word-tagger-model) ‚Äî Train a machine learning model to tag individual words in natural language text.
- [NLModel](https://developer.apple.com/documentation/naturallanguage/nlmodel) ‚Äî A custom model trained to classify or tag natural language text.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage)*
--- END FILE ---

--- FILE: NLModel.md ---
# NLModel

**A custom model trained to classify or tag natural language text.**

## Availability

- **iOS** 12.0+
- **iPadOS** 12.0+
- **Mac Catalyst** 13.1+
- **macOS** 10.14+
- **tvOS** 12.0+
- **visionOS** 1.0+
- **watchOS** 5.0+


## Overview

With [doc://com.apple.naturallanguage/documentation/NaturalLanguage](https://developer.apple.com/documentation/NaturalLanguage), you can create text classifier ([doc://com.apple.documentation/documentation/CreateML/MLTextClassifier](https://developer.apple.com/documentation/CreateML/MLTextClassifier)) or word tagger ([doc://com.apple.documentation/documentation/CreateML/MLWordTagger](https://developer.apple.com/documentation/CreateML/MLWordTagger)) models. Use [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLModel](https://developer.apple.com/documentation/NaturalLanguage/NLModel) to integrate those models into your app. This integration ensures that your tokenization and tagger configurations are identical when you train your model and use it in your app.

If you create a text classifier as described in doc:creating-a-text-classifier-model, you can integrate that model into your app and use it to make predictions like this:

```swift
let text = "I am very happy."

do {
    let mlModel = try SentimentClassifier(configuration: MLModelConfiguration()).model
        
    let customModel = try NLModel(mlModel: mlModel)
    
    // Use the text classifier model to get the most likely label.
    if let label = customModel.predictedLabel(for: text) {
        print("Most likely label: \(label)")
    }
    
    // Get multiple possible labels with their associated confidence scores.
    let labelHypotheses = customModel.predictedLabelHypotheses(for: text, maximumCount: 3)
    print("Label confidence scores: \(labelHypotheses)")
    
} catch {
    print(error)
}
```

If you create a custom word tagger as described in [doc://com.apple.naturallanguage/documentation/NaturalLanguage/creating-a-word-tagger-model](https://developer.apple.com/documentation/NaturalLanguage/creating-a-word-tagger-model), you can integrate that model into your app and generate tags for new text input like this:

```swift
let text = "The iPad is my favorite Apple product."

do {
    let mlModel = try AppleTagger(configuration: MLModelConfiguration()).model
        
    let customModel = try NLModel(mlModel: mlModel)
    let customTagScheme = NLTagScheme("Apple")
    
    let tagger = NLTagger(tagSchemes: [.nameType, customTagScheme])
    tagger.string = text
    tagger.setModels([customModel], forTagScheme: customTagScheme)
    
    tagger.enumerateTags(in: text.startIndex..<text.endIndex, unit: .word, 
                         scheme: customTagScheme, options: .omitWhitespace) { tag, tokenRange  in
        if let tag = tag {
            print("\(text[tokenRange]): \(tag.rawValue)")
        }
        return true
    }
} catch {
    print(error)
}
```

## Topics

### Creating a model

- [init(mlModel:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/init(mlmodel:)) ‚Äî Creates a new natural language model based on the given Core ML model instance.
- [init(contentsOf:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/init(contentsof:)) ‚Äî Creates a new natural language model based on a compiled Core ML model at the given URL.
### Making predictions

- [predictedLabel(for:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabel(for:)) ‚Äî Predicts a label for the given input string.
- [predictedLabels(forTokens:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabels(fortokens:)) ‚Äî Predicts a label for each string in the given array.
- [predictedLabelHypotheses(for:maximumCount:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabelhypotheses(for:maximumcount:)) ‚Äî Predicts multiple possible labels for the given input string.
- [predictedLabelHypotheses(forTokens:maximumCount:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabelhypotheses(fortokens:maximumcount:)) ‚Äî Predicts multiple possible labels for each string in the given array.
### Inspecting a model

- [configuration](https://developer.apple.com/documentation/naturallanguage/nlmodel/configuration) ‚Äî A configuration describing the natural language model.
- [NLModelConfiguration](https://developer.apple.com/documentation/naturallanguage/nlmodelconfiguration) ‚Äî The configuration parameters of a natural language model.
### Related Documentation

- [MLTextClassifier](https://developer.apple.com/documentation/CreateML/MLTextClassifier) ‚Äî A model you train to classify natural language text.
- [MLWordTagger](https://developer.apple.com/documentation/CreateML/MLWordTagger) ‚Äî A word-tagging model you train to classify natural language text at the word level.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLModel](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLModel)*
--- END FILE ---

--- FILE: Technologies.md ---
# Technologies


---

*Source: [https://developer.apple.com/documentation/com.apple.welcome-experience-documentation/documentation/technologies](https://developer.apple.com/documentation/com.apple.welcome-experience-documentation/documentation/technologies)*
--- END FILE ---
=== END SWIFT DOCUMENTATION ===
=== END CONTEXT ===

=== BUILD ATTEMPT 1 FAILED ===
The previous implementation failed with the following errors:

Build failed but no detailed error log available.

=== INSTRUCTIONS FOR ATTEMPT 2 ===
1. Analyze what went wrong in the previous approach
2. Try a DIFFERENT approach or fix the specific issues
3. Do NOT repeat the same mistakes
4. If the same approach keeps failing, consider an alternative implementation strategy
5. Write the corrected code directly - do not explain, just implement

Please fix the issues and provide the corrected implementation.
mcp: xcodebuildmcp starting
mcp: xcodebuildmcp ready
mcp startup: ready: xcodebuildmcp
exec
/bin/zsh -lc ls in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
Algo
Artifacts
README.md
Racism_is_an_engineering_problem.txt
Redefining_Racism.aux
Redefining_Racism.fdb_latexmk
Redefining_Racism.fls
Redefining_Racism.log
Redefining_Racism.out
Redefining_Racism.pdf
Redefining_Racism.synctex.gz
Redefining_Racism.tex
__Avenue
app
critique
swiftDocs
venn_diagram_1.png
venn_diagram_2.png
website

thinking
**Locating target directory**

I'm checking the contents of the app/decodingOppression directory to find relevant files for the task.
exec
/bin/zsh -lc 'rg --files app/decodingOppression/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism exited 2 in 52ms:
rg: app/decodingOppression/decodingOppression/decodingOppression: IO error for operation on app/decodingOppression/decodingOppression/decodingOppression: No such file or directory (os error 2)
exec
/bin/zsh -lc 'ls app/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
decodingOppression
decodingOppression.xcodeproj
decodingOppressionTests
decodingOppressionUITests
exec
/bin/zsh -lc 'ls app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
Assets.xcassets
ContentView.swift
Data
Info.plist
MLX
Models
NLP
Resources
decodingOppression.entitlements
decodingOppressionApp.swift
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/decodingOppressionApp.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  decodingOppressionApp.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import Combine
import SwiftData
import SwiftUI
import UIKit

@main
struct decodingOppressionApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appDelegate

    /// Shared dependencies: same ModelDownloadManager instance is URLSession delegate (identifier matches AppDelegate).
    private let deps = AppDependencies.shared

    var sharedModelContainer: ModelContainer = {

thinking
**Checking session identifier consistency**

Noticed a potential mismatch between the background URLSession identifier used here and the one in the ModelDownloadManager; I'll verify that they align correctly.
exec
/bin/zsh -lc "sed -n '1,240p' app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  ModelDownloadManager.swift
//  decodingOppression
//
//  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
//

import Foundation
import Observation
import Hub

@MainActor
@Observable
final class ModelDownloadManager: NSObject {
    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"

    enum DownloadState: Sendable {
        case unavailable
        case downloading(progress: Double) // 0.0 ‚Äì 1.0
        case available(modelURL: URL)

thinking
**Verifying session identifier linkage**

Noted that the background URLSession identifier in AppDelegate must match the manager's sessionIdentifier; this is done but needs confirmation. Next, I'll check Tier2Engine.
exec
/bin/zsh -lc "sed -n '1,240p' app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  Tier2Engine.swift
//  decodingOppression
//
//  Facade mirroring Tier1Engine; gates MLX embedding and classifier behind download state.
//

import Foundation

actor Tier2Engine {
    private let embeddingEngine: MLXEmbeddingEngine
    private let classifier: MLXClauseClassifier
    private let downloadManager: ModelDownloadManager

    init(downloadManager: ModelDownloadManager) {
        self.downloadManager = downloadManager
        self.embeddingEngine = MLXEmbeddingEngine()
        self.classifier = MLXClauseClassifier(downloadManager: downloadManager)
    }


thinking
**Checking embedding methods and pipeline usage**

Noticing "similarity" and "embed" methods exist but suspecting they might not be integrated into the pipeline; next is to verify embeddingEngine usage and pipeline wiring for embeddings.
exec
/bin/zsh -lc 'rg -n "Tier2Engine|embeddingEngine|Tier2" app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:2://  Tier2EngineHolder.swift
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:5://  Observable holder for Tier2Engine; plumbed through environment for pipeline/view-model.
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:13:final class Tier2EngineHolder: ObservableObject {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:14:    private let engine: Tier2Engine
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:19:        self.engine = Tier2Engine(downloadManager: downloadManager)
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:22:    /// Classify a clause using Tier2 (MLX) when the model is available.
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:2://  Tier2Engine.swift
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:10:actor Tier2Engine {
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:11:    private let embeddingEngine: MLXEmbeddingEngine
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:17:        self.embeddingEngine = MLXEmbeddingEngine()
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:31:        try await embeddingEngine.loadModel()
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:36:        try await embeddingEngine.loadModel()
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:37:        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:42:        try await embeddingEngine.loadModel()
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:43:        return try await embeddingEngine.embed(text)
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:46:    /// Whether the Tier2 model is downloaded and ready for classification.
app/decodingOppression/decodingOppression/ContentView.swift:28:            Button("Download Tier2 model") {
app/decodingOppression/decodingOppression/ContentView.swift:45:            Label("Tier2 model ready", systemImage: "checkmark.circle.fill")
app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift:5://  Routes clause classification through Tier2 when available, falling back to Tier1.
app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift:12:    private let tier2Holder: Tier2EngineHolder

thinking
**Noting Tier2EngineHolder reference**
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  Tier2EngineHolder.swift
//  decodingOppression
//
//  Observable holder for Tier2Engine; plumbed through environment for pipeline/view-model.
//

import Combine
import Foundation
import SwiftUI

@MainActor
final class Tier2EngineHolder: ObservableObject {
    private let engine: Tier2Engine
    /// Used so Swift synthesizes objectWillChange for ObservableObject.
    @Published private(set) var isReady = false

    init(downloadManager: ModelDownloadManager) {
        self.engine = Tier2Engine(downloadManager: downloadManager)
    }
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/ContentView.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  ContentView.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject private var deps: AppDependencies

    var body: some View {
        VStack(spacing: 16) {
            modelDownloadSection
            ContentUnavailableView(
                "decodingOppression",
                systemImage: "doc.text.magnifyingglass",
                description: Text("Policy analysis placeholder")
            )

thinking
**Identifying key class in pipeline**
exec
/bin/zsh -lc "sed -n '1,240p' app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  ClauseClassificationPipeline.swift
//  decodingOppression
//
//  Routes clause classification through Tier2 when available, falling back to Tier1.
//

import Foundation

actor ClauseClassificationPipeline {
    private let tier1Engine: Tier1Engine
    private let tier2Holder: Tier2EngineHolder

    init(tier2Holder: Tier2EngineHolder) throws {
        self.tier1Engine = try Tier1Engine()
        self.tier2Holder = tier2Holder
    }

    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
        try await tier1Engine.extractAndPreprocess(pdf: url)

thinking
**Reviewing model manager usage and concurrency**
exec
/bin/zsh -lc "sed -n '1,240p' app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  MLXEmbeddingEngine.swift
//  decodingOppression
//
//  Actor that loads BGE small embedder and provides similarity for taxonomy matching.
//

import Foundation
#if !targetEnvironment(simulator)
import MLX
import MLXEmbedders
#endif

actor MLXEmbeddingEngine {
#if !targetEnvironment(simulator)
    private var modelContainer: ModelContainer?

    func loadModel() async throws {
        if modelContainer != nil { return }
        modelContainer = try await loadModelContainer(

thinking
**Analyzing concurrency and build issues**

I'm investigating potential concurrency-related build errors involving @MainActor ObservableObjects used with SwiftUI environment objects and Combine/Observation interplay, checking for duplicates or misuse of AppDependencies and related classes in the repo to align with comment instructions and resolve build failures without error logs.
exec
/bin/zsh -lc 'rg -n "AppDependencies" app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
app/decodingOppression/decodingOppression/ContentView.swift:11:    @EnvironmentObject private var deps: AppDependencies
app/decodingOppression/decodingOppression/ContentView.swift:53:        .environmentObject(AppDependencies.shared)
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:18:    private let deps = AppDependencies.shared
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:46:final class AppDependencies: ObservableObject {
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:58:    static let shared = AppDependencies()

thinking
**Assessing Tier2Engine integration**

I'm verifying whether Tier2Engine is actively used in the pipeline despite relying on tier2Holder, focusing on its application in similarity and embed features.
exec
/bin/zsh -lc "rg -n \"similarity\\(|embed\\(\" app/decodingOppression/decodingOppression" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:33:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:34:        try await engine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:38:    func embed(_ text: String) async throws -> [Float] {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:39:        try await engine.embed(text)
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift:25:    func embed(_ text: String) async throws -> [Float] {
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift:54:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift:55:        let a = try await embed(clause)
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift:56:        let b = try await embed(taxonomyTerm)
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift:64:    func embed(_ text: String) async throws -> [Float] {
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift:72:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:35:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:37:        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:41:    func embed(_ text: String) async throws -> [Float] {
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:43:        return try await embeddingEngine.embed(text)
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:90:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:95:        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:98:    func embed(_ text: String) async throws -> [Float] {
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:103:        return try await pipeline.embed(text)
app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift:31:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift:32:        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)


thinking
**Evaluating previous issues with pipeline wiring**
thinking
**Analyzing concurrency issues and Actor isolation causing build failures**

Potential build errors stem from main-actor isolation violations when accessing `@MainActor` static properties like the background completion handler from nonisolated contexts such as AppDelegate, requiring careful use of `@MainActor` annotations and async calls. Adjusting visibility of Tier2Engine‚Äôs embedding methods to `public` may address previous comment requirements, while ensuring the pipeline properly uses these methods or removing dead code. Next, I'll implement needed concurrency fixes and visibility changes to meet these constraints.
exec
/bin/zsh -lc 'rg -n "taxonomy|embedding|similarity" app/decodingOppression/decodingOppression/NLP app/decodingOppression/decodingOppression/Models' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift:31:    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift:32:        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:33:    private let embedding: NLEmbedding?
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:56:        self.embedding = NLEmbedding.wordEmbedding(for: .english)
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:109:        guard let embedding else { return 0 }
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:110:        guard embedding.contains(lemma) else { return 0 }
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:114:            guard embedding.contains(term) else { continue }
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:115:            let distance = embedding.distance(between: lemma, and: term, distanceType: .cosine)
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:116:            let similarity = max(0, 1 - distance)
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:117:            if similarity > best {
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift:118:                best = similarity

thinking
**Inspecting KeywordEngine for integration**
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  KeywordEngine.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/22/26.
//

import Foundation
import NaturalLanguage

nonisolated struct KeywordFeatureVector: Sendable {
    let outgroupBurdenScore: Double
    let ingroupBenefitScore: Double
    let eliteExtractionScore: Double
    let proxyTermsFound: [String]
    let confidence: Double
}

actor KeywordEngine {
    private struct KeywordTaxonomies: Decodable {

thinking
**Clarifying embedding engine usage**

KeywordEngine uses natural language embeddings (NLEmbedding), not MLX, while the comment about Tier2 embedding may relate to taxonomy matching; next I'll verify if classification uses KeywordEngine by checking Tier1Engine.
exec
/bin/zsh -lc "sed -n '1,260p' app/decodingOppression/decodingOppression/NLP/Tier1Engine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  Tier1Engine.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/22/26.
//

import Foundation

actor Tier1Engine {
    private let clauseAnalyzer: ClauseAnalyzer

    init() throws {
        let keywordEngine = try KeywordEngine()
        self.clauseAnalyzer = ClauseAnalyzer(keywordEngine: keywordEngine)
    }

    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
        let rawText = try PDFExtractor.extract(from: url)
        return TextPreprocessor.preprocess(text: rawText)


thinking
**Identifying concurrency issue in build failure**

The build likely fails due to concurrency with unannotated AppDelegate methods accessing main-actor static properties; next, I'll verify and adjust AppDelegate to use @MainActor to fix this.
thinking
**Considering @MainActor on AppDelegate and @Observable usage**

Adding `@MainActor` to AppDelegate would resolve concurrency warnings with main-actor properties; meanwhile, mixing `@Observable` ModelDownloadManager inside `ObservableObject` AppDependencies with `@EnvironmentObject` may cause runtime update issues but likely not build errors.
exec
/bin/zsh -lc "sed -n '1,260p' app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
//
//  MLXClauseClassifier.swift
//  decodingOppression
//
//  Actor that loads Qwen3-4B-4bit + LoRA and classifies clauses to TierClassification.
//

import Foundation
#if !targetEnvironment(simulator)
import MLXLLM
import MLXLMCommon
#endif

actor MLXClauseClassifier {
#if !targetEnvironment(simulator)
    private var session: ChatSession?
    private let downloadManager: ModelDownloadManager

    init(downloadManager: ModelDownloadManager) {
        self.downloadManager = downloadManager


thinking
**Analyzing environment and observation mismatch**

The app injects AppDependencies as an environment object but doesn't manage it as a StateObject, and since ModelDownloadManager isn't @Published within AppDependencies, changes there won't trigger UI updates. This suggests the UI won't reflect ModelDownloadManager state changes because the new Observation system isn't wired through the existing ObservableObject environment setup.
thinking
**Confirming iOS deployment target to resolve Observation use**

The build likely failed due to using `@Observable` from the Observation framework unavailable below iOS 17; verifying the project's deployment target will reveal if switching ModelDownloadManager to `ObservableObject` with Combine is needed for compatibility.
exec
/bin/zsh -lc 'rg -n "IPHONEOS_DEPLOYMENT_TARGET" app/decodingOppression/decodingOppression.xcodeproj/project.pbxproj' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
456:				IPHONEOS_DEPLOYMENT_TARGET = 26.2;
501:				IPHONEOS_DEPLOYMENT_TARGET = 26.2;
646:				IPHONEOS_DEPLOYMENT_TARGET = 26.2;
672:				IPHONEOS_DEPLOYMENT_TARGET = 26.2;
697:				IPHONEOS_DEPLOYMENT_TARGET = 26.2;
722:				IPHONEOS_DEPLOYMENT_TARGET = 26.2;



thinking
**Assessing concurrency and annotation issues**

The target iOS version is unusually high, but the key concern is potential conflicts from mixing `@Observable`, `@MainActor`, and `NSObject`, especially with Swift 6's stricter concurrency; this might cause build or runtime issues with `ModelDownloadManager`.
thinking
**Planning switch to ObservableObject and EnvironmentObject**

Observing nested state changes fails because `ModelDownloadManager` isn‚Äôt injected directly as an `@EnvironmentObject` or observed with `@ObservedObject` in the view; switching from `@Observable` to `ObservableObject` with `@Published` properties and injecting `ModelDownloadManager` separately as an environment object should fix UI update issues.
thinking
**Planning full conversion to ObservableObject and removing static handler**

To fix build and observation issues, the plan is to convert ModelDownloadManager from `@Observable` to `ObservableObject` with `@Published` properties, remove the static background handler in favor of an instance method, mark AppDelegate as `@MainActor` to call that instance method directly, inject ModelDownloadManager separately as an environment object, and update ContentView and previews accordingly.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -7,4 +7,4 @@
 
+import Combine
 import Foundation
-import Observation
 import Hub
@@ -12,4 +12,3 @@
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
@@ -21,8 +20,5 @@
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
@@ -194,4 +190,3 @@
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }


thinking
**Updating AppDelegate for background handling**

I'm removing the static handler and adding setBackgroundCompletionHandler in AppDelegate, marking it @MainActor. I'll keep Combine import since @Published is used in AppDependencies.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -108,2 +108,3 @@
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
@@ -119,3 +120,3 @@
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/decodingOppressionApp.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..b8ec7fc35581ddcb30407e7abbde4d38af49ce3d
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -106,6 +106,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +118,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..b8ec7fc35581ddcb30407e7abbde4d38af49ce3d
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -106,6 +106,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +118,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }


thinking
**Injecting model manager as environment object**

I'm adding ModelDownloadManager as an environment object in the app entry point using the shared instance via dependencies, preserving its use in AppDependencies and ContentView.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -37,2 +37,3 @@
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/decodingOppressionApp.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }


thinking
**Updating ContentView for environment object**
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/ContentView.swift
@@ -11,2 +11,3 @@
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
@@ -25,9 +26,9 @@
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
@@ -53,2 +54,3 @@
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/ContentView.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }

file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }


thinking
**Reviewing main-actor isolation and handler usage**

ModelDownloadManager remains @MainActor with ObservableObject, and the backgroundCompletionHandler usage aligns with that isolation. The instance method replaces the removed static handler properly, but I need to update all references to the removed static property to ensure consistency.
exec
/bin/zsh -lc 'rg -n "sharedBackgroundCompletionHandler" app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism exited 1 in 51ms:

file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }



thinking
**Assessing access control for embedding method**

The comment calls for a public async method on Tier2Engine, but making it truly public conflicts with internal types used in parameters, which would cause compile errors unless more types are made public‚Äîan extensive change.
thinking
**Planning to make embedding methods public via public actor**

Deciding to mark Tier2Engine as a public actor and make embedding-related methods public since their parameter types are public; this meets the comment‚Äôs requirements without exposing internal types like Clause. The internal initializer is acceptable, and related usage should remain compatible.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -9,3 +9,3 @@
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
@@ -29,3 +29,3 @@
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
@@ -34,3 +34,3 @@
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
@@ -40,3 +40,3 @@
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index c54bbd0036ffe4e5bd88e237071aa0da7684063c..baef859899a16db110e80d51ea0e69c97393534c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -7,7 +7,7 @@
 
 import Foundation
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
     private let classifier: MLXClauseClassifier
     private let downloadManager: ModelDownloadManager
@@ -27,18 +27,18 @@
     }
 
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
     }
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.embed(text)
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }

file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index c54bbd0036ffe4e5bd88e237071aa0da7684063c..baef859899a16db110e80d51ea0e69c97393534c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -7,7 +7,7 @@
 
 import Foundation
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
     private let classifier: MLXClauseClassifier
     private let downloadManager: ModelDownloadManager
@@ -27,18 +27,18 @@
     }
 
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
     }
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.embed(text)
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }



thinking
**Reviewing concurrency and visibility changes**

The `ModelDownloadManager` changed to `ObservableObject` with `@Published` properties and dropped Observation, but usage sites don't rely on `@Bindable`, so no immediate updates needed. Concurrency handling looks safe as state updates happen on the main actor. Internal-public visibility and stored property scopes are fine, and unused imports like Observation have been removed.
thinking
**Preparing minimal final summary**

The response will confirm implementation done with a brief listing of changed files only, avoiding explanations per instructions; it also aims to verify no remaining `@Observable` usage elsewhere.
exec
/bin/zsh -lc 'rg -n "@Observable" app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism exited 1 in 51ms:

file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index c54bbd0036ffe4e5bd88e237071aa0da7684063c..baef859899a16db110e80d51ea0e69c97393534c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -7,7 +7,7 @@
 
 import Foundation
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
     private let classifier: MLXClauseClassifier
     private let downloadManager: ModelDownloadManager
@@ -27,18 +27,18 @@
     }
 
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
     }
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.embed(text)
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }


thinking
**Verifying background completion handling and concurrency**

I'm confirming that `setBackgroundCompletionHandler` remains correct and that `ModelDownloadManager` is still `@MainActor` despite no longer using `@Observable`. I'm also reviewing concurrency usage around calling the background completion handler in `urlSessionDidFinishEvents` to avoid unnecessary `Task { @MainActor in ... }`.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  ModelDownloadManager.swift
//  decodingOppression
//
//  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
//

import Combine
import Foundation
import Hub

@MainActor
final class ModelDownloadManager: NSObject, ObservableObject {
    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"

    enum DownloadState: Sendable {
        case unavailable
        case downloading(progress: Double) // 0.0 ‚Äì 1.0
        case available(modelURL: URL)
    }
file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index c54bbd0036ffe4e5bd88e237071aa0da7684063c..baef859899a16db110e80d51ea0e69c97393534c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -7,7 +7,7 @@
 
 import Foundation
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
     private let classifier: MLXClauseClassifier
     private let downloadManager: ModelDownloadManager
@@ -27,18 +27,18 @@
     }
 
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
     }
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.embed(text)
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }



thinking
**Reviewing unused dependency property**

I'm noticing the `deps` property in ContentView is currently unused, which might cause warnings depending on compiler settings, so removing it could prevent these issues unless it's expected for future use.
thinking
**Confirming EnvironmentObject usage and references**

I'm verifying that the unused `@EnvironmentObject` likely won't cause warnings but could be removed for clarity, and I'm preparing to search for any remaining references to the shared model download manager to ensure consistent usage.
exec
/bin/zsh -lc 'rg -n "modelDownloadManager" app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:38:                .environmentObject(deps.modelDownloadManager)
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:60:    let modelDownloadManager = ModelDownloadManager.shared
app/decodingOppression/decodingOppression/ContentView.swift:12:    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
app/decodingOppression/decodingOppression/ContentView.swift:27:        switch modelDownloadManager.state {
app/decodingOppression/decodingOppression/ContentView.swift:30:                Task { await modelDownloadManager.startDownload() }
app/decodingOppression/decodingOppression/ContentView.swift:33:            if let error = modelDownloadManager.downloadError {
file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index c54bbd0036ffe4e5bd88e237071aa0da7684063c..baef859899a16db110e80d51ea0e69c97393534c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -7,7 +7,7 @@
 
 import Foundation
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
     private let classifier: MLXClauseClassifier
     private let downloadManager: ModelDownloadManager
@@ -27,18 +27,18 @@
     }
 
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
     }
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.embed(text)
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }



thinking
**Reviewing visibility and usage of public actors and methods**
thinking
**Confirming usage and preparing concise final response**
codex
Updated files:
- `app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift`
- `app/decodingOppression/decodingOppression/decodingOppressionApp.swift`
- `app/decodingOppression/decodingOppression/ContentView.swift`
- `app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift`

Tests not run (not requested).
file update:
diff --git a/app/decodingOppression/decodingOppression/ContentView.swift b/app/decodingOppression/decodingOppression/ContentView.swift
index 9b23bf323bb7a4510ead9b2429ad5bb619e6ca58..3fb6715fc238111b6a9f68d14df4a332ae44a276
--- a/app/decodingOppression/decodingOppression/ContentView.swift
+++ b/app/decodingOppression/decodingOppression/ContentView.swift
@@ -9,6 +9,7 @@
 
 struct ContentView: View {
     @EnvironmentObject private var deps: AppDependencies
+    @EnvironmentObject private var modelDownloadManager: ModelDownloadManager
 
     var body: some View {
         VStack(spacing: 16) {
@@ -23,13 +24,13 @@
 
     @ViewBuilder
     private var modelDownloadSection: some View {
-        switch deps.modelDownloadManager.state {
+        switch modelDownloadManager.state {
         case .unavailable:
             Button("Download Tier2 model") {
-                Task { await deps.modelDownloadManager.startDownload() }
+                Task { await modelDownloadManager.startDownload() }
             }
             .buttonStyle(.borderedProminent)
-            if let error = deps.modelDownloadManager.downloadError {
+            if let error = modelDownloadManager.downloadError {
                 Text("Error: \(error.localizedDescription)")
                     .font(.caption)
                     .foregroundStyle(.secondary)
@@ -51,4 +52,5 @@
 #Preview {
     ContentView()
         .environmentObject(AppDependencies.shared)
+        .environmentObject(ModelDownloadManager.shared)
 }
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index 8e92b511ea5b125262a6ed444b147a1e362b2de6..8b91e7971b7e379e36d8aa03dc6998cba6006d27
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -5,13 +5,12 @@
 //  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
 //
 
+import Combine
 import Foundation
-import Observation
 import Hub
 
 @MainActor
-@Observable
-final class ModelDownloadManager: NSObject {
+final class ModelDownloadManager: NSObject, ObservableObject {
     nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
 
     enum DownloadState: Sendable {
@@ -19,12 +18,9 @@
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
         case available(modelURL: URL)
     }
-
-    var state: DownloadState = .unavailable
-    var downloadError: Error?
 
-    /// Set by AppDelegate when the system delivers the background session completion handler.
-    static var sharedBackgroundCompletionHandler: (() -> Void)?
+    @Published var state: DownloadState = .unavailable
+    @Published var downloadError: Error?
 
     private var backgroundSession: URLSession = URLSession(configuration: .default)
     nonisolated let modelDestinationURL: URL
@@ -192,8 +188,7 @@
 
     nonisolated func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
         Task { @MainActor in
-            (Self.sharedBackgroundCompletionHandler ?? backgroundCompletionHandler)?()
-            Self.sharedBackgroundCompletionHandler = nil
+            backgroundCompletionHandler?()
             backgroundCompletionHandler = nil
         }
     }
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index c54bbd0036ffe4e5bd88e237071aa0da7684063c..baef859899a16db110e80d51ea0e69c97393534c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -7,7 +7,7 @@
 
 import Foundation
 
-actor Tier2Engine {
+public actor Tier2Engine {
     private let embeddingEngine: MLXEmbeddingEngine
     private let classifier: MLXClauseClassifier
     private let downloadManager: ModelDownloadManager
@@ -27,18 +27,18 @@
     }
 
     /// Load embedding model for taxonomy matching. Call before similarity/embed.
-    func loadEmbeddingModel() async throws {
+    public func loadEmbeddingModel() async throws {
         try await embeddingEngine.loadModel()
     }
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
-    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+    public func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
-    func embed(_ text: String) async throws -> [Float] {
+    public func embed(_ text: String) async throws -> [Float] {
         try await embeddingEngine.loadModel()
         return try await embeddingEngine.embed(text)
     }
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 5b3dddfa285199585f9517c35fcede56d7734838..4a720aaf830723d448c961f1194bdb84e0d168f8
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -35,6 +35,7 @@
         WindowGroup {
             ContentView()
                 .environmentObject(deps)
+                .environmentObject(deps.modelDownloadManager)
         }
         .modelContainer(sharedModelContainer)
     }
@@ -106,6 +107,7 @@
 
 // MARK: - Background URLSession handoff for model download
 
+@MainActor
 final class AppDelegate: NSObject, UIApplicationDelegate {
     func application(
         _ application: UIApplication,
@@ -117,6 +119,6 @@
             return
         }
         // Must match ModelDownloadManager.sessionIdentifier so the shared instance receives delegate callbacks.
-        ModelDownloadManager.sharedBackgroundCompletionHandler = completionHandler
+        ModelDownloadManager.shared.setBackgroundCompletionHandler(completionHandler)
     }
 }

tokens used
109,684
Updated files:
- `app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift`
- `app/decodingOppression/decodingOppression/decodingOppressionApp.swift`
- `app/decodingOppression/decodingOppression/ContentView.swift`
- `app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift`

Tests not run (not requested).
