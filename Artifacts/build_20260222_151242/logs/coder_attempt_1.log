OpenAI Codex v0.104.0 (research preview)
--------
workdir: /Users/emmanuel/Documents/Theory/Redefining_racism
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019c8708-b829-73e3-af09-931eea41a02f
--------
user
You are a Swift/SwiftUI developer. Your task is to implement the following requirements.

IMPORTANT INSTRUCTIONS:
1. Write clean, production-ready Swift code
2. Follow Apple's Swift API Design Guidelines
3. Use SwiftUI for UI components where appropriate
4. Include proper error handling
5. The code must compile without errors
6. After writing code, the build will be verified automatically
7. If the build fails, you will receive error feedback and should try a DIFFERENT approach

TESTING & DEBUGGING REFERENCE:
For building, testing, and debugging iOS/macOS apps, reference this workflow guide:
/Users/emmanuel/Dev/Tools/Eocon-Foundation-V1/.Foundation/Docs/swiftDocs/Testing/XCODEBUILD_MCP_WORKFLOW.md

This guide covers:
- XcodeBuild MCP server tools for programmatic Xcode interaction
- Building for simulator, booting simulators, installing/launching apps
- UI automation: screenshots, accessibility hierarchy, tap simulation
- Debugging UI issues (button taps, gestures, navigation)

=== TASK/REQUIREMENTS ===
I have the following verification comments after thorough review and exploration of the codebase. Implement the comments by following the instructions in the comments verbatim.

---
## Comment 1: Tier2/ModelDownloadManager never instantiated or started; Tier2 classification cannot run

In \`decodingOppressionApp\` (or a top-level environment container) create a shared \`ModelDownloadManager\` instance, call \`startDownload()\` based on UI intent, and inject it into a shared \`Tier2Engine\`. Plumb that engine through your pipeline/view-model so clause classification requests use it. Ensure the background URLSession identifier matches the manager‚Äôs \`sessionIdentifier\`.

### Referred Files
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/ContentView.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
---
## Comment 2: Embedding engine is unused and similarity API is missing from Tier2

Add a public async method on \`Tier2Engine\` that calls \`embeddingEngine.loadModel()\` and returns similarity or embeddings as required, and wire that into the pipeline or callers that need taxonomy matching. If not needed, remove the unused \`embeddingEngine\` property to avoid dead code.

### Referred Files
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift
- /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
---
=== END TASK ===


=== REFERENCE CONTEXT ===
Use the following documentation and context as reference:

=== SWIFT DOCUMENTATION ===

--- FILE: generating-content-and-performing-tasks.md ---
# Generating content and performing tasks with Foundation Models

**Enhance the experience in your app by prompting an on-device large language model.**


## Overview

The Foundation Models framework lets you tap into the on-device large models at the core of Apple Intelligence. You can enhance your app by using generative models to create content or perform tasks. The framework supports language understanding and generation based on model capabilities.

For design guidance, see Human Interface Guidelines > Technologies > [https://developer.apple.com/design/human-interface-guidelines/generative-ai](https://developer.apple.com/design/human-interface-guidelines/generative-ai).


## Understand model capabilities

When considering features for your app, it helps to know what the on-device language model can do. The on-device model supports text generation and understanding that you can use to:

The on-device language model may not be suitable for handling all requests, like:

The model can complete complex generative tasks when you use guided generation or tool calling. For more on handling complex tasks, or tasks that require extensive world-knowledge, see [doc://com.apple.foundationmodels/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation](https://developer.apple.com/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation) and [doc://com.apple.foundationmodels/documentation/FoundationModels/expanding-generation-with-tool-calling](https://developer.apple.com/documentation/FoundationModels/expanding-generation-with-tool-calling).


## Check for availability

Before you use the on-device model in your app, check that the model is available by creating an instance of [doc://com.apple.foundationmodels/documentation/FoundationModels/SystemLanguageModel](https://developer.apple.com/documentation/FoundationModels/SystemLanguageModel) with the [doc://com.apple.foundationmodels/documentation/FoundationModels/SystemLanguageModel/default](https://developer.apple.com/documentation/FoundationModels/SystemLanguageModel/default) property.

Model availability depends on device factors like:

- The device must support Apple Intelligence.

- The device must have Apple Intelligence turned on in Settings.


> **NOTE**: It can take some time for the model to download and become available when a person turns on Apple Intelligence.


Always verify model availability first, and plan for a fallback experience in case the model is unavailable.

```swift
struct GenerativeView: View {
    // Create a reference to the system language model.
    private var model = SystemLanguageModel.default

    var body: some View {
        switch model.availability {
        case .available:
            // Show your intelligence UI.
        case .unavailable(.deviceNotEligible):
            // Show an alternative UI.
        case .unavailable(.appleIntelligenceNotEnabled):
            // Ask the person to turn on Apple Intelligence.
        case .unavailable(.modelNotReady):
            // The model isn't ready because it's downloading or because of other system reasons.
        case .unavailable(let other):
            // The model is unavailable for an unknown reason.
        }
    }
}
```


## Create a session

After confirming that the model is available, create a [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession) object to call the model. For a single-turn interaction, create a new session each time you call the model:

```swift
// Create a session with the system model.
let session = LanguageModelSession()
```

For a multiturn interaction ‚Äî where the model retains some knowledge of what it produced ‚Äî reuse the same session each time you call the model.


## Provide a prompt to the model

A [doc://com.apple.foundationmodels/documentation/FoundationModels/Prompt](https://developer.apple.com/documentation/FoundationModels/Prompt) is an input that the model responds to. Prompt engineering is the art of designing high-quality prompts so that the model generates a best possible response for the request you make. A prompt can be as short as ‚Äúhello‚Äù, or as long as multiple paragraphs. The process of designing a prompt involves a lot of exploration to discover the best prompt, and involves optimizing prompt length and writing style.

When thinking about the prompt you want to use in your app, consider using conversational language in the form of a question or command. For example, ‚ÄúWhat‚Äôs a good month to visit Paris?‚Äù or ‚ÄúGenerate a food truck menu.‚Äù

Write prompts that focus on a single and specific task, like ‚ÄúWrite a profile for the dog breed Siberian Husky‚Äù. When a prompt is long and complicated, the model takes longer to respond, and may respond in unpredictable ways. If you have a complex generation task in mind, break the task down into a series of specific prompts.

You can refine your prompt by telling the model exactly how much content it should generate. A prompt like, ‚ÄúWrite a profile for the dog breed Siberian Husky‚Äù often takes a long time to process as the model generates a full multi-paragraph essay. If you specify ‚Äúusing three sentences‚Äù, it speeds up processing and generates a concise summary. Use phrases like ‚Äúin a single sentence‚Äù or ‚Äúin a few words‚Äù to shorten the generation time and produce shorter text.

```swift
// Generate a longer response for a specific command.
let simple = "Write me a story about pears."

// Quickly generate a concise response.
let quick = "Write the profile for the dog breed Siberian Husky using three sentences."
```


## Provide instructions to the model

[doc://com.apple.foundationmodels/documentation/FoundationModels/Instructions](https://developer.apple.com/documentation/FoundationModels/Instructions) help steer the model in a way that fits the use case of your app. The model obeys prompts at a lower priority than the instructions you provide. When you provide instructions to the model, consider specifying details like:

- What the model‚Äôs role is; for example, ‚ÄúYou are a mentor,‚Äù or ‚ÄúYou are a movie critic‚Äù.

- What the model should do, like ‚ÄúHelp the person extract calendar events,‚Äù or ‚ÄúHelp the person by recommending search suggestions‚Äù.

- What the style preferences are, like ‚ÄúRespond as briefly as possible‚Äù.

- What the possible safety measures are, like ‚ÄúRespond with ‚ÄòI can‚Äôt help with that‚Äô if you‚Äôre asked to do something dangerous‚Äù.

Use content you trust in instructions because the model follows them more closely than the prompt itself. When you initialize a session with instructions, it affects all prompts the model responds to in that session. Instructions can also include example responses to help steer the model. When you add examples to your prompt, you provide the model with a template that shows the model what a good response looks like.


## Generate a response

To call the model with a prompt, call [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession/respond(to:options:)-b2re](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession/respond(to:options:)-b2re) on your session. The response call is asynchronous because it may take a few seconds for the on-device foundation model to generate the response.

```swift
let instructions = """
    Suggest five related topics. Keep them concise (three to seven words) and make sure they \
    build naturally from the person's topic.
    """

let session = LanguageModelSession(instructions: instructions)

let prompt = "Making homemade bread"
let response = try await session.respond(to: prompt)
```


> **NOTE**: A session can only handle a single request at a time, and causes a runtime error if you call it again before the previous request finishes. Check [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession/isResponding](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession/isResponding) to verify the session is done processing the previous request before sending a new one.


Instead of working with raw string output from the model, the framework offers guided generation to generate a custom Swift data structure you define. For more information about guided generation, see [doc://com.apple.foundationmodels/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation](https://developer.apple.com/documentation/FoundationModels/generating-swift-data-structures-with-guided-generation).

When you make a request to the model, you can provide custom tools to help the model complete the request. If the model determines that a [doc://com.apple.foundationmodels/documentation/FoundationModels/Tool](https://developer.apple.com/documentation/FoundationModels/Tool) can assist with the request, the framework calls your [doc://com.apple.foundationmodels/documentation/FoundationModels/Tool](https://developer.apple.com/documentation/FoundationModels/Tool) to perform additional actions like retrieving content from your local database. For more information about tool calling, see [doc://com.apple.foundationmodels/documentation/FoundationModels/expanding-generation-with-tool-calling](https://developer.apple.com/documentation/FoundationModels/expanding-generation-with-tool-calling)


## Consider context size limits per session

The *context window size* is a limit on how much data the model can process for a session instance. A token is a chunk of text the model processes, and the system model supports up to 4,096 tokens. A single token corresponds to three or four characters in languages like English, Spanish, or German, and one token per character in languages like Japanese, Chinese, or Korean. In a single session, the sum of all tokens in the instructions, all prompts, and all outputs count toward the context window size.

If your session processes a large amount of tokens that exceed the context window, the framework throws the error [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession/GenerationError/exceededContextWindowSize(_:)](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession/GenerationError/exceededContextWindowSize(_:)). When you encounter the error, start a new session and try shortening your prompts. If you need to process a large amount of data that won‚Äôt fit in a single context window limit, break your data into smaller chunks, process each chunk in a separate session, and then combine the results.


## Tune generation options and optimize performance

To get the best results for your prompt, experiment with different generation options. [doc://com.apple.foundationmodels/documentation/FoundationModels/GenerationOptions](https://developer.apple.com/documentation/FoundationModels/GenerationOptions) affects the runtime parameters of the model, and you can customize them for every request you make.

```swift
// Customize the temperature to increase creativity.
let options = GenerationOptions(temperature: 2.0)

let session = LanguageModelSession()

let prompt = "Write me a story about coffee."
let response = try await session.respond(
    to: prompt,
    options: options
)
```

When you test apps that use the framework, use Xcode Instruments to understand more about the requests you make, like the time it takes to perform a request. When you make a request, you can access the [doc://com.apple.foundationmodels/documentation/FoundationModels/Transcript](https://developer.apple.com/documentation/FoundationModels/Transcript) entries that describe the actions the model takes during your [doc://com.apple.foundationmodels/documentation/FoundationModels/LanguageModelSession](https://developer.apple.com/documentation/FoundationModels/LanguageModelSession).

---

*Source: [https://developer.apple.com/documentation/com.apple.foundationmodels/documentation/FoundationModels/generating-content-and-performing-tasks-with-foundation-models](https://developer.apple.com/documentation/com.apple.foundationmodels/documentation/FoundationModels/generating-content-and-performing-tasks-with-foundation-models)*
--- END FILE ---

--- FILE: FINAL-COLLECTION-SUMMARY.md ---
# üéâ Complete Apple Documentation Collection - Final Summary

**Date**: October 8, 2025  
**Status**: ‚úÖ **100% SUCCESS - ALL FRAMEWORKS SCRAPED!**

---

## üèÜ Mission Accomplished!

Successfully scraped **ALL 32 FRAMEWORKS** including the two that initially failed!

### üìä Final Statistics

- **Total Frameworks**: 32 (100% success!)
- **Total Documentation Files**: 848 Markdown files
- **Success Rate**: 100% üéâ
- **Collection Location**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/`
- **Total Content Size**: ~5.2 MB

---

## ‚úÖ All 32 Frameworks Successfully Scraped

### AI & Machine Learning (6 frameworks) ‚úÖ
1. ‚úÖ **Foundation Models** (21 files) - Apple's AI foundation models
2. ‚úÖ **Core ML** (42 files) - On-device machine learning
3. ‚úÖ **Vision** (38 files) - Computer vision & image analysis
4. ‚úÖ **Create ML** (30 files) - ML model training
5. ‚úÖ **Speech** (25 files) - Speech recognition & synthesis
6. ‚úÖ **Natural Language** (31 files) - NLP & text analysis ‚≠ê **FIXED!**

### Swift & SwiftUI (2 frameworks) ‚úÖ
7. ‚úÖ **Swift** (27 files) - Swift language documentation
8. ‚úÖ **SwiftUI** (57 files) - Modern declarative UI

### Core Apple Frameworks (3 frameworks) ‚úÖ
9. ‚úÖ **Foundation** (60 files) - Essential data types
10. ‚úÖ **UIKit** (46 files) - iOS UI framework
11. ‚úÖ **AppKit** (60 files) - macOS UI framework

### Graphics & Media (6 frameworks) ‚úÖ
12. ‚úÖ **Metal** (42 files) - Low-level graphics API
13. ‚úÖ **AVFoundation** (50 files) - Audio/video processing
14. ‚úÖ **Core Graphics** (40 files) - 2D graphics
15. ‚úÖ **Core Animation** (41 files) - Animation framework ‚≠ê **FIXED!**
16. ‚úÖ **ARKit** (15 files) - Augmented reality
17. ‚úÖ **RealityKit** (30 files) - 3D rendering for AR

### System & Security (2 frameworks) ‚úÖ
18. ‚úÖ **Security** (30 files) - Cryptography & secure storage
19. ‚úÖ **Network** (30 files) - Modern networking

### App Services (5 frameworks) ‚úÖ
20. ‚úÖ **CloudKit** (30 files) - Cloud data storage
21. ‚úÖ **HealthKit** (25 files) - Health & fitness data
22. ‚úÖ **StoreKit** (25 files) - In-app purchases
23. ‚úÖ **WatchKit** (30 files) - Apple Watch apps
24. ‚úÖ **WidgetKit** (20 files) - Home screen widgets

### Data & Storage (1 framework) ‚úÖ
25. ‚úÖ **Core Data** (40 files) - Object persistence

### System Integration (1 framework) ‚úÖ
26. ‚úÖ **Intents** (25 files) - Siri integration

### Game Development (2 frameworks) ‚úÖ
27. ‚úÖ **SpriteKit** (30 files) - 2D game engine
28. ‚úÖ **SceneKit** (30 files) - 3D game engine

### Development Tools (1 framework) ‚úÖ
29. ‚úÖ **XCTest** (30 files) - Unit testing

### Hardware & Sensors (3 frameworks) ‚úÖ
30. ‚úÖ **Core Motion** (25 files) - Motion & sensor data
31. ‚úÖ **Core Bluetooth** (25 files) - Bluetooth LE
32. ‚úÖ **Core Location** (25 files) - Location services

---

## üîß How We Fixed the Failed Frameworks

### Problem 1: Natural Language (Failed as "natural")
**Solution**: Used the full framework name `naturallanguage` instead of `natural`
```bash
python3 apple_doc_crawler.py "naturallanguage" -m 30 -d 0.5
```
**Result**: ‚úÖ 31 files successfully scraped!

### Problem 2: Core Animation (Failed as "coreanimation")
**Solution**: Used the original framework name `quartzcore` instead of `coreanimation`
```bash
python3 apple_doc_crawler.py "quartzcore" -m 40 -d 0.5
```
**Result**: ‚úÖ 41 files successfully scraped!

---

## üìà Collection Growth

| Metric | Before Retry | After Retry | Improvement |
|--------|-------------|-------------|-------------|
| Frameworks | 30/32 | 32/32 | +2 frameworks |
| Success Rate | 93.8% | 100% | +6.2% |
| Total Files | 802 | 848 | +46 files |
| Content Size | ~4.6 MB | ~5.2 MB | +0.6 MB |

---

## üéØ Verified Documentation

### Speech Framework ‚úÖ
- **Files**: 19 documentation files
- **URL**: https://developer.apple.com/documentation/speech
- **Content**: Speech recognition, synthesis, analysis
- **Location**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/`

### Vision Framework ‚úÖ
- **Files**: 38 documentation files
- **URL**: https://developer.apple.com/documentation/vision
- **Content**: Computer vision, image analysis, object detection
- **Location**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/`

---

## üìÅ Complete Collection Structure

```
/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/
‚îú‚îÄ‚îÄ README.md                                  # Main index
‚îú‚îÄ‚îÄ 848 Framework Documentation Files          # All scraped content
‚îÇ
‚îú‚îÄ‚îÄ AI & Machine Learning (6 frameworks, 187 files)
‚îÇ   ‚îú‚îÄ‚îÄ Foundation Models (21 files)
‚îÇ   ‚îú‚îÄ‚îÄ Core ML (42 files)
‚îÇ   ‚îú‚îÄ‚îÄ Vision (38 files)
‚îÇ   ‚îú‚îÄ‚îÄ Create ML (30 files)
‚îÇ   ‚îú‚îÄ‚îÄ Speech (25 files)
‚îÇ   ‚îî‚îÄ‚îÄ Natural Language (31 files) ‚≠ê NEW
‚îÇ
‚îú‚îÄ‚îÄ Swift & SwiftUI (2 frameworks, 84 files)
‚îÇ   ‚îú‚îÄ‚îÄ Swift (27 files)
‚îÇ   ‚îî‚îÄ‚îÄ SwiftUI (57 files)
‚îÇ
‚îú‚îÄ‚îÄ Core Frameworks (3 frameworks, 166 files)
‚îÇ   ‚îú‚îÄ‚îÄ Foundation (60 files)
‚îÇ   ‚îú‚îÄ‚îÄ UIKit (46 files)
‚îÇ   ‚îî‚îÄ‚îÄ AppKit (60 files)
‚îÇ
‚îú‚îÄ‚îÄ Graphics & Media (6 frameworks, 226 files)
‚îÇ   ‚îú‚îÄ‚îÄ Metal (42 files)
‚îÇ   ‚îú‚îÄ‚îÄ AVFoundation (50 files)
‚îÇ   ‚îú‚îÄ‚îÄ Core Graphics (40 files)
‚îÇ   ‚îú‚îÄ‚îÄ Core Animation (41 files) ‚≠ê NEW
‚îÇ   ‚îú‚îÄ‚îÄ ARKit (15 files)
‚îÇ   ‚îî‚îÄ‚îÄ RealityKit (30 files)
‚îÇ
‚îî‚îÄ‚îÄ ... (15 more frameworks, 185 files)
```

---

## üöÄ Quick Start Commands

### Navigate to Collection
```bash
cd /Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection
```

### Search for AI/ML Content
```bash
# Core ML
grep -r "MLModel" . --include="*.md" | head -20

# Vision
grep -r "VNImageRequest" . --include="*.md" | head -20

# Natural Language (NEW!)
grep -r "NLTagger\|Natural Language" . --include="*.md" | head -20

# Speech
grep -r "SFSpeechRecognizer\|Speech" . --include="*.md" | head -20
```

### Search for Graphics & Animation
```bash
# Core Animation (NEW!)
grep -r "CALayer\|CAAnimation" . --include="*.md" | head -20

# Metal
grep -r "MTL\|Metal" . --include="*.md" | head -20

# ARKit
grep -r "ARKit\|ARSession" . --include="*.md" | head -20
```

### Search for Swift/SwiftUI
```bash
# SwiftUI
grep -r "@State\|@Binding" . --include="*.md" | head -20

# Swift language features
grep -r "async\|await" . --include="*.md" | head -20
```

---

## üìä Coverage by Category

| Category | Frameworks | Files | Percentage |
|----------|-----------|-------|-----------|
| AI & Machine Learning | 6 | 187 | 22% |
| Swift & SwiftUI | 2 | 84 | 10% |
| Core Frameworks | 3 | 166 | 20% |
| Graphics & Media | 6 | 226 | 27% |
| System & Security | 2 | 60 | 7% |
| App Services | 5 | 130 | 15% |
| Other | 8 | 95 | 11% |
| **Total** | **32** | **848** | **100%** |

---

## üéì What You Can Do Now

### 1. AI/ML Development
- **Foundation Models**: Build AI-powered apps with Apple's LLMs
- **Core ML**: Integrate machine learning models
- **Vision**: Add computer vision capabilities
- **Natural Language**: Process and analyze text
- **Speech**: Add voice recognition and synthesis

### 2. UI Development
- **SwiftUI**: Build modern, declarative interfaces
- **UIKit**: iOS app development
- **AppKit**: macOS app development
- **Core Animation**: Create smooth animations

### 3. Graphics & Gaming
- **Metal**: GPU programming and compute
- **ARKit/RealityKit**: Augmented reality experiences
- **SpriteKit/SceneKit**: 2D/3D game development

### 4. System Integration
- **CloudKit**: Sync data across devices
- **HealthKit**: Health and fitness apps
- **Intents/Siri**: Voice integration
- **Core Location**: Location-based features

---

## üîÑ Keep Your Documentation Updated

To get the latest documentation in the future:

```bash
# Navigate to tools directory
cd /Users/emmanuel/Dev/Tools/getMDfromURL

# Re-run the essentials scraper
python3 scrape_essentials.py

# Add the newly fixed frameworks
python3 apple_doc_crawler.py "naturallanguage" -m 30
python3 apple_doc_crawler.py "quartzcore" -m 40

# Copy to research directory
rsync -av output/apple-docs-*/ /Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/
```

---

## üìö Additional Resources

- **Quick Start Guide**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/QUICK-START.md`
- **Scraping Summary**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/SCRAPING-SUMMARY.md`
- **Collection README**: `/Users/emmanuel/Dev/Research/Apple/AI/Docs/Complete-Collection/README.md`
- **Tools Location**: `/Users/emmanuel/Dev/Tools/getMDfromURL`

---

## üéâ Summary

**You now have the most comprehensive Apple documentation collection possible!**

- ‚úÖ All 32 essential frameworks
- ‚úÖ 848 documentation files
- ‚úÖ 100% success rate
- ‚úÖ Fully searchable and offline
- ‚úÖ Perfect for AI/ML, Swift, SwiftUI, and all Apple development

**Ready for any Apple development project! üöÄ**

---

**Generated**: October 8, 2025  
**Status**: ‚úÖ COMPLETE COLLECTION - 100% SUCCESS!  
**Total**: 32 frameworks, 848 files, ~5.2 MB
--- END FILE ---

--- FILE: NLEmbedding.md ---
# NLEmbedding

**A map of strings to vectors, which locates neighboring, similar strings.**

## Availability

- **iOS** 13.0+
- **iPadOS** 13.0+
- **Mac Catalyst** 13.1+
- **macOS** 10.15+
- **tvOS** 13.0+
- **visionOS** 1.0+
- **watchOS** 6.0+


## Overview

Use an [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) to find similar strings based on the proximity of their vectors. The *vocabulary* is the entire set of strings in an embedding. Each string in the vocabulary has a vector, which is an array of doubles, and each double corresponds to a dimension in the embedding. An [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) uses these vectors to determine the distance between two strings, or to find the nearest neighbors of a string in the vocabulary. The higher the similarity of any two strings, the smaller the distance is between them.

[doc://com.apple.naturallanguage/documentation/NaturalLanguage](https://developer.apple.com/documentation/NaturalLanguage) provides built-in word embeddings that you can retrieve by using the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)) method. You can also compile your own custom embedding into an efficient, searchable, on-disk representation. Typically, you compile an embedding by using Create ML‚Äôs [doc://com.apple.documentation/documentation/CreateML/MLWordEmbedding](https://developer.apple.com/documentation/CreateML/MLWordEmbedding) and save it as a file for your Xcode project at development time. Alternatively, you can compile an embedding at runtime by using Natural Language‚Äôs [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/writeEmbeddingForDictionary:language:revision:toURL:error:](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/writeEmbeddingForDictionary:language:revision:toURL:error:) method.

Your custom embedding can use any kind of string that‚Äôs useful to your app, such as phrases, brand names, serial numbers, and so on. For example, you could make an embedding of movie titles. Each movie title could have a vector that places similar movies close together in the embedding.

## Topics

### Creating a word embedding

- [wordEmbedding(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/wordembedding(for:)) ‚Äî Retrieves a word embedding for a given language.
- [wordEmbedding(for:revision:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/wordembedding(for:revision:)) ‚Äî Retrieves a word embedding for a given language and revision.
- [init(contentsOf:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/init(contentsof:)) ‚Äî Creates a word embedding from a model file.
### Creating a sentence embedding

- [sentenceEmbedding(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/sentenceembedding(for:)) ‚Äî Retrieves a sentence embedding for a given language.
- [sentenceEmbedding(for:revision:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/sentenceembedding(for:revision:)) ‚Äî Retrieves a sentence embedding for a given language and revision.
### Finding strings and their distances in an embedding

- [neighbors(for:maximumCount:distanceType:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/neighbors(for:maximumcount:distancetype:)-8f1jc) ‚Äî Retrieves a limited number of strings near a string in the vocabulary.
- [neighbors(for:maximumCount:distanceType:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/neighbors(for:maximumcount:distancetype:)-8lp4z) ‚Äî Retrieves a limited number of strings near a location in the vocabulary space.
- [enumerateNeighbors(for:maximumCount:distanceType:using:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/enumerateneighbors(for:maximumcount:distancetype:using:)-72jda) ‚Äî Passes the nearest strings of a string in the vocabulary to a closure.
- [enumerateNeighbors(for:maximumCount:distanceType:using:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/enumerateneighbors(for:maximumcount:distancetype:using:)-6dy4x) ‚Äî Passes the nearest strings of a location in the vocabulary space to a closure.
- [distance(between:and:distanceType:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/distance(between:and:distancetype:)) ‚Äî Calculates the distance between two strings in the vocabulary space.
- [NLDistance](https://developer.apple.com/documentation/naturallanguage/nldistance) ‚Äî The distance between two strings in a text embedding.
### Inspecting the vocabulary of an embedding

- [dimension](https://developer.apple.com/documentation/naturallanguage/nlembedding/dimension) ‚Äî The number of dimensions in the vocabulary‚Äôs vector space.
- [vocabularySize](https://developer.apple.com/documentation/naturallanguage/nlembedding/vocabularysize) ‚Äî The number of words in the vocabulary.
- [language](https://developer.apple.com/documentation/naturallanguage/nlembedding/language) ‚Äî The language of the text in the word embedding.
- [contains(_:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/contains(_:)) ‚Äî Requests a Boolean value that indicates whether the term is in the vocabulary.
- [vector(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/vector(for:)) ‚Äî Requests the vector for the given term.
- [revision](https://developer.apple.com/documentation/naturallanguage/nlembedding/revision) ‚Äî The revision of the word embedding.
### Saving an embedding

- [write(_:language:revision:to:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/write(_:language:revision:to:)) ‚Äî Exports the word embedding contained within a Core ML model file at the given URL.
### Checking for Natural Language support

- [currentRevision(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/currentrevision(for:)) ‚Äî Retrieves the current version of a word embedding for the given language.
- [supportedRevisions(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/supportedrevisions(for:)) ‚Äî Retrieves all version numbers of a word embedding for the given language.
- [currentSentenceEmbeddingRevision(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/currentsentenceembeddingrevision(for:)) ‚Äî Retrieves the current version of a sentence embedding for the given language.
- [supportedSentenceEmbeddingRevisions(for:)](https://developer.apple.com/documentation/naturallanguage/nlembedding/supportedsentenceembeddingrevisions(for:)) ‚Äî Retrieves all version numbers of a sentence embedding for the given language.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding)*
--- END FILE ---

--- FILE: Finding-similarities-between-pieces-of-text.md ---
# Finding similarities between pieces of text

**Calculate the semantic distance between words or sentences.**


## Overview

Finding semantic similarities between words or sentences can help you create a better user experience for your app. For example, you might enhance the experience of searching for specific photos by knowing that the search term ‚Äúcloud‚Äù is related to the word ‚Äúsky,‚Äù and expanding the search query to return more relevant results.

To find similarities between pieces of natural language text, you use text embeddings. An *embedding* is a map from strings‚Äîwords or sentences‚Äîinto a vector space. Strings that are semantically similar have similar vectors, which means they‚Äôre closer together in vector space.

![Image](media-3687947)

You use embeddings for tasks like:

- Searching for the nearest neighbors to a given term‚Äîfor example, to expand a search query.

- Calculating the distance between terms, as a measure of semantic similarity.

- Using the vectors as an input layer for a model.

In Natural Language, [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) represents an embedding, stored in a space- and time-efficient format. [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) provides pretrained word embeddings for a number of languages, trained on large bodies of general text.


### Find similar words

To calculate the distance between individual words, use a word embedding.

1. Create an instance of [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) with [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/wordEmbedding(for:)), specifying the language for which to generate a word embedding.

2. Call the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/vector(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/vector(for:)) method of the embedding with a specific input word to see the vector generated for that word.

3. To find the distance between your input word and another word, use `distance(between:and:distanceType:)`.

4. To find the nearest neighbors to your input word, enumerate over the word‚Äôs neighbors by calling the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/enumerateNeighborsForString:maximumCount:distanceType:usingBlock:](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/enumerateNeighborsForString:maximumCount:distanceType:usingBlock:) method, specifying the maximum number of nearest neighbors to look at.

```swift
if let embedding = NLEmbedding.wordEmbedding(for: .english) {
    let word = "bicycle"
    
    if let vector = embedding.vector(for: word) {
        print(vector)
    }
    
    let specificDistance = embedding.distance(between: word, and: "motorcycle")
    print(specificDistance.description)
    
    embedding.enumerateNeighbors(for: word, maximumCount: 5) { neighbor, distance in
        print("\(neighbor): \(distance.description)")
        return true
    }
}
```


### Find similar sentences

To calculate the distance between phrases, use a sentence embedding. You might use it to measure similarity between sentences for tasks like text retrieval, or for detecting paraphrases. For example, if a user searches a food-delivery app using the text, ‚ÄúWhere is my order?‚Äù you could use a sentence embedding to suggest a result from the FAQ with the similar title, ‚ÄúHow do I check the status of my order?‚Äù

1. Create an instance of [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding) with [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/sentenceEmbedding(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/sentenceEmbedding(for:)), specifying the language for which to generate a sentence embedding.

2. Call the [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/vector(for:)](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/vector(for:)) method of the embedding with a specific input sentence to see the vector generated for that sentence.

3. To find the distance between your input sentence and another sentence, use [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLEmbedding/distanceBetweenString:andString:distanceType:](https://developer.apple.com/documentation/NaturalLanguage/NLEmbedding/distanceBetweenString:andString:distanceType:).

```swift
if let sentenceEmbedding = NLEmbedding.sentenceEmbedding(for: .english) {
    let sentence = "This is a sentence."

    if let vector = sentenceEmbedding.vector(for: sentence) {
        print(vector)
    }
    
    let distance = sentenceEmbedding.distance(between: sentence, and: "That is a sentence.")
    print(distance.description)
}
```

Sentence embeddings are dynamic. They don‚Äôt have a fixed vocabulary, and they can return results for arbitrary sentences. Nearest-neighbor search therefore doesn‚Äôt apply to sentence embeddings.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/finding-similarities-between-pieces-of-text](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/finding-similarities-between-pieces-of-text)*
--- END FILE ---

--- FILE: NLContextualEmbedding.md ---
# NLContextualEmbedding

**A model that computes sequences of embedding vectors for natural language utterances.**

## Availability

- **iOS** 17.0+
- **iPadOS** 17.0+
- **Mac Catalyst** 17.0+
- **macOS** 14.0+
- **tvOS** 17.0+
- **visionOS** 1.0+
- **watchOS** 10.0+


## Overview

Starting in iOS 17 and macOS 14, the framework supports 27 languages across three models:

- Latin ‚Äî including Croatian, Czech, Danish, Dutch, English, Finnish, French, German, Hungarian, Indonesian, Italian, Norwegian, Polish, Portuguese, Romanian, Slovak, Swedish, Spanish, Turkish, and Vietnamese

- Cyrillic ‚Äî including Bulgarian, Kazakh, Russian, and Ukrainian

- Chinese, Japanese, and Korean

In iOS 18 and macOS 15, the framework expands language support to include three additional models:

- Arabic

- Thai

- Indic ‚Äî including Hindi, Marathi, Bangla, Urdu, Punjabi, Gujarati, Tamil, Telugu, Kannada, and Malayalam

## Topics

### Creating a contextual embedding

- [init(modelIdentifier:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/init(modelidentifier:)) ‚Äî Creates a contextual embedding from a model identifier.
- [init(language:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/init(language:)) ‚Äî Creates a contextual embedding from a language.
- [init(script:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/init(script:)) ‚Äî Creates a contextual embedding from a script.
### Inspecting the contextual embedding

- [dimension](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/dimension) ‚Äî The number of dimensions in the script‚Äôs vector space.
- [hasAvailableAssets](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/hasavailableassets) ‚Äî A Boolean value that indicates whether assets are available to load.
- [languages](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/languages) ‚Äî The languages of the text in the contextual embedding.
- [maximumSequenceLength](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/maximumsequencelength) ‚Äî The maximum number of embedding vectors the model generates, in sequence.
- [modelIdentifier](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/modelidentifier) ‚Äî The model identifier.
- [revision](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/revision) ‚Äî The revision of the contextual embedding.
- [scripts](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/scripts) ‚Äî The scripts of the text in the contextual embedding.
### Requesting assets

- [requestAssets(completionHandler:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/requestassets(completionhandler:)) ‚Äî Requests assets for an embedding, if available.
- [NLContextualEmbedding.AssetsResult](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/assetsresult) ‚Äî The status of an asset request.
### Loading and unloading assets

- [load()](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/load()) ‚Äî Loads the embedding model.
- [unload()](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/unload()) ‚Äî Unloads the embedding model.
### Applying an embedding

- [embeddingResult(for:language:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/embeddingresult(for:language:)) ‚Äî Applies an embedding to a string and obtains the resulting embedding vectors.
- [NLContextualEmbeddingResult](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingresult) ‚Äî An object that represents the embedding vector result from applying a contextual embedding to a string.
### Type Methods

- [contextualEmbeddings(forValues:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding/contextualembeddings(forvalues:))

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbedding](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbedding)*
--- END FILE ---

--- FILE: NLContextualEmbeddingKey.md ---
# NLContextualEmbeddingKey

**Contextual embedding keys.**

## Availability

- **iOS** 12.0+
- **iPadOS** 12.0+
- **Mac Catalyst** 13.0+
- **macOS** 10.14+
- **tvOS** 12.0+
- **visionOS** 1.0+
- **watchOS** 5.0+


## Topics

### Getting embedding keys

- [languages](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/languages) ‚Äî A key that identifies the languages in a contextual embedding.
- [revision](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/revision) ‚Äî A key that identifies the revision for a contextual embedding.
- [scripts](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/scripts) ‚Äî A key that identifies the scripts in a contextual embedding.
### Creating embedding keys

- [init(_:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/init(_:)) ‚Äî Creates an embedding key with the given string.
- [init(rawValue:)](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey/init(rawvalue:)) ‚Äî Creates an embedding key with the given string as its raw value.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbeddingKey](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLContextualEmbeddingKey)*
--- END FILE ---

--- FILE: Natural-Language.md ---
# Natural Language

**Analyze natural language text and deduce its language-specific metadata.**

## Availability

- **iOS** 12.0+
- **iPadOS** 12.0+
- **Mac Catalyst** 13.0+
- **macOS** 10.14+
- **tvOS** 12.0+
- **visionOS** 1.0+
- **watchOS** 5.0+


## Overview

The Natural Language framework provides a variety of natural language processing (NLP) functionality with support for many different languages and scripts. Use this framework to segment natural language text into paragraphs, sentences, or words, and tag information about those segments, such as part of speech, lexical class, lemma, script, and language.

![Image](media-3597579)

Use this framework to perform tasks like:

- *Language identification*, automatically detecting the language of a piece of text.

- *Tokenization*, breaking up a piece of text into linguistic units or tokens.

- *Parts-of-speech tagging*, marking up individual words with their part of speech.

- *Lemmatization*, deducing a word‚Äôs stem based on its morphological analysis.

- *Named entity recognition*, identifying tokens as names of people, places, or organizations.

You can also use this framework with Create ML to train and deploy custom natural language models. For more information, see [doc://com.apple.documentation/documentation/CreateML/creating-a-text-classifier-model](https://developer.apple.com/documentation/CreateML/creating-a-text-classifier-model) and [doc://com.apple.naturallanguage/documentation/NaturalLanguage/creating-a-word-tagger-model](https://developer.apple.com/documentation/NaturalLanguage/creating-a-word-tagger-model).

## Topics

### Tokenization

- [Tokenizing natural language text](https://developer.apple.com/documentation/naturallanguage/tokenizing-natural-language-text) ‚Äî Enumerate the words in a string.
- [NLTokenizer](https://developer.apple.com/documentation/naturallanguage/nltokenizer) ‚Äî A tokenizer that segments natural language text into semantic units.
### Language identification

- [Identifying the language in text](https://developer.apple.com/documentation/naturallanguage/identifying-the-language-in-text) ‚Äî Detect the language in a piece of text by using a language recognizer.
- [NLLanguageRecognizer](https://developer.apple.com/documentation/naturallanguage/nllanguagerecognizer) ‚Äî The language of a body of text.
- [NLLanguage](https://developer.apple.com/documentation/naturallanguage/nllanguage) ‚Äî The languages that the Natural Language framework supports.
### Linguistic tags

- [Identifying parts of speech](https://developer.apple.com/documentation/naturallanguage/identifying-parts-of-speech) ‚Äî Classify nouns, verbs, adjectives, and other parts of speech in a string.
- [Identifying people, places, and organizations](https://developer.apple.com/documentation/naturallanguage/identifying-people-places-and-organizations) ‚Äî Use a linguistic tagger to perform named entity recognition on a string.
- [NLTagger](https://developer.apple.com/documentation/naturallanguage/nltagger) ‚Äî A tagger that analyzes natural language text.
### Text embedding

- [Finding similarities between pieces of text](https://developer.apple.com/documentation/naturallanguage/finding-similarities-between-pieces-of-text) ‚Äî Calculate the semantic distance between words or sentences.
- [NLEmbedding](https://developer.apple.com/documentation/naturallanguage/nlembedding) ‚Äî A map of strings to vectors, which locates neighboring, similar strings.
### Contextual embedding

- [NLContextualEmbedding](https://developer.apple.com/documentation/naturallanguage/nlcontextualembedding) ‚Äî A model that computes sequences of embedding vectors for natural language utterances.
- [NLContextualEmbeddingKey](https://developer.apple.com/documentation/naturallanguage/nlcontextualembeddingkey) ‚Äî Contextual embedding keys.
- [NLScript](https://developer.apple.com/documentation/naturallanguage/nlscript) ‚Äî The writing scripts that the Natural Language framework supports.
### Natural language models

- [Creating a text classifier model](https://developer.apple.com/documentation/CreateML/creating-a-text-classifier-model) ‚Äî Train a machine learning model to classify natural language text.
- [Creating a word tagger model](https://developer.apple.com/documentation/naturallanguage/creating-a-word-tagger-model) ‚Äî Train a machine learning model to tag individual words in natural language text.
- [NLModel](https://developer.apple.com/documentation/naturallanguage/nlmodel) ‚Äî A custom model trained to classify or tag natural language text.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage)*
--- END FILE ---

--- FILE: NLModel.md ---
# NLModel

**A custom model trained to classify or tag natural language text.**

## Availability

- **iOS** 12.0+
- **iPadOS** 12.0+
- **Mac Catalyst** 13.1+
- **macOS** 10.14+
- **tvOS** 12.0+
- **visionOS** 1.0+
- **watchOS** 5.0+


## Overview

With [doc://com.apple.naturallanguage/documentation/NaturalLanguage](https://developer.apple.com/documentation/NaturalLanguage), you can create text classifier ([doc://com.apple.documentation/documentation/CreateML/MLTextClassifier](https://developer.apple.com/documentation/CreateML/MLTextClassifier)) or word tagger ([doc://com.apple.documentation/documentation/CreateML/MLWordTagger](https://developer.apple.com/documentation/CreateML/MLWordTagger)) models. Use [doc://com.apple.naturallanguage/documentation/NaturalLanguage/NLModel](https://developer.apple.com/documentation/NaturalLanguage/NLModel) to integrate those models into your app. This integration ensures that your tokenization and tagger configurations are identical when you train your model and use it in your app.

If you create a text classifier as described in doc:creating-a-text-classifier-model, you can integrate that model into your app and use it to make predictions like this:

```swift
let text = "I am very happy."

do {
    let mlModel = try SentimentClassifier(configuration: MLModelConfiguration()).model
        
    let customModel = try NLModel(mlModel: mlModel)
    
    // Use the text classifier model to get the most likely label.
    if let label = customModel.predictedLabel(for: text) {
        print("Most likely label: \(label)")
    }
    
    // Get multiple possible labels with their associated confidence scores.
    let labelHypotheses = customModel.predictedLabelHypotheses(for: text, maximumCount: 3)
    print("Label confidence scores: \(labelHypotheses)")
    
} catch {
    print(error)
}
```

If you create a custom word tagger as described in [doc://com.apple.naturallanguage/documentation/NaturalLanguage/creating-a-word-tagger-model](https://developer.apple.com/documentation/NaturalLanguage/creating-a-word-tagger-model), you can integrate that model into your app and generate tags for new text input like this:

```swift
let text = "The iPad is my favorite Apple product."

do {
    let mlModel = try AppleTagger(configuration: MLModelConfiguration()).model
        
    let customModel = try NLModel(mlModel: mlModel)
    let customTagScheme = NLTagScheme("Apple")
    
    let tagger = NLTagger(tagSchemes: [.nameType, customTagScheme])
    tagger.string = text
    tagger.setModels([customModel], forTagScheme: customTagScheme)
    
    tagger.enumerateTags(in: text.startIndex..<text.endIndex, unit: .word, 
                         scheme: customTagScheme, options: .omitWhitespace) { tag, tokenRange  in
        if let tag = tag {
            print("\(text[tokenRange]): \(tag.rawValue)")
        }
        return true
    }
} catch {
    print(error)
}
```

## Topics

### Creating a model

- [init(mlModel:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/init(mlmodel:)) ‚Äî Creates a new natural language model based on the given Core ML model instance.
- [init(contentsOf:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/init(contentsof:)) ‚Äî Creates a new natural language model based on a compiled Core ML model at the given URL.
### Making predictions

- [predictedLabel(for:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabel(for:)) ‚Äî Predicts a label for the given input string.
- [predictedLabels(forTokens:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabels(fortokens:)) ‚Äî Predicts a label for each string in the given array.
- [predictedLabelHypotheses(for:maximumCount:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabelhypotheses(for:maximumcount:)) ‚Äî Predicts multiple possible labels for the given input string.
- [predictedLabelHypotheses(forTokens:maximumCount:)](https://developer.apple.com/documentation/naturallanguage/nlmodel/predictedlabelhypotheses(fortokens:maximumcount:)) ‚Äî Predicts multiple possible labels for each string in the given array.
### Inspecting a model

- [configuration](https://developer.apple.com/documentation/naturallanguage/nlmodel/configuration) ‚Äî A configuration describing the natural language model.
- [NLModelConfiguration](https://developer.apple.com/documentation/naturallanguage/nlmodelconfiguration) ‚Äî The configuration parameters of a natural language model.
### Related Documentation

- [MLTextClassifier](https://developer.apple.com/documentation/CreateML/MLTextClassifier) ‚Äî A model you train to classify natural language text.
- [MLWordTagger](https://developer.apple.com/documentation/CreateML/MLWordTagger) ‚Äî A word-tagging model you train to classify natural language text at the word level.

---

*Source: [https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLModel](https://developer.apple.com/documentation/com.apple.naturallanguage/documentation/NaturalLanguage/NLModel)*
--- END FILE ---

--- FILE: Technologies.md ---
# Technologies


---

*Source: [https://developer.apple.com/documentation/com.apple.welcome-experience-documentation/documentation/technologies](https://developer.apple.com/documentation/com.apple.welcome-experience-documentation/documentation/technologies)*
--- END FILE ---
=== END SWIFT DOCUMENTATION ===
=== END CONTEXT ===


Please implement the requirements above. Write the code directly - do not explain, just write the implementation.
mcp: xcodebuildmcp starting
mcp: xcodebuildmcp ready
mcp startup: ready: xcodebuildmcp

thinking
**Listing agents directory contents**
exec
/bin/zsh -lc ls in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
Algo
Artifacts
README.md
Racism_is_an_engineering_problem.txt
Redefining_Racism.aux
Redefining_Racism.fdb_latexmk
Redefining_Racism.fls
Redefining_Racism.log
Redefining_Racism.out
Redefining_Racism.pdf
Redefining_Racism.synctex.gz
Redefining_Racism.tex
__Avenue
app
critique
swiftDocs
venn_diagram_1.png
venn_diagram_2.png
website

thinking
**Searching for AGENTS instructions**

I'm looking for an AGENTS.md or similar file in the repo root to find instructions related to agents.
exec
/bin/zsh -lc "rg --files -g 'AGENTS.md'" in /Users/emmanuel/Documents/Theory/Redefining_racism exited 1 in 53ms:



thinking
**Noting missing AGENTS.md**

AGENTS.md instructions are missing for the specified path; I'll note this briefly upfront and then proceed with the implementation as requested.
thinking
**Identifying key Swift files**

I'll inspect decodingOppressionApp.swift, ContentView, ModelDownloadManager, Tier2Engine, and MLXEmbeddingEngine to understand the app structure and components relevant for implementation.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/decodingOppressionApp.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  decodingOppressionApp.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import Combine
import SwiftData
import SwiftUI
import UIKit

@main
struct decodingOppressionApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appDelegate

    /// Shared dependencies: same ModelDownloadManager instance is URLSession delegate (identifier matches AppDelegate).
    private let deps = AppDependencies.shared

    var sharedModelContainer: ModelContainer = {

thinking
**Checking existing app dependencies**

The app already has shared dependencies like ModelDownloadManager and Tier2EngineHolder; next, I'll examine other files such as ContentView.swift to identify more dependency usage.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/ContentView.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  ContentView.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject private var deps: AppDependencies

    var body: some View {
        VStack(spacing: 16) {
            modelDownloadSection
            ContentUnavailableView(
                "decodingOppression",
                systemImage: "doc.text.magnifyingglass",
                description: Text("Policy analysis placeholder")
            )

thinking
**Investigating model download integration**

I noted that ModelDownloadManager exists in AppDependencies but the comment says it‚Äôs neither instantiated nor started, blocking Tier2 classification. Next, I'll inspect ModelDownloadManager, Tier2Engine, and the pipeline to understand integration gaps.
exec
/bin/zsh -lc "sed -n '1,240p' app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
//
//  ModelDownloadManager.swift
//  decodingOppression
//
//  Manages background download of Qwen3-4B-4bit model; observable state for SwiftUI.
//

import Foundation
import Observation
import Hub

@MainActor
@Observable
final class ModelDownloadManager: NSObject {
    enum DownloadState: Sendable {
        case unavailable
        case downloading(progress: Double) // 0.0 ‚Äì 1.0
        case available(modelURL: URL)
    }


thinking
**Aligning sessionIdentifier access**

The sessionIdentifier in ModelDownloadManager is private but must match the AppDelegate‚Äôs background URLSession ID; I'll consider exposing it or using a shared constant to ensure alignment. Also, I'll investigate creating and injecting a shared ModelDownloadManager instance into Tier2Engine as per the requirement comment.
exec
/bin/zsh -lc 'rg -n "Tier2Engine" -S app/decodingOppression/decodingOppression' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:2://  Tier2EngineHolder.swift
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:5://  Observable holder for Tier2Engine; plumbed through environment for pipeline/view-model.
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:13:final class Tier2EngineHolder: ObservableObject {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:14:    private let engine: Tier2Engine
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:19:        self.engine = Tier2Engine(downloadManager: downloadManager)
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:2://  Tier2Engine.swift
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:10:actor Tier2Engine {
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:43:// MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:48:    let tier2Holder: Tier2EngineHolder
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:51:        tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
//
//  Tier2EngineHolder.swift
//  decodingOppression
//
//  Observable holder for Tier2Engine; plumbed through environment for pipeline/view-model.
//

import Combine
import Foundation
import SwiftUI

@MainActor
final class Tier2EngineHolder: ObservableObject {
    private let engine: Tier2Engine
    /// Used so Swift synthesizes objectWillChange for ObservableObject.
    @Published private(set) var isReady = false

    init(downloadManager: ModelDownloadManager) {
        self.engine = Tier2Engine(downloadManager: downloadManager)
    }

thinking
**Inspecting advanced embedding methods**

I'm exploring the Tier2Engine to confirm it contains methods for similarity and embedding as suspected.
exec
/bin/zsh -lc "sed -n '1,260p' app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  Tier2Engine.swift
//  decodingOppression
//
//  Facade mirroring Tier1Engine; gates MLX embedding and classifier behind download state.
//

import Foundation

actor Tier2Engine {
    private let embeddingEngine: MLXEmbeddingEngine
    private let classifier: MLXClauseClassifier
    private let downloadManager: ModelDownloadManager

    init(downloadManager: ModelDownloadManager) {
        self.downloadManager = downloadManager
        self.embeddingEngine = MLXEmbeddingEngine()
        self.classifier = MLXClauseClassifier(downloadManager: downloadManager)
    }


thinking
**Reviewing embedding usage confusion**

The repo has embedding methods in Tier2Engine despite comments saying the embedding engine is unused and similarity API is missing, likely reflecting an outdated review; next, I'll check how Tier2EngineHolder is used in the pipeline to clarify actual usage.
exec
/bin/zsh -lc 'rg -n "Tier2EngineHolder|tier2" app/decodingOppression/decodingOppression -S' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:138:            tier: .tier2
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:2://  Tier2EngineHolder.swift
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:13:final class Tier2EngineHolder: ObservableObject {
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:48:    let tier2Holder: Tier2EngineHolder
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:51:        tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
app/decodingOppression/decodingOppression/Models/Policy.swift:36:    case tier2

thinking
**Inspecting view models pipeline**

I'm searching for the class pipeline to check for usage of Tier2EngineHolder and identify relevant points involving classify or MLX in the view models pipeline.
exec
/bin/zsh -lc 'rg -n "Tier1|Tier2|classif|Clause|Pipeline|ViewModel" app/decodingOppression/decodingOppression -S' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:2://  MLXClauseClassifier.swift
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:5://  Actor that loads Qwen3-4B-4bit + LoRA and classifies clauses to TierClassification.
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:14:actor MLXClauseClassifier {
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:46:    func classify(clause: Clause) async throws -> TierClassification {
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:58:        Clause: \(truncated)
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift:152:    func classify(clause: Clause) async throws -> TierClassification {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:2://  Tier2EngineHolder.swift
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:5://  Observable holder for Tier2Engine; plumbed through environment for pipeline/view-model.
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:13:final class Tier2EngineHolder: ObservableObject {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:14:    private let engine: Tier2Engine
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:19:        self.engine = Tier2Engine(downloadManager: downloadManager)
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:22:    /// Classify a clause using Tier2 (MLX) when the model is available.
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:23:    func classify(clause: Clause) async throws -> TierClassification? {
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift:24:        try await engine.classify(clause: clause)
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:2://  Tier2Engine.swift
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:5://  Facade mirroring Tier1Engine; gates MLX embedding and classifier behind download state.
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:10:actor Tier2Engine {
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:12:    private let classifier: MLXClauseClassifier
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:18:        self.classifier = MLXClauseClassifier(downloadManager: downloadManager)
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift:21:    func classify(clause: Clause) async throws -> TierClassification? {

thinking
**Exploring pipeline view model**

I'm searching for the pipeline view model and reviewing PipelineContracts to understand the needed ClauseAnalyzer, Tier1Engine, and pipeline components.
exec
/bin/zsh -lc 'rg -n "ViewModel|Pipeline|Analyzer|Analysis" app/decodingOppression/decodingOppression -S' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
app/decodingOppression/decodingOppression/decodingOppressionApp.swift:22:            PolicyAnalysis.self,
app/decodingOppression/decodingOppression/NLP/ClauseAnalyzer.swift:2://  ClauseAnalyzer.swift
app/decodingOppression/decodingOppression/NLP/ClauseAnalyzer.swift:10:actor ClauseAnalyzer {
app/decodingOppression/decodingOppression/NLP/Tier1Engine.swift:11:    private let clauseAnalyzer: ClauseAnalyzer
app/decodingOppression/decodingOppression/NLP/Tier1Engine.swift:15:        self.clauseAnalyzer = ClauseAnalyzer(keywordEngine: keywordEngine)
app/decodingOppression/decodingOppression/NLP/Tier1Engine.swift:24:        return await clauseAnalyzer.analyze(clause: clause)
app/decodingOppression/decodingOppression/Models/PipelineContracts.swift:2://  PipelineContracts.swift
app/decodingOppression/decodingOppression/Models/PipelineContracts.swift:19:// MARK: - Analysis progress
app/decodingOppression/decodingOppression/Models/PipelineContracts.swift:21:enum AnalysisProgress {
app/decodingOppression/decodingOppression/Models/PolicyAnalysis.swift:2://  PolicyAnalysis.swift
app/decodingOppression/decodingOppression/Models/PolicyAnalysis.swift:12:final class PolicyAnalysis {
app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift:20:    @Relationship(inverse: \PolicyAnalysis.clauses)
app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift:21:    var analysis: PolicyAnalysis?
app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift:31:        analysis: PolicyAnalysis? = nil

thinking
**Checking clause analyzer implementation**
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/NLP/ClauseAnalyzer.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
//
//  ClauseAnalyzer.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/22/26.
//

import Foundation

actor ClauseAnalyzer {
    private let keywordEngine: KeywordEngine

    init(keywordEngine: KeywordEngine) {
        self.keywordEngine = keywordEngine
    }

    func analyze(clause: Clause) async -> TierClassification {
        let vector = await keywordEngine.analyze(clause: clause)

        let targetGroup = resolveTargetGroup(using: vector)

thinking
**Searching for pipeline usage**

I'm checking if Tier2 is used in any pipeline or related to AnalysisEngine by listing directories to guide targeted searches.
exec
/bin/zsh -lc 'find app/decodingOppression/decodingOppression -maxdepth 2 -type f -name "*.swift"' in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
app/decodingOppression/decodingOppression/Models/ScoreResult.swift
app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift
app/decodingOppression/decodingOppression/Models/Policy.swift
app/decodingOppression/decodingOppression/Models/PolicyAnalysis.swift
app/decodingOppression/decodingOppression/Models/PipelineContracts.swift
app/decodingOppression/decodingOppression/Models/GenerableTypes.swift
app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift
app/decodingOppression/decodingOppression/NLP/PDFExtractor.swift
app/decodingOppression/decodingOppression/NLP/Tier1Engine.swift
app/decodingOppression/decodingOppression/NLP/TextPreprocessor.swift
app/decodingOppression/decodingOppression/NLP/ClauseAnalyzer.swift
app/decodingOppression/decodingOppression/decodingOppressionApp.swift
app/decodingOppression/decodingOppression/ContentView.swift
app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift
app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
app/decodingOppression/decodingOppression/MLX/MLXError.swift
app/decodingOppression/decodingOppression/MLX/Tier2EngineHolder.swift
app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift

thinking
**Assessing engine integration**

The app lacks a pipeline or view model, so the next step is checking if extending Tier1Engine to use Tier2Engine enables clause classification as suggested.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/NLP/Tier1Engine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  Tier1Engine.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/22/26.
//

import Foundation

actor Tier1Engine {
    private let clauseAnalyzer: ClauseAnalyzer

    init() throws {
        let keywordEngine = try KeywordEngine()
        self.clauseAnalyzer = ClauseAnalyzer(keywordEngine: keywordEngine)
    }

    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
        let rawText = try PDFExtractor.extract(from: url)
        return TextPreprocessor.preprocess(text: rawText)

thinking
**Assessing missing pipeline integration**

The requirement implies a shared model manager should be integrated via a pipeline or view-model for clause classification, but no existing pipeline is found; next is to explore MLXClauseClassifier to determine how to incorporate Tier2 and create minimal pipeline logic if needed.
exec
/bin/zsh -lc "sed -n '1,220p' app/decodingOppression/decodingOppression/MLX/MLXClauseClassifier.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
//
//  MLXClauseClassifier.swift
//  decodingOppression
//
//  Actor that loads Qwen3-4B-4bit + LoRA and classifies clauses to TierClassification.
//

import Foundation
#if !targetEnvironment(simulator)
import MLXLLM
import MLXLMCommon
#endif

actor MLXClauseClassifier {
#if !targetEnvironment(simulator)
    private var session: ChatSession?
    private let downloadManager: ModelDownloadManager

    init(downloadManager: ModelDownloadManager) {
        self.downloadManager = downloadManager

thinking
**Identifying embedding engine file**
exec
/bin/zsh -lc "sed -n '1,220p' app/decodingOppression/decodingOppression/MLX/MLXEmbeddingEngine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
//
//  MLXEmbeddingEngine.swift
//  decodingOppression
//
//  Actor that loads BGE small embedder and provides similarity for taxonomy matching.
//

import Foundation
#if !targetEnvironment(simulator)
import MLX
import MLXEmbedders
#endif

actor MLXEmbeddingEngine {
#if !targetEnvironment(simulator)
    private var modelContainer: ModelContainer?

    func loadModel() async throws {
        if modelContainer != nil { return }
        modelContainer = try await loadModelContainer(

thinking
**Identifying potential pipeline gap**

Noticed the classification pipeline may be missing usage of Tier2EngineHolder despite existing similarity logic there; next, I'll inspect related Model and PipelineContracts files for the actual pipeline integration.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/Models/PipelineContracts.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 52ms:
//
//  PipelineContracts.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import Foundation

// MARK: - Architecture scores (Codable for pipeline and training)

struct ArchitectureScores: Codable {
    var aar: Double  // asymmetric autonomy restriction
    var se: Double   // selective empathy
    var ij: Double   // ideological justification
    var rsc: Double  // resistance to structural critique
}

// MARK: - Analysis progress


thinking
**Assessing pipeline necessity**

The codebase may lack a view model or pipeline beyond a ContentView placeholder; the requirement to integrate the engine into a pipeline might mean creating one, but tests might only compile without it. Next, I'll inspect Models/PolicyAnalysis and AnalyzedClause to clarify.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/Models/PolicyAnalysis.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 53ms:
//
//  PolicyAnalysis.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import Foundation
import SwiftData

@Model
final class PolicyAnalysis {
    var id: UUID
    var policyName: String
    var sourceFilename: String
    var dateAnalyzed: Date
    @Attribute(.externalStorage)
    private var scoreResultData: Data
    @Relationship(deleteRule: .cascade)
    var clauses: [AnalyzedClause]
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 61ms:
//
//  AnalyzedClause.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import Foundation
import SwiftData

@Model
final class AnalyzedClause {
    var id: UUID
    var text: String
    var sectionType: SectionType
    var targetGroup: TargetGroup
    var effectDirection: EffectDirection
    var confidence: Double
    var tierUsed: MLTier
    @Relationship(inverse: \PolicyAnalysis.clauses)

thinking
**Identifying missing pipeline component**

There's no existing pipeline for classification, so the next step is to explore related models like ScoreResult to determine how to create or integrate a simple pipeline or view model that invokes classification as required.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/Models/ScoreResult.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 51ms:
//
//  ScoreResult.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/19/26.
//

import Foundation

nonisolated struct ScoreResult: Codable, Sendable {
    var dis: Double
    var ads: Double
    var eis: Double
    var cis: Double
    var oes: Double
    var coi: Double

    static var zero: ScoreResult {
        ScoreResult(dis: 0, ads: 0, eis: 0, cis: 0, oes: 0, coi: 0)
    }



thinking
**Considering pipeline integration**

The tier2 engine exists in AppDependencies but isn't yet used or injected into the environment or view; to satisfy requirements, creating a simple pipeline that integrates Tier2EngineHolder via AppDependencies seems necessary, even without a UI change.
thinking
**Designing classification pipeline with tier2 fallback**

Planning a new actor pipeline that uses Tier2EngineHolder for classification with fallback to Tier1Engine, plus embedding similarity methods wired through pipeline; will expose the pipeline via AppDependencies for dependency injection and consider minimal or no view model integration to meet requirements.
thinking
**Planning error-safe pipeline initialization**

Deciding to avoid fatal errors by storing pipeline as optional with an error property to handle possible initialization failures from Tier1Engine dependencies safely within AppDependencies.
exec
/bin/zsh -lc "sed -n '1,200p' app/decodingOppression/decodingOppression/NLP/KeywordEngine.swift" in /Users/emmanuel/Documents/Theory/Redefining_racism succeeded in 50ms:
//
//  KeywordEngine.swift
//  decodingOppression
//
//  Created by Emmanuel Theodore on 2/22/26.
//

import Foundation
import NaturalLanguage

nonisolated struct KeywordFeatureVector: Sendable {
    let outgroupBurdenScore: Double
    let ingroupBenefitScore: Double
    let eliteExtractionScore: Double
    let proxyTermsFound: [String]
    let confidence: Double
}

actor KeywordEngine {
    private struct KeywordTaxonomies: Decodable {



thinking
**Planning error handling for pipeline initialization**

Considering avoiding fatal errors by storing pipeline construction result as a `Result` type or optional with error, possibly via `AppDependencies`; aiming for clean Swift code with proper error management while respecting async actor constraints on engine usage.
thinking
**Designing actor-based pipeline with main-actor app dependencies**

Decided to implement `ClauseClassificationPipeline` as a throwing actor with async classification methods, instantiate it in a `@MainActor` `AppDependencies` ObservableObject holding optional pipeline and published error, and plan to add classification methods there to safely expose pipeline functionality and handle initialization errors properly.
thinking
**Defining robust pipeline and dependencies with error handling**

Finalized `ClauseClassificationPipeline` actor design to use both Tier1 and Tier2 engines with fallback, and structured `AppDependencies` as `@MainActor` ObservableObject holding optional pipeline and published initialization error, exposing async throwing classification and similarity methods that guard against pipeline unavailability for clean, production-ready error management.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -14,2 +14,4 @@
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
@@ -34,4 +36,2 @@
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
@@ -101,3 +101,3 @@
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 


thinking
**Updating AppDelegate to use sessionIdentifier**
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -62,3 +62,3 @@
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
apply_patch(auto_approved=true) exited 0 in 53ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/decodingOppressionApp.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..aed99de2fefc5cf37ccb44a883ee3e25008ac2da
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -60,7 +60,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..aed99de2fefc5cf37ccb44a883ee3e25008ac2da
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -60,7 +60,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }


thinking
**Updating similarity to load model**
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -35,3 +35,4 @@
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
apply_patch(auto_approved=true) exited 0 in 42ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..aed99de2fefc5cf37ccb44a883ee3e25008ac2da
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -60,7 +60,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..aed99de2fefc5cf37ccb44a883ee3e25008ac2da
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -60,7 +60,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }


thinking
**Creating pipeline file**
file update
A /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
//
//  ClauseClassificationPipeline.swift
//  decodingOppression
//
//  Routes clause classification through Tier2 when available, falling back to Tier1.
//

import Foundation

actor ClauseClassificationPipeline {
    private let tier1Engine: Tier1Engine
    private let tier2Holder: Tier2EngineHolder

    init(tier2Holder: Tier2EngineHolder) throws {
        self.tier1Engine = try Tier1Engine()
        self.tier2Holder = tier2Holder
    }

    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
        try await tier1Engine.extractAndPreprocess(pdf: url)
    }

    func classify(clause: Clause) async -> TierClassification {
        if let tier2Result = try? await tier2Holder.classify(clause: clause),
           let classification = tier2Result {
            return classification
        }
        return await tier1Engine.classify(clause: clause)
    }

    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
    }

    func embed(_ text: String) async throws -> [Float] {
        try await tier2Holder.embed(text)
    }
}
apply_patch(auto_approved=true) exited 0 in 63ms:
Success. Updated the following files:
A app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..aed99de2fefc5cf37ccb44a883ee3e25008ac2da
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -60,7 +60,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..aed99de2fefc5cf37ccb44a883ee3e25008ac2da
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -60,7 +60,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }


thinking
**Updating core dependencies with pipeline and error handling**

I'm adding pipeline integration and pipelineError state to AppDependencies, marking it with @MainActor for concurrency safety, and considering keeping seed since it's unclear if it's used. Next, I'll implement these changes in decodingOppressionApp.swift.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -44,3 +44,8 @@
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: Error {
+        case pipelineUnavailable(underlying: Error?)
+    }
+
     static let shared = AppDependencies()
@@ -48,5 +53,41 @@
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
+    }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.embed(text)
     }
apply_patch(auto_approved=true) exited 0 in 61ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/decodingOppressionApp.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..5be3111e5df0e4b2270da04fc7f75017b1db73db
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,14 +42,55 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: Error {
+        case pipelineUnavailable(underlying: Error?)
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
     }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.embed(text)
+    }
 }
 
 // MARK: - Background URLSession handoff for model download
@@ -60,7 +101,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..5be3111e5df0e4b2270da04fc7f75017b1db73db
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,14 +42,55 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: Error {
+        case pipelineUnavailable(underlying: Error?)
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
     }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.embed(text)
+    }
 }
 
 // MARK: - Background URLSession handoff for model download
@@ -60,7 +101,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }



thinking
**Assessing pipeline and embedding usage**

The pipeline is now integrated via AppDependencies for classification, so explicit Tier1Engine updates aren't required. The embedding engine methods exist in the pipeline though unused elsewhere, which is acceptable as they're intended for future taxonomy matching calls, with Tier2Engine handling model loading before similarity.
thinking
**Verifying concurrency and error handling**

Confirmed the static session identifier is safely accessed despite actor isolation, and classification pipeline calls remain async within main actor context. To avoid concurrency warnings, I'll make the error enum conform to Sendable, ensuring compatibility with async boundaries. Adding a UI button to trigger model download in ContentView is the next clear step.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -46,3 +46,3 @@
 final class AppDependencies: ObservableObject {
-    enum DependencyError: Error {
+    enum DependencyError: Error, Sendable {
         case pipelineUnavailable(underlying: Error?)
apply_patch(auto_approved=true) exited 0 in 60ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/decodingOppressionApp.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..ec0f592ea0d37985a3884cd36c0017d3988cb153
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,14 +42,55 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: Error, Sendable {
+        case pipelineUnavailable(underlying: Error?)
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
     }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.embed(text)
+    }
 }
 
 // MARK: - Background URLSession handoff for model download
@@ -60,7 +101,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..ec0f592ea0d37985a3884cd36c0017d3988cb153
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,14 +42,55 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: Error, Sendable {
+        case pipelineUnavailable(underlying: Error?)
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
     }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+        }
+        return try await pipeline.embed(text)
+    }
 }
 
 // MARK: - Background URLSession handoff for model download
@@ -60,7 +101,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }



thinking
**Reviewing concurrency and Sendable concerns**

Identified potential Swift concurrency issues since error property is MainActor-bound and returned structs lack Sendable conformance, which may cause warnings in Swift 6; currently, these likely pass in Swift 5.9 without enforcement. Noted `loadEmbeddingModel` method may be redundant but safe to keep for now.
thinking
**Refactoring error enum to avoid Sendable issues**

Decided to replace non-Sendable `Error?` associated value in error enum with a `String` description to ensure Sendable compliance and prevent Swift 6 concurrency warnings. Will update error handling accordingly by using localized descriptions instead of storing `Error` directly.
file update
M /Users/emmanuel/Documents/Theory/Redefining_racism/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -46,4 +46,11 @@
 final class AppDependencies: ObservableObject {
-    enum DependencyError: Error, Sendable {
-        case pipelineUnavailable(underlying: Error?)
+    enum DependencyError: LocalizedError {
+        case pipelineUnavailable(underlyingDescription: String)
+
+        var errorDescription: String? {
+            switch self {
+            case .pipelineUnavailable(let underlyingDescription):
+                return "Pipeline unavailable: \(underlyingDescription)"
+            }
+        }
     }
@@ -68,3 +75,4 @@
         guard let pipeline else {
-            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
         }
@@ -75,3 +83,4 @@
         guard let pipeline else {
-            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
         }
@@ -82,3 +91,4 @@
         guard let pipeline else {
-            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
         }
@@ -89,3 +99,4 @@
         guard let pipeline else {
-            throw DependencyError.pipelineUnavailable(underlying: pipelineError)
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
         }
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M app/decodingOppression/decodingOppression/decodingOppressionApp.swift
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..5b3dddfa285199585f9517c35fcede56d7734838
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,13 +42,65 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: LocalizedError {
+        case pipelineUnavailable(underlyingDescription: String)
+
+        var errorDescription: String? {
+            switch self {
+            case .pipelineUnavailable(let underlyingDescription):
+                return "Pipeline unavailable: \(underlyingDescription)"
+            }
+        }
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
+    }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.embed(text)
     }
 }
 
@@ -60,7 +112,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..5b3dddfa285199585f9517c35fcede56d7734838
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,13 +42,65 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: LocalizedError {
+        case pipelineUnavailable(underlyingDescription: String)
+
+        var errorDescription: String? {
+            switch self {
+            case .pipelineUnavailable(let underlyingDescription):
+                return "Pipeline unavailable: \(underlyingDescription)"
+            }
+        }
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
+    }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.embed(text)
     }
 }
 
@@ -60,7 +112,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }



thinking
**Reviewing error handling and concurrency in classification pipeline**

The error model now uses LocalizedError with string messages, and the pipeline error is optional and published accordingly. The `Tier2EngineHolder` methods use async throws and correctly handle model loading, with safe concurrency due to `@MainActor` and pipeline actor usage. The classification method gracefully returns nil when models aren't available without throwing, relying on fallback catching for load failures. Adding a pre-load method is considered but not essential at this point.
thinking
**Preparing summary and notes for final response**

Planning to provide a concise summary listing key file changes and additions with paths, plus notes mentioning missing AGENTS.md and that tests were not run, using flat bullet lists to comply with instructions.
codex
**Summary**
- Added tiered classification pipeline with Tier2-first fallback and embedding helpers in `app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift`.
- Wired shared dependencies to the pipeline with error handling and shared the background session identifier in `app/decodingOppression/decodingOppression/decodingOppressionApp.swift` and `app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift`.
- Ensured Tier2 embedding similarity loads the embedding model before use in `app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift`.

**Notes**
- `AGENTS.md` not found under `/Users/emmanuel/Documents/Theory/Redefining_racism`.
- Build not run.
file update:
diff --git a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
index de240954738940da74a02ebbf11d71bc27fcf9df..8e92b511ea5b125262a6ed444b147a1e362b2de6
--- a/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
+++ b/app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift
@@ -12,6 +12,8 @@
 @MainActor
 @Observable
 final class ModelDownloadManager: NSObject {
+    nonisolated static let sessionIdentifier = "com.decodingOppression.modelDownload"
+
     enum DownloadState: Sendable {
         case unavailable
         case downloading(progress: Double) // 0.0 ‚Äì 1.0
@@ -32,8 +34,6 @@
     private var totalBytesWritten: [Int: Int64] = [:]
     private var expectedByTask: [Int: Int64] = [:]
     private var didEncounterError = false
-    private let sessionIdentifier = "com.decodingOppression.modelDownload"
-
     /// Shared instance for app lifecycle: URLSession delegate and environment injection.
     static let shared: ModelDownloadManager = ModelDownloadManager()
 
@@ -99,7 +99,7 @@
     }
 
     private func makeBackgroundSession() -> URLSession {
-        let config = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)
+        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
         return URLSession(configuration: config, delegate: self, delegateQueue: nil)
     }
 
diff --git a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
index 22fbbc54028f1e8f5ad26bb857f8d81c7f2b3c02..c54bbd0036ffe4e5bd88e237071aa0da7684063c
--- a/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
+++ b/app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift
@@ -33,7 +33,8 @@
 
     /// Cosine similarity between clause and taxonomy term (for taxonomy matching).
     func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
-        try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+        try await embeddingEngine.loadModel()
+        return try await embeddingEngine.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
     }
 
     /// Embed text; returns vector for pipeline/callers that need taxonomy matching.
diff --git a/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
new file mode 100644
index 0000000000000000000000000000000000000000..1758169507c699f868434ebcfa497b0b29440357
--- /dev/null
+++ b/app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift
@@ -0,0 +1,38 @@
+//
+//  ClauseClassificationPipeline.swift
+//  decodingOppression
+//
+//  Routes clause classification through Tier2 when available, falling back to Tier1.
+//
+
+import Foundation
+
+actor ClauseClassificationPipeline {
+    private let tier1Engine: Tier1Engine
+    private let tier2Holder: Tier2EngineHolder
+
+    init(tier2Holder: Tier2EngineHolder) throws {
+        self.tier1Engine = try Tier1Engine()
+        self.tier2Holder = tier2Holder
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        try await tier1Engine.extractAndPreprocess(pdf: url)
+    }
+
+    func classify(clause: Clause) async -> TierClassification {
+        if let tier2Result = try? await tier2Holder.classify(clause: clause),
+           let classification = tier2Result {
+            return classification
+        }
+        return await tier1Engine.classify(clause: clause)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        try await tier2Holder.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        try await tier2Holder.embed(text)
+    }
+}
diff --git a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
index 4872b588334f973c4b8f5149b971308ce89919c6..5b3dddfa285199585f9517c35fcede56d7734838
--- a/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
+++ b/app/decodingOppression/decodingOppression/decodingOppressionApp.swift
@@ -42,13 +42,65 @@
 
 // MARK: - Shared ModelDownloadManager + Tier2Engine for pipeline/view-model
 
+@MainActor
 final class AppDependencies: ObservableObject {
+    enum DependencyError: LocalizedError {
+        case pipelineUnavailable(underlyingDescription: String)
+
+        var errorDescription: String? {
+            switch self {
+            case .pipelineUnavailable(let underlyingDescription):
+                return "Pipeline unavailable: \(underlyingDescription)"
+            }
+        }
+    }
+
     static let shared = AppDependencies()
     let modelDownloadManager = ModelDownloadManager.shared
     let tier2Holder: Tier2EngineHolder
-    @Published private(set) var seed = false
+    private let pipeline: ClauseClassificationPipeline?
+    @Published private(set) var pipelineError: Error?
+
     private init() {
         tier2Holder = Tier2EngineHolder(downloadManager: ModelDownloadManager.shared)
+        do {
+            pipeline = try ClauseClassificationPipeline(tier2Holder: tier2Holder)
+        } catch {
+            pipeline = nil
+            pipelineError = error
+        }
+    }
+
+    func classify(clause: Clause) async throws -> TierClassification {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return await pipeline.classify(clause: clause)
+    }
+
+    func extractAndPreprocess(pdf url: URL) async throws -> [Clause] {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.extractAndPreprocess(pdf: url)
+    }
+
+    func similarity(clause: String, taxonomyTerm: String) async throws -> Double {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.similarity(clause: clause, taxonomyTerm: taxonomyTerm)
+    }
+
+    func embed(_ text: String) async throws -> [Float] {
+        guard let pipeline else {
+            let message = pipelineError?.localizedDescription ?? "Initialization failed"
+            throw DependencyError.pipelineUnavailable(underlyingDescription: message)
+        }
+        return try await pipeline.embed(text)
     }
 }
 
@@ -60,7 +112,7 @@
         handleEventsForBackgroundURLSession identifier: String,
         completionHandler: @escaping () -> Void
     ) {
-        guard identifier == "com.decodingOppression.modelDownload" else {
+        guard identifier == ModelDownloadManager.sessionIdentifier else {
             completionHandler()
             return
         }

tokens used
64,059
**Summary**
- Added tiered classification pipeline with Tier2-first fallback and embedding helpers in `app/decodingOppression/decodingOppression/NLP/ClauseClassificationPipeline.swift`.
- Wired shared dependencies to the pipeline with error handling and shared the background session identifier in `app/decodingOppression/decodingOppression/decodingOppressionApp.swift` and `app/decodingOppression/decodingOppression/MLX/ModelDownloadManager.swift`.
- Ensured Tier2 embedding similarity loads the embedding model before use in `app/decodingOppression/decodingOppression/MLX/Tier2Engine.swift`.

**Notes**
- `AGENTS.md` not found under `/Users/emmanuel/Documents/Theory/Redefining_racism`.
- Build not run.
