You are a Swift/SwiftUI developer. A previous attempt to complete a task failed.

TESTING & DEBUGGING REFERENCE:
For building, testing, and debugging iOS/macOS apps, reference this workflow guide:
/Users/emmanuel/Dev/Tools/Eocon-Foundation-V1/.Foundation/Docs/swiftDocs/Testing/XCODEBUILD_MCP_WORKFLOW.md

This guide covers:
- XcodeBuild MCP server tools for programmatic Xcode interaction
- Building for simulator, booting simulators, installing/launching apps
- UI automation: screenshots, accessibility hierarchy, tap simulation
- Debugging UI issues (button taps, gestures, navigation)

=== ORIGINAL TASK ===
I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

## Observations

T1–T6 are complete. The full backend is in place: \`AnalysisPipeline\`, \`TierResolver\`, \`DefaultPolicyScorer\`, \`ModelDownloadManager\`, \`HistoricalPolicies\`, and all SwiftData models. \`ContentView.swift\` is a placeholder. No UI views, ViewModels, Style structs, or \`ReportExporter\` exist yet. One data-model gap must be closed first: \`AnalyzedClause\` does not persist \`architectureScores\`, \`proxyDetection\`, or \`wasSafetyFallback\`, which are required by the drill-down chart views and export tier-usage stats.

## Approach

Build the UI layer in dependency order: close the data-model gap → navigation shell → screens in flow order → chart views → export → accessibility layer → macOS sidebar. Every view follows the MVVM-S pattern (\`@Observable\` ViewModel + pure-value Style struct). iOS uses \`NavigationStack\`; macOS uses \`NavigationSplitView\` gated with \`#if os(macOS)\`.

---

## Step 1 — Extend \`AnalyzedClause\` to Persist Chart Data

In \`file:app/decodingOppression/decodingOppression/Models/AnalyzedClause.swift\`, add three new stored properties:

- \`architectureScoresData: Data\` — \`@Attribute(.externalStorage)\`, JSON-encoded \`ArchitectureScores\`; expose a computed \`architectureScores: ArchitectureScores\` getter/setter (same pattern as \`PolicyAnalysis.scoreResult\`)
- \`proxyTerms: [String]\` — stored directly (small array)
- \`expandsOutgroup: Bool\`
- \`wasSafetyFallback: Bool\` — \`true\` when \`TierResolver\` routed the clause to Tier 2 after a Tier 3 safety guardrail rejection

Update the \`init\` to accept these new parameters with sensible defaults so existing call sites compile without changes.

---

## Step 2 — Navigation Shell (\`ContentView.swift\`)

Replace the placeholder \`ContentView\` entirely.

- Add \`@AppStorage(\"hasCompletedOnboarding\") private var hasCompletedOnboarding: Bool = false\`
- **iOS path** (\`#if os(iOS)\`): \`NavigationStack\` — show \`WelcomeView\` when \`!hasCompletedOnboarding\`, otherwise \`PolicyHistoryView\` as the root
- **macOS path** (\`#if os(macOS)\`): \`NavigationSplitView\` with a sidebar (\`List\` of \`SidebarItem\` enum: \`.analyze\`, \`.training\`, \`.validation\`, \`.data\`) and a detail column that switches on the selected item; the Analyze item renders \`PolicyHistoryView\` in the sidebar column and a detail panel for \`ScoreCardView\`/charts
- Pass \`hasCompletedOnboarding\` binding into \`WelcomeView\`

---

## Step 3 — \`WelcomeView\` + \`WelcomeViewModel\` + \`WelcomeViewStyle\`

**Files:** \`Views/WelcomeView.swift\`, \`ViewModels/WelcomeViewModel.swift\`, \`Views/Style/WelcomeViewStyle.swift\`

**\`WelcomeViewModel: @Observable @MainActor\`**
- \`isDownloadStarted: Bool\`
- \`func getStarted(deps: AppDependencies, hasCompletedOnboarding: inout Bool)\` — calls \`deps.startTier2Download()\`, sets \`hasCompletedOnboarding = true\`

**\`WelcomeView\`**
- App icon, one-sentence description, \"Get Started\" button
- Inline download progress section (observe \`modelDownloadManager.state\`): \`ProgressView(value:)\` + percentage label + \"Pause\" button calling \`modelDownloadManager.cancelDownload()\`
- Retry button when \`modelDownloadManager.downloadError != nil\`
- Accessibility: \`.accessibilityHint\` on \"Get Started\" button; \`@AccessibilityFocusState\` to move focus to progress bar after tap

**\`WelcomeViewStyle\`**
- \`reduceMotion\`, \`dynamicTypeSize\` environment values
- \`static func progressAnimation(reduceMotion: Bool) -> Animation?\`

---

## Step 4 — \`PolicyHistoryView\` + \`PolicyHistoryViewModel\` + \`PolicyHistoryViewStyle\`

**Files:** \`Views/PolicyHistoryView.swift\`, \`ViewModels/PolicyHistoryViewModel.swift\`, \`Views/Style/PolicyHistoryViewStyle.swift\`

**\`PolicyHistoryViewModel: @Observable @MainActor\`**
- \`isShowingFilePicker: Bool\`
- \`selectedAnalysis: PolicyAnalysis?\`
- \`func delete(_ analysis: PolicyAnalysis, context: ModelContext)\` — calls \`context.delete(analysis)\`

**\`PolicyHistoryView\`**
- \`@Query(sort: \\PolicyAnalysis.dateAnalyzed, order: .reverse) var analyses: [PolicyAnalysis]\`
- \`@Environment(\\.modelContext) private var modelContext\`
- Navigation bar: title \"Analyses\", trailing \"+\" button sets \`viewModel.isShowingFilePicker = true\`
- MLX downloading banner: shown when \`modelDownloadManager.state\` is \`.downloading\` or \`.unavailable\` (and \`hasCompletedOnboarding\`); disappears when \`.available\`
- List rows: policy name, formatted date + clause count, COI badge
- \`.swipeActions\` (iOS) / \`.contextMenu { Button(\"Delete\", role: .destructive) }\` (macOS) calling \`viewModel.delete\`
- Empty state: \`ContentUnavailableView(\"No Analyses\", systemImage: \"doc.text.magnifyingglass\", description: Text(\"Analyze your first policy\"))\`
- \`.fileImporter(isPresented: \$viewModel.isShowingFilePicker, allowedContentTypes: [.pdf])\` → on success navigate to \`AnalysisView(pdfURL:)\`
- Tapping a row navigates to \`ScoreCardView(analysis:)\`

**\`PolicyHistoryViewStyle\`**
- \`static func coiBadgeColor(_ coi: Double, differentiateWithoutColor: Bool) -> (Color, String)\` — returns color + icon name
- COI severity thresholds: \`coi ≥ 0.6\` → red/\"exclamationmark.triangle\", \`0.3..<0.6\` → orange/\"minus.circle\", \`< 0.3\` → green/\"checkmark.shield\"

---

## Step 5 — \`AnalysisViewModel\` + \`AnalysisView\` + \`AnalysisViewStyle\`

**Files:** \`ViewModels/AnalysisViewModel.swift\`, \`Views/AnalysisView.swift\`, \`Views/Style/AnalysisViewStyle.swift\`

**\`AnalysisViewModel: @Observable @MainActor\`**
- Properties: \`stage: String\`, \`coiValue: Double\`, \`partialScores: ScoreResult\`, \`clauseIndex: Int\`, \`totalClauses: Int\`, \`isComplete: Bool\`, \`error: Error?\`, \`finalAnalysis: PolicyAnalysis?\`, \`classifiedClauses: [TierClassification]\`
- \`func startAnalysis(pdfURL: URL, deps: AppDependencies, context: ModelContext)\` — calls \`deps.makeAnalysisPipeline()\`, iterates \`AsyncStream<AnalysisProgress>\`:
  - \`.extracting\` → \`stage = \"Extracting text…\"\`
  - \`.classifying(clauseIndex:total:partialScores:)\` → update \`stage\`, \`clauseIndex\`, \`totalClauses\`, \`coiValue\`, \`partialScores\`; append to \`classifiedClauses\`
  - \`.complete(scoreResult)\` → build \`PolicyAnalysis\` + \`[AnalyzedClause]\` (populating \`architectureScores\`, \`proxyTerms\`, \`expandsOutgroup\`, \`wasSafetyFallback\` from \`TierClassification\`), \`context.insert\`, set \`finalAnalysis\`, \`isComplete = true\`
  - \`.failed(error)\` → set \`error\`
- \`func cancel()\` — cancels the pipeline task

**\`AnalysisView\`**
- Receives \`pdfURL: URL\`
- Filename in nav bar title
- Tier availability banner (same as \`PolicyHistoryView\`)
- Stage label
- COI gauge: circular \`Canvas\` or \`ZStack\` with \`Circle\` stroke arcs; animates from 0 to \`viewModel.coiValue\`
- Clause counter + \`ProgressView(value: Double(clauseIndex) / Double(max(totalClauses, 1)))\`
- Sub-score rows (DIS, ADS, EIS, CIS, OES): show value if \`clauseIndex > 0\`, else \"—\"; label \"Preliminary\" until \`isComplete\`
- On \`isComplete\`: show \"View Full Results\" \`Button\` + auto-navigate after 1 second via \`Task { try await Task.sleep(for: .seconds(1)); navigate() }\`
- Error banner with \"Go Back\" button
- \`.onAppear { viewModel.startAnalysis(pdfURL:deps:context:) }\`
- \`@AccessibilityFocusState\` — move focus to COI gauge when \`isComplete\` becomes \`true\`

**\`AnalysisViewStyle\`**
- \`static func gaugeAnimation(reduceMotion: Bool) -> Animation?\` — \`nil\` when \`reduceMotion\`, else \`.spring(duration: 0.6)\`
- \`static func scoreColor(_ score: Double, differentiateWithoutColor: Bool) -> (Color, String)\`

---

## Step 6 — \`ScoreCardView\` + \`ScoreCardViewModel\` + \`ScoreCardViewStyle\`

**Files:** \`ViewModels/ScoreCardViewModel.swift\`, \`Views/ScoreCardView.swift\`, \`Views/Style/ScoreCardViewStyle.swift\`

**\`ScoreCardViewModel: @Observable @MainActor\`**
- \`analysis: PolicyAnalysis\`
- \`isShowingExport: Bool\`
- \`interpretation: String\` — computed from \`analysis.scoreResult.coi\` (e.g., \"Highly Oppressive\" ≥ 0.6, \"Moderately Oppressive\" 0.3–0.6, \"Low Oppression\" < 0.3, \"Liberatory\" < 0)

**\`ScoreCardView\`**
- Large COI gauge (same \`Canvas\`/\`ZStack\` arc as \`AnalysisView\` but static/final)
- Interpretation label below gauge
- 5 \`NavigationLink\` rows: DIS → \`BenefitHierarchyView\`, ADS → \`ArchitectureRadarView\`, EIS → \`EliteInterestDetailView\`, CIS → \`CompoundingTrajectoryView\`, OES → \`OutgroupExpansionView\`
- \"Historical Comparison\" \`NavigationLink\` → \`HistoricalComparisonView\`
- Toolbar: \"Export\" button → \`.sheet(isPresented: \$viewModel.isShowingExport) { ExportView(analysis:) }\`
- Accessibility: \`.accessibilityElement(children: .combine)\` on gauge block; \`.accessibilityLabel(\"Composite Oppression Index\")\`; \`.accessibilityValue(\"\\(coi, format: .number.precision(.fractionLength(2))), \\(interpretation)\")\`; \`.accessibilityCustomContent\` for each sub-score; \`speechAdjustedPitch\`; custom \"Scores\" rotor; \`.accessibilitySortPriority\` ordering

**\`ScoreCardViewStyle\`**
- \`static func scoreRevealAnimation(reduceMotion: Bool) -> Animation?\`
- \`static func scoreColor(_ score: Double, differentiateWithoutColor: Bool) -> (Color, String)\`
- \`static func backgroundMaterial(reduceTransparency: Bool) -> Material\`
- \`static func scoreFont(dynamicTypeSize: DynamicTypeSize, legibilityWeight: LegibilityWeight?) -> Font\`

---

## Step 7 — Chart Views

Each chart view has a corresponding ViewModel and Style struct. Create under \`Views/Charts/\` and \`ViewModels/Charts/\`.

### \`BenefitHierarchyView\`
- Swift Charts \`BarMark\` stacked by \`TargetGroup\` (Elite / InGroupNonElite / Outgroup)
- Data: aggregate benefit/burden counts from \`analysis.clauses\` grouped by \`targetGroup\` and \`effectDirection\`
- \`BenefitChartDescriptor: AXChartDescriptorRepresentable\` — \`AXCategoricalDataAxisDescriptor\` for groups, \`AXNumericDataAxisDescriptor\` for percentage
- Pattern fills (\`.foregroundStyle(by:)\` + custom \`ChartSymbolShape\`) when \`differentiateWithoutColor\`
- \`.accessibilityLabel(\"Benefit Hierarchy Chart\")\`; \`.accessibilityValue\` with plain-English summary

### \`ArchitectureRadarView\`
- \`Canvas\` spider chart with 4 axes: AAR, SE, IJ, RSC
- Data: mean of each component across \`analysis.clauses\` (using the new \`architectureScores\` property on \`AnalyzedClause\`)
- \`.accessibilityRepresentation { VStack { ForEach(components) { Text(\"\\(\$0.name): \\(\$0.score, format: .percent)\") } } }\`
- \`.accessibilityLabel(\"Architecture Detection Radar Chart\")\`; \`.accessibilityHeading(.h2)\`
- \`.accessibilityAdjustableAction\` to swipe through the 4 component scores
- Distinct line patterns (dashed/dotted/solid) per axis when \`differentiateWithoutColor\`

### \`CompoundingTrajectoryView\`
- Swift Charts \`LineMark\` — X axis: year, Y axis: out-group capacity (0–1)
- Data: \`HistoricalPolicies.chain\` mapped to \`(year, capacity)\` points where capacity = \`1 - cumulativeCompoundingEffect\`; append current policy as the final point
- \`CompoundingChartDescriptor: AXChartDescriptorRepresentable\` — implement \`makeChartDescriptor()\` per Phase 7 plan
- \`.accessibilityLabel(\"Compounding Impact Trajectory\")\`; \`.accessibilityHint\`

### \`HistoricalComparisonView\`
- Swift Charts \`BarMark\` or \`PointMark\` — X axis: policy name, Y axis: COI
- Data: \`HistoricalPolicies.chain\` + current \`analysis\` as the highlighted bar
- \`.accessibilityElement(children: .contain)\`; per-baseline \`.accessibilityLabel\` + \`.accessibilityValue\`; current policy \`.accessibilityAddTraits(.isSelected)\`
- Custom \"Historical Policies\" rotor

### \`OutgroupExpansionView\`
- Three metric rows: expansion rate, proxy usage rate, proxy density (computed from \`analysis.clauses\`)
- Proxy term list: aggregate unique \`proxyTerms\` from all \`AnalyzedClause\` instances
- \`.accessibilityLabel(\"Outgroup Expansion Score\")\`

---

## Step 8 — \`ReportExporter\`

**File:** \`Export/ReportExporter.swift\`

\`nonisolated struct ReportExporter\`

**\`exportJSON(analysis: PolicyAnalysis) throws -> Data\`**
- Define \`PolicyAnalysisExport: Codable\` with all \`PolicyAnalysis\` fields + \`tierUsageStats: TierUsageStats\` + \`safetyFallbackCount: Int\`
- \`TierUsageStats: Codable\` — \`tier1Count: Int\`, \`tier2Count: Int\`, \`tier3Count: Int\`
- Compute counts by iterating \`analysis.clauses\` on \`tierUsed\`; \`safetyFallbackCount\` = count of clauses where \`wasSafetyFallback == true\`
- Encode with \`JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys])\`

**\`exportPDF(analysis: PolicyAnalysis) throws -> Data\`**
- On iOS (\`#if canImport(UIKit)\`): \`UIGraphicsPDFRenderer\` — render policy name, date, COI gauge summary, sub-score table, tier-usage stats, clause breakdown table
- On macOS (\`#if os(macOS)\`): \`NSGraphicsPDFContext\` equivalent
- Return \`Data\`

---

## Step 9 — \`ExportView\` + \`ExportViewModel\` + \`ExportViewStyle\`

**Files:** \`ViewModels/ExportViewModel.swift\`, \`Views/ExportView.swift\`, \`Views/Style/ExportViewStyle.swift\`

**\`ExportViewModel: @Observable @MainActor\`**
- \`isGenerating: Bool\`, \`error: Error?\`, \`exportedItem: ExportedItem?\` (wraps \`URL\` + \`UTType\`)
- \`func export(analysis: PolicyAnalysis, format: ExportFormat)\` — calls \`ReportExporter\`, writes to a temp file, sets \`exportedItem\`
- \`enum ExportFormat { case pdf, json }\`

**\`ExportView\`**
- Presented as \`.sheet\` (iOS) / \`.popover\` (macOS)
- Two format buttons: \"PDF Report\" and \"JSON Data\"
- \`ProgressView\` while \`isGenerating\`
- On success: \`ShareLink(item: exportedItem.url)\` or \`UIActivityViewController\` via \`UIViewControllerRepresentable\`
- Error banner with \"Try Again\" button
- Accessibility: \`.accessibilityLabel\` on format buttons; \`.accessibilityHint\` describing output format

---

## Step 10 — Accessibility Layer (applied across all views)

This is not a separate file but a pass over all views created above. Key items not yet covered in individual steps:

- **Heading hierarchy**: add \`.accessibilityHeading(.h1)\` to \"Policy Analysis Results\" in \`ScoreCardView\`; \`.accessibilityHeading(.h2)\` to each section title
- **\"Scores\" custom rotor** on \`ScoreCardView\`: \`AccessibilityRotorEntry\` for COI, DIS, ADS, EIS, CIS, OES
- **\"Clauses\" custom rotor** on a \`ClauseListView\` (optional detail view accessible from \`ScoreCardView\`): \"Oppressive Clauses\" and \"Liberatory Clauses\" rotors filtering by score threshold
- **\`accessibilitySortPriority\`**: \`ScoreCardView\` = 5, \`ArchitectureRadarView\` = 4, \`CompoundingTrajectoryView\` = 3, \`BenefitHierarchyView\` = 2, \`HistoricalComparisonView\` = 1
- **\`accessibilityLinkedGroup\`**: link each sub-score label in \`ScoreCardView\` to its corresponding chart view using a shared \`@Namespace\`
- **\`accessibilityShowsLargeContentViewer()\`** on the COI score number in \`ScoreCardView\`
- **\`speechSpellsOutCharacters(false)\`** + \`speechAdjustedPitch\` on score \`Text\` views

---

## Step 11 — macOS Sidebar Layout

In \`ContentView.swift\`, within the \`#if os(macOS)\` block:

- \`NavigationSplitView(sidebar:detail:)\` — sidebar renders a \`List\` bound to \`@State var selectedSidebarItem: SidebarItem?\`
- \`SidebarItem\` enum: \`.analyze\`, \`.training\` (placeholder), \`.validation\` (placeholder), \`.data\` (placeholder)
- Analyze detail: \`NavigationSplitView\` with \`PolicyHistoryView\` in the content column and \`ScoreCardView\`/chart views in the detail column (driven by \`viewModel.selectedAnalysis\`)
- Drill-down charts open in the detail column instead of pushing a new screen — \`ScoreCardView\` uses \`@State var selectedDrillDown: DrillDown?\` and renders the chart in a detail panel
- Training/Validation/Data items show \`ContentUnavailableView(\"Coming in T8\", ...)\` placeholders

---

## File Structure Summary

\`\`\`
app/decodingOppression/decodingOppression/
├── Models/
│   └── AnalyzedClause.swift          ← extend with architectureScores, proxyTerms, expandsOutgroup, wasSafetyFallback
├── Views/
│   ├── WelcomeView.swift
│   ├── PolicyHistoryView.swift
│   ├── AnalysisView.swift
│   ├── ScoreCardView.swift
│   ├── ExportView.swift
│   ├── Charts/
│   │   ├── BenefitHierarchyView.swift
│   │   ├── ArchitectureRadarView.swift
│   │   ├── CompoundingTrajectoryView.swift
│   │   ├── HistoricalComparisonView.swift
│   │   └── OutgroupExpansionView.swift
│   └── Style/
│       ├── WelcomeViewStyle.swift
│       ├── PolicyHistoryViewStyle.swift
│       ├── AnalysisViewStyle.swift
│       ├── ScoreCardViewStyle.swift
│       ├── ExportViewStyle.swift
│       └── Charts/
│           ├── BenefitHierarchyViewStyle.swift
│           ├── ArchitectureRadarViewStyle.swift
│           ├── CompoundingTrajectoryViewStyle.swift
│           ├── HistoricalComparisonViewStyle.swift
│           └── OutgroupExpansionViewStyle.swift
├── ViewModels/
│   ├── WelcomeViewModel.swift
│   ├── PolicyHistoryViewModel.swift
│   ├── AnalysisViewModel.swift
│   ├── ScoreCardViewModel.swift
│   ├── ExportViewModel.swift
│   └── Charts/
│       ├── BenefitHierarchyViewModel.swift
│       ├── ArchitectureRadarViewModel.swift
│       ├── CompoundingTrajectoryViewModel.swift
│       ├── HistoricalComparisonViewModel.swift
│       └── OutgroupExpansionViewModel.swift
├── Export/
│   └── ReportExporter.swift
└── ContentView.swift                  ← replace placeholder
\`\`\`

---

## Flow Coverage

\`\`\`mermaid
sequenceDiagram
    participant App as decodingOppressionApp
    participant CV as ContentView
    participant WV as WelcomeView
    participant PHV as PolicyHistoryView
    participant AV as AnalysisView
    participant SCV as ScoreCardView
    participant Charts as Chart Views
    participant EV as ExportView

    App->>CV: launch
    CV->>WV: !hasCompletedOnboarding
    WV->>CV: getStarted() → hasCompletedOnboarding=true
    CV->>PHV: root view
    PHV->>AV: fileImporter → pdfURL
    AV->>AV: AnalysisViewModel.startAnalysis()
    AV->>SCV: isComplete → navigate
    SCV->>Charts: tap sub-score row
    Charts-->>SCV: back
    SCV->>EV: tap Export
    EV-->>SCV: ShareLink / UIActivityViewController
\`\`\`
=== END ORIGINAL TASK ===

=== REFERENCE CONTEXT ===

=== SWIFT DOCUMENTATION ===

--- FILE: Navigation.md ---
# Navigation

**Enable people to move between different parts of your app’s view hierarchy within a scene.**


## Overview

Use navigation containers to provide structure to your app’s user interface, enabling people to easily move among the parts of your app.

![Image](navigation-hero)

For example, people can move forward and backward through a stack of views using a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack), or choose which view to display from a tab bar using a [doc://com.apple.SwiftUI/documentation/SwiftUI/TabView](https://developer.apple.com/documentation/SwiftUI/TabView).

Configure navigation containers by adding view modifiers like [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationSplitViewStyle(_:)) to the container. Use other modifiers on the views inside the container to affect the container’s behavior when showing that view. For example, you can use [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationTitle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationTitle(_:)) on a view to provide a toolbar title to display when showing that view.

## Topics

### Essentials

- [Understanding the navigation stack](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack) — Learn about the navigation stack, links, and how to manage navigation types in your app’s structure.
### Presenting views in columns

- [Bringing robust navigation structure to your SwiftUI app](https://developer.apple.com/documentation/swiftui/bringing-robust-navigation-structure-to-your-swiftui-app) — Use navigation links, stacks, destinations, and paths to provide a streamlined experience for all platforms, as well as behaviors such as deep linking and state restoration.
- [Migrating to new navigation types](https://developer.apple.com/documentation/swiftui/migrating-to-new-navigation-types) — Improve navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.
- [NavigationSplitView](https://developer.apple.com/documentation/swiftui/navigationsplitview) — A view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.
- [navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewstyle(_:)) — Sets the style for navigation split views within this view.
- [navigationSplitViewColumnWidth(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(_:)) — Sets a fixed, preferred width for the column containing this view.
- [navigationSplitViewColumnWidth(min:ideal:max:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(min:ideal:max:)) — Sets a flexible, preferred width for the column containing this view.
- [NavigationSplitViewVisibility](https://developer.apple.com/documentation/swiftui/navigationsplitviewvisibility) — The visibility of the leading columns in a navigation split view.
- [NavigationLink](https://developer.apple.com/documentation/swiftui/navigationlink) — A view that controls a navigation presentation.
### Stacking views in one column

- [NavigationStack](https://developer.apple.com/documentation/swiftui/navigationstack) — A view that displays a root view and enables you to present additional views over the root view.
- [NavigationPath](https://developer.apple.com/documentation/swiftui/navigationpath) — A type-erased list of data representing the content of a navigation stack.
- [navigationDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(for:destination:)) — Associates a destination view with a presented data type for use within a navigation stack.
- [navigationDestination(isPresented:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(ispresented:destination:)) — Associates a destination view with a binding that can be used to push the view onto a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack).
- [navigationDestination(item:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(item:destination:)) — Associates a destination view with a bound value for use within a navigation stack or navigation split view
### Managing column collapse

- [NavigationSplitViewColumn](https://developer.apple.com/documentation/swiftui/navigationsplitviewcolumn) — A view that represents a column in a navigation split view.
### Setting titles for navigation content

- [navigationTitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)) — Configures the view’s title for purposes of navigation, using a string binding.
- [navigationSubtitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)) — Configures the view’s subtitle for purposes of navigation.
- [navigationDocument(_:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:)) — Configures the view’s document for purposes of navigation.
- [navigationDocument(_:preview:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)) — Configures the view’s document for purposes of navigation.
### Configuring the navigation bar

- [navigationBarBackButtonHidden(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbarbackbuttonhidden(_:)) — Hides the navigation bar back button for the view.
- [navigationBarTitleDisplayMode(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbartitledisplaymode(_:)) — Configures the title display mode for this view.
- [NavigationBarItem](https://developer.apple.com/documentation/swiftui/navigationbaritem) — A configuration for a navigation bar that represents a view at the top of a navigation stack.
### Configuring the sidebar

- [sidebarRowSize](https://developer.apple.com/documentation/swiftui/environmentvalues/sidebarrowsize) — The current size of sidebar rows.
- [SidebarRowSize](https://developer.apple.com/documentation/swiftui/sidebarrowsize) — The standard sizes of sidebar rows.
### Presenting views in tabs

- [Enhancing your app’s content with tab navigation](https://developer.apple.com/documentation/swiftui/enhancing-your-app-content-with-tab-navigation) — Keep your app content front and center while providing quick access to navigation using the tab bar.
- [TabView](https://developer.apple.com/documentation/swiftui/tabview) — A view that switches between multiple child views using interactive user interface elements.
- [Tab](https://developer.apple.com/documentation/swiftui/tab) — The content for a tab and the tab’s associated tab item in a tab view.
- [TabRole](https://developer.apple.com/documentation/swiftui/tabrole) — A value that defines the purpose of the tab.
- [TabSection](https://developer.apple.com/documentation/swiftui/tabsection) — A container that you can use to add hierarchy within a tab view.
- [tabViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewstyle(_:)) — Sets the style for the tab view within the current environment.
### Configuring a tab bar

- [tabViewSidebarHeader(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarheader(content:)) — Adds a custom header to the sidebar of a tab view.
- [tabViewSidebarFooter(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarfooter(content:)) — Adds a custom footer to the sidebar of a tab view.
- [tabViewSidebarBottomBar(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarbottombar(content:)) — Adds a custom bottom bar to the sidebar of a tab view.
- [AdaptableTabBarPlacement](https://developer.apple.com/documentation/swiftui/adaptabletabbarplacement) — A placement for tabs in a tab view using the adaptable sidebar style.
- [tabBarPlacement](https://developer.apple.com/documentation/swiftui/environmentvalues/tabbarplacement) — The current placement of the tab bar.
- [TabBarPlacement](https://developer.apple.com/documentation/swiftui/tabbarplacement) — A placement for tabs in a tab view.
- [isTabBarShowingSections](https://developer.apple.com/documentation/swiftui/environmentvalues/istabbarshowingsections) — A Boolean value that determines whether a tab view shows the expanded contents of a tab section.
- [TabBarMinimizeBehavior](https://developer.apple.com/documentation/swiftui/tabbarminimizebehavior)
- [TabViewBottomAccessoryPlacement](https://developer.apple.com/documentation/swiftui/tabviewbottomaccessoryplacement) — A placement of the bottom accessory in a tab view. You can use this to adjust the content of the accessory view based on the placement.
### Configuring a tab

- [sectionActions(content:)](https://developer.apple.com/documentation/swiftui/view/sectionactions(content:)) — Adds custom actions to a section.
- [TabPlacement](https://developer.apple.com/documentation/swiftui/tabplacement) — A place that a tab can appear.
- [TabContentBuilder](https://developer.apple.com/documentation/swiftui/tabcontentbuilder) — A result builder that constructs tabs for a tab view that supports programmatic selection. This builder requires that all tabs in the tab view have the same selection type.
- [TabContent](https://developer.apple.com/documentation/swiftui/tabcontent) — A type that provides content for programmatically selectable tabs in a tab view.
- [AnyTabContent](https://developer.apple.com/documentation/swiftui/anytabcontent) — Type erased tab content.
### Enabling tab customization

- [tabViewCustomization(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewcustomization(_:)) — Specifies the customizations to apply to the sidebar representation of the tab view.
- [TabViewCustomization](https://developer.apple.com/documentation/swiftui/tabviewcustomization) — The customizations a person makes to an adaptable sidebar tab view.
- [TabCustomizationBehavior](https://developer.apple.com/documentation/swiftui/tabcustomizationbehavior) — The customization behavior of customizable tab view content.
### Displaying views in multiple panes

- [HSplitView](https://developer.apple.com/documentation/swiftui/hsplitview) — A layout container that arranges its children in a horizontal line and allows the user to resize them using dividers placed between them.
- [VSplitView](https://developer.apple.com/documentation/swiftui/vsplitview) — A layout container that arranges its children in a vertical line and allows the user to resize them using dividers placed between them.
### Deprecated Types

- [NavigationView](https://developer.apple.com/documentation/swiftui/navigationview) — A view for presenting a stack of views that represents a visible path in a navigation hierarchy.
- [tabItem(_:)](https://developer.apple.com/documentation/swiftui/view/tabitem(_:)) — Sets the tab bar item associated with this view.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation)*
--- END FILE ---

--- FILE: Navigation.md ---
# Navigation

**Enable people to move between different parts of your app’s view hierarchy within a scene.**


## Overview

Use navigation containers to provide structure to your app’s user interface, enabling people to easily move among the parts of your app.

![Image](navigation-hero)

For example, people can move forward and backward through a stack of views using a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack), or choose which view to display from a tab bar using a [doc://com.apple.SwiftUI/documentation/SwiftUI/TabView](https://developer.apple.com/documentation/SwiftUI/TabView).

Configure navigation containers by adding view modifiers like [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationSplitViewStyle(_:)) to the container. Use other modifiers on the views inside the container to affect the container’s behavior when showing that view. For example, you can use [doc://com.apple.SwiftUI/documentation/SwiftUI/View/navigationTitle(_:)](https://developer.apple.com/documentation/SwiftUI/View/navigationTitle(_:)) on a view to provide a toolbar title to display when showing that view.

## Topics

### Essentials

- [Understanding the navigation stack](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack) — Learn about the navigation stack, links, and how to manage navigation types in your app’s structure.
### Presenting views in columns

- [Bringing robust navigation structure to your SwiftUI app](https://developer.apple.com/documentation/swiftui/bringing-robust-navigation-structure-to-your-swiftui-app) — Use navigation links, stacks, destinations, and paths to provide a streamlined experience for all platforms, as well as behaviors such as deep linking and state restoration.
- [Migrating to new navigation types](https://developer.apple.com/documentation/swiftui/migrating-to-new-navigation-types) — Improve navigation behavior in your app by replacing navigation views with navigation stacks and navigation split views.
- [NavigationSplitView](https://developer.apple.com/documentation/swiftui/navigationsplitview) — A view that presents views in two or three columns, where selections in leading columns control presentations in subsequent columns.
- [navigationSplitViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewstyle(_:)) — Sets the style for navigation split views within this view.
- [navigationSplitViewColumnWidth(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(_:)) — Sets a fixed, preferred width for the column containing this view.
- [navigationSplitViewColumnWidth(min:ideal:max:)](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth(min:ideal:max:)) — Sets a flexible, preferred width for the column containing this view.
- [NavigationSplitViewVisibility](https://developer.apple.com/documentation/swiftui/navigationsplitviewvisibility) — The visibility of the leading columns in a navigation split view.
- [NavigationLink](https://developer.apple.com/documentation/swiftui/navigationlink) — A view that controls a navigation presentation.
### Stacking views in one column

- [NavigationStack](https://developer.apple.com/documentation/swiftui/navigationstack) — A view that displays a root view and enables you to present additional views over the root view.
- [NavigationPath](https://developer.apple.com/documentation/swiftui/navigationpath) — A type-erased list of data representing the content of a navigation stack.
- [navigationDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(for:destination:)) — Associates a destination view with a presented data type for use within a navigation stack.
- [navigationDestination(isPresented:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(ispresented:destination:)) — Associates a destination view with a binding that can be used to push the view onto a [doc://com.apple.SwiftUI/documentation/SwiftUI/NavigationStack](https://developer.apple.com/documentation/SwiftUI/NavigationStack).
- [navigationDestination(item:destination:)](https://developer.apple.com/documentation/swiftui/view/navigationdestination(item:destination:)) — Associates a destination view with a bound value for use within a navigation stack or navigation split view
### Managing column collapse

- [NavigationSplitViewColumn](https://developer.apple.com/documentation/swiftui/navigationsplitviewcolumn) — A view that represents a column in a navigation split view.
### Setting titles for navigation content

- [navigationTitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationtitle(_:)) — Configures the view’s title for purposes of navigation, using a string binding.
- [navigationSubtitle(_:)](https://developer.apple.com/documentation/swiftui/view/navigationsubtitle(_:)) — Configures the view’s subtitle for purposes of navigation.
- [navigationDocument(_:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:)) — Configures the view’s document for purposes of navigation.
- [navigationDocument(_:preview:)](https://developer.apple.com/documentation/swiftui/view/navigationdocument(_:preview:)) — Configures the view’s document for purposes of navigation.
### Configuring the navigation bar

- [navigationBarBackButtonHidden(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbarbackbuttonhidden(_:)) — Hides the navigation bar back button for the view.
- [navigationBarTitleDisplayMode(_:)](https://developer.apple.com/documentation/swiftui/view/navigationbartitledisplaymode(_:)) — Configures the title display mode for this view.
- [NavigationBarItem](https://developer.apple.com/documentation/swiftui/navigationbaritem) — A configuration for a navigation bar that represents a view at the top of a navigation stack.
### Configuring the sidebar

- [sidebarRowSize](https://developer.apple.com/documentation/swiftui/environmentvalues/sidebarrowsize) — The current size of sidebar rows.
- [SidebarRowSize](https://developer.apple.com/documentation/swiftui/sidebarrowsize) — The standard sizes of sidebar rows.
### Presenting views in tabs

- [Enhancing your app’s content with tab navigation](https://developer.apple.com/documentation/swiftui/enhancing-your-app-content-with-tab-navigation) — Keep your app content front and center while providing quick access to navigation using the tab bar.
- [TabView](https://developer.apple.com/documentation/swiftui/tabview) — A view that switches between multiple child views using interactive user interface elements.
- [Tab](https://developer.apple.com/documentation/swiftui/tab) — The content for a tab and the tab’s associated tab item in a tab view.
- [TabRole](https://developer.apple.com/documentation/swiftui/tabrole) — A value that defines the purpose of the tab.
- [TabSection](https://developer.apple.com/documentation/swiftui/tabsection) — A container that you can use to add hierarchy within a tab view.
- [tabViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewstyle(_:)) — Sets the style for the tab view within the current environment.
### Configuring a tab bar

- [tabViewSidebarHeader(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarheader(content:)) — Adds a custom header to the sidebar of a tab view.
- [tabViewSidebarFooter(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarfooter(content:)) — Adds a custom footer to the sidebar of a tab view.
- [tabViewSidebarBottomBar(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewsidebarbottombar(content:)) — Adds a custom bottom bar to the sidebar of a tab view.
- [AdaptableTabBarPlacement](https://developer.apple.com/documentation/swiftui/adaptabletabbarplacement) — A placement for tabs in a tab view using the adaptable sidebar style.
- [tabBarPlacement](https://developer.apple.com/documentation/swiftui/environmentvalues/tabbarplacement) — The current placement of the tab bar.
- [TabBarPlacement](https://developer.apple.com/documentation/swiftui/tabbarplacement) — A placement for tabs in a tab view.
- [isTabBarShowingSections](https://developer.apple.com/documentation/swiftui/environmentvalues/istabbarshowingsections) — A Boolean value that determines whether a tab view shows the expanded contents of a tab section.
- [TabBarMinimizeBehavior](https://developer.apple.com/documentation/swiftui/tabbarminimizebehavior)
- [TabViewBottomAccessoryPlacement](https://developer.apple.com/documentation/swiftui/tabviewbottomaccessoryplacement) — A placement of the bottom accessory in a tab view. You can use this to adjust the content of the accessory view based on the placement.
### Configuring a tab

- [sectionActions(content:)](https://developer.apple.com/documentation/swiftui/view/sectionactions(content:)) — Adds custom actions to a section.
- [TabPlacement](https://developer.apple.com/documentation/swiftui/tabplacement) — A place that a tab can appear.
- [TabContentBuilder](https://developer.apple.com/documentation/swiftui/tabcontentbuilder) — A result builder that constructs tabs for a tab view that supports programmatic selection. This builder requires that all tabs in the tab view have the same selection type.
- [TabContent](https://developer.apple.com/documentation/swiftui/tabcontent) — A type that provides content for programmatically selectable tabs in a tab view.
- [AnyTabContent](https://developer.apple.com/documentation/swiftui/anytabcontent) — Type erased tab content.
### Enabling tab customization

- [tabViewCustomization(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewcustomization(_:)) — Specifies the customizations to apply to the sidebar representation of the tab view.
- [TabViewCustomization](https://developer.apple.com/documentation/swiftui/tabviewcustomization) — The customizations a person makes to an adaptable sidebar tab view.
- [TabCustomizationBehavior](https://developer.apple.com/documentation/swiftui/tabcustomizationbehavior) — The customization behavior of customizable tab view content.
### Displaying views in multiple panes

- [HSplitView](https://developer.apple.com/documentation/swiftui/hsplitview) — A layout container that arranges its children in a horizontal line and allows the user to resize them using dividers placed between them.
- [VSplitView](https://developer.apple.com/documentation/swiftui/vsplitview) — A layout container that arranges its children in a vertical line and allows the user to resize them using dividers placed between them.
### Deprecated Types

- [NavigationView](https://developer.apple.com/documentation/swiftui/navigationview) — A view for presenting a stack of views that represents a visible path in a navigation hierarchy.
- [tabItem(_:)](https://developer.apple.com/documentation/swiftui/view/tabitem(_:)) — Sets the tab bar item associated with this view.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Navigation)*
--- END FILE ---

--- FILE: Adopting-SwiftData-for-a-Core-Data-app.md ---
# Adopting SwiftData for a Core Data app

**Persist data in your app intuitively with the Swift native persistence framework.**

## Availability

- **iOS** 26.0+
- **iPadOS** 26.0+
- **macOS** 26.0+
- **Xcode** 26.0+


## Overview

This sample project is designed to help you understand how to adopt SwiftData in an existing Core Data app. The SampleTrips app fetches and displays all upcoming trips from the store, and allows people to create or remove trips, and to add, update, or remove information from the itinerary for each trip. There are three versions of this app:

- A Core Data version that demonstrates Core Data best practices.

- A SwiftData version that shows the complete app conversion from Core Data to SwiftData.

- A coexistence version, where the sample app uses Core Data, and adds a widget extension that uses SwiftData. This version covers a scenario where you might want to adopt SwiftData incrementally, or for certain portions of your app.


### Configure the sample code project

Open the sample code project in Xcode. Before building it, do the following:

1. Set the developer team for all targets to your team so Xcode automatically manages the provisioning profile. For more information, see [https://help.apple.com/xcode/mac/current/#/dev23aab79b4](https://help.apple.com/xcode/mac/current/#/dev23aab79b4).

2. Replace the App Group container identifier — `group.com.example.apple-samplecode.SampleTrips` — with one specific to your team for the entire project. The identifier points to an App Group container that the app and widget use to share data. You can search for `group.com.example.apple-samplecode.SampleTrips` using the Find navigator in Xcode, and then change all of the occurrences. For more information, see [doc://com.apple.documentation/documentation/Xcode/configuring-app-groups](https://developer.apple.com/documentation/Xcode/configuring-app-groups).


### Adopt SwiftData

The SwiftData sample sets up the schema with Swift types that conform to the [doc://com.apple.documentation/documentation/SwiftData/PersistentModel](https://developer.apple.com/documentation/SwiftData/PersistentModel) protocol, which captures information about the app’s types, including properties and relationships. Each model file corresponds to an individual entity, with identical entity names, properties, and relationships as its Core Data counterpart.

Each model file in this sample uses the [doc://com.apple.documentation/documentation/SwiftData/Model()](https://developer.apple.com/documentation/SwiftData/Model()) macro to add necessary conformances for the `PersistentModel` and [doc://com.apple.documentation/documentation/Observation/Observable](https://developer.apple.com/documentation/Observation/Observable) protocols:

```swift
@Model class Trip {
    #Index<Trip>([\.name], [\.startDate], [\.endDate], [\.name, \.startDate, \.endDate])
    #Unique<Trip>([\.name, \.startDate, \.endDate])
    
    @Attribute(.preserveValueOnDeletion)
    var name: String
    var destination: String
    
    @Attribute(.preserveValueOnDeletion)
    var startDate: Date
    
    @Attribute(.preserveValueOnDeletion)
    var endDate: Date

    @Relationship(deleteRule: .cascade, inverse: \BucketListItem.trip)
    var bucketList: [BucketListItem] = [BucketListItem]()
    
    @Relationship(deleteRule: .cascade, inverse: \LivingAccommodation.trip)
    var livingAccommodation: LivingAccommodation?
    ...
```

Additionally, the app sets up the container using [doc://com.apple.documentation/documentation/SwiftData/ModelContainer](https://developer.apple.com/documentation/SwiftData/ModelContainer) to ensure that all views access the same `ModelContainer`.

```swift
.modelContainer(modelContainer)
```

Setting up the `ModelContainer` also creates and sets a default [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) in the environment. The app can access the `ModelContext` from any scene or view using an environment property.

```swift
@Environment(\.modelContext) private var modelContext
```


### Create a persisted data object

This app creates a new instance of a trip and inserts it into the [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) for persistence:

```swift
if newTripSegment == .personal {
    newTrip = PersonalTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, reason: reason)
} else if newTripSegment == .business {
    newTrip = BusinessTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, perdiem: perdiem)
} else {
    newTrip = Trip(name: name, destination: destination, startDate: startDate, endDate: endDate)
}
modelContext.insert(newTrip)
```


### Persist data

The app uses the SwiftData implicit save feature to persist data. This implicit save occurs on UI life cycle events and on a timer after the context changes. For more information about enabling autosave, see the [doc://com.apple.documentation/documentation/SwiftData/ModelContext/autosaveEnabled](https://developer.apple.com/documentation/SwiftData/ModelContext/autosaveEnabled) property.

The app calls [doc://com.apple.documentation/documentation/SwiftData/ModelContext/delete(_:)](https://developer.apple.com/documentation/SwiftData/ModelContext/delete(_:)) on the [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) with the instance to delete.

```swift
modelContext.delete(trip)
```


### Fetch persisted data

This sample app fetches the complete list of upcoming trips by wrapping an array of trips in a [doc://com.apple.documentation/documentation/SwiftData/Query](https://developer.apple.com/documentation/SwiftData/Query) macro, which fetches `Trip` objects from the container.

```swift
@Query(sort: \Trip.startDate, order: .forward)
var trips: [Trip]
```

This sample also fetches data by calling [doc://com.apple.documentation/documentation/SwiftData/ModelContext/fetch(_:)](https://developer.apple.com/documentation/SwiftData/ModelContext/fetch(_:)) on the [doc://com.apple.documentation/documentation/SwiftData/ModelContext](https://developer.apple.com/documentation/SwiftData/ModelContext) and passing in a [doc://com.apple.documentation/documentation/SwiftData/FetchDescriptor](https://developer.apple.com/documentation/SwiftData/FetchDescriptor) that specifies both the entity to retrieve data from as well as a corresponding [doc://com.apple.documentation/documentation/Foundation/Predicate](https://developer.apple.com/documentation/Foundation/Predicate) that specifies the conditions for the object to fetch.

```swift
var descriptor = FetchDescriptor<BucketListItem>()
let tripName = trip.name
descriptor.predicate = #Predicate { item in
    item.title.contains(searchText) && tripName == item.trip?.name
}
let filteredList = try? modelContext.fetch(descriptor)
```


### Inheritance

The SwiftData-Inheritance version of the app extends the `Trip` class into two distinct kinds of Trips, `PersonalTrip` and `BusinessTrip`, building on the basic `Trip` model to include more specialized properties for different kinds of Trips.

```swift
class PersonalTrip: Trip {...}
```

Both `PersonalTrip` and `BusinessTrip` inherit basic properties from their superclass, `Trip`, while defining their own specialized properties, as shown in the following code. For instance, `PersonalTrip`, has an additional property that describes the reason for the trip.

```swift
init(name: String, destination: String, startDate: Date = .now, endDate: Date = .distantFuture, reason: Reason) {
    self.reason = reason
    super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)
}
```


### Coexistence between Core Data and SwiftData

The coexistence version of the app has two persistence stacks: a Core Data persistence stack for the host app, and a SwiftData persistence stack for the widget extension. Both stacks write to the same store file.


### Namespace models

The namespaces in the coexistence sample use the pre-existing [doc://com.apple.documentation/documentation/CoreData/NSManagedObject](https://developer.apple.com/documentation/CoreData/NSManagedObject)-based entity subclasses so that they don’t conflict with the SwiftData classes. Note that this refers to the class name, not the entity name.

```swift
class CDTrip: NSManagedObject {...}
```

The sample then refers to the entity as `CDTrip` when accessing it in the Core Data host app. For instance, when adding a new `Trip`:

```swift
let newTrip = CDTrip(context: viewContext)
```


### Share the same store file

This sample ensures that both the Core Data and SwiftData persistent stacks write to the same store file by setting the persistent store URL for the container description:

```swift
if let description = container.persistentStoreDescriptions.first {
    description.url = url
    ...
}
```

Additionally, the coexistence sample must set the [doc://com.apple.documentation/documentation/CoreData/NSPersistentHistoryTrackingKey](https://developer.apple.com/documentation/CoreData/NSPersistentHistoryTrackingKey). Although SwiftData enables persistent history tracking automatically, Core Data does not, so the app enables persistent history manually.

```swift
description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
```

By default, SwiftData behaves in the following way when determining where it persists data:

- It persists data store to the app’s Application Support directory.

- This sample app uses App Groups to access shared containers and share data between the SwiftData widget extension and the Core Data host app. For an app that has the [doc://com.apple.documentation/documentation/BundleResources/Entitlements/com.apple.security.application-groups](https://developer.apple.com/documentation/BundleResources/Entitlements/com.apple.security.application-groups), it persists the data store to the root directory of the app group container. For apps that evolve from a version that doesn’t have any app group container to a version that has one, SwiftData copies the existing store to the app group container.

In this sample, the main app and widget share the same store via an app group container, and the store is located in the default location in the app group container. To ensure SwiftData accesses the same store, the main app and widget both share the [doc://com.apple.documentation/documentation/SwiftData/ModelContainer](https://developer.apple.com/documentation/SwiftData/ModelContainer).


### Detect relevant changes by consuming the SwiftData history

In the SwiftData version, people can confirm the living accommodation for the current trip by tapping the Accommodation button in the widget. The widget then updates `LivingAccommodation.isConfirmed` in SwiftData, and the main app, when entering the foreground, detects the changes and annotates the trip with a blue dot to indicate that it has unread changes.

There are multiple options for the main app to detect the changes from the widget:

1. Adding a key value pair to the shared `UserDefaults` ([doc://com.apple.documentation/documentation/Foundation/UserDefaults/init(suiteName:)](https://developer.apple.com/documentation/Foundation/UserDefaults/init(suiteName:)) for the widget and the main app to share the changes.

2. Adding a new attribute in `Trip` so the widget can mark the trip as “unread” when changing the living accommodation status.

3. Consuming the history of the store, which SwiftData generates by default, and picking up the relevant changes from there.

The first option introduces a new storage, and hence needs to maintain the consistency between SwiftData and the shared `UserDefaults`. The second option is easier to implement, but introduces and maintains a new attribute, which is redundant and consumes extra storage space; for real-world apps that manage more complicated changes and have larger data set, that may not be the favorite approach.

This sample chooses to detect the changes with the third option. To do so, it sets up a `HistoryDescriptor<DefaultHistoryTransaction>` with a history token (`DefaultHistoryToken`) and calls `fetchHistory(_:)` to retrieve the history transactions (`DefaultHistoryTransaction`) after the token, as shown in the following code:

```swift
private func findTransactions(after historyToken: DefaultHistoryToken?, author: String) -> [DefaultHistoryTransaction] {...}
```

After getting the transactions, it uses the following code to find the trips that have living accommodation changes:

```swift
private func findTrips(in transactions: [DefaultHistoryTransaction]) -> (Set<Trip>, DefaultHistoryToken?) {...}
```

---

*Source: [https://developer.apple.com/documentation/com.apple.coredata/documentation/CoreData/adopting-swiftdata-for-a-core-data-app](https://developer.apple.com/documentation/com.apple.coredata/documentation/CoreData/adopting-swiftdata-for-a-core-data-app)*
--- END FILE ---

--- FILE: SwiftData-Class-Inheritance.md ---
# Adopting Class Inheritance in Swift Data

## Overview

Swift Data supports class inheritance, allowing you to create hierarchical relationships between your model classes. This powerful feature enables you to build more flexible and specialized data models by creating subclasses that inherit properties and capabilities from a base class. Class inheritance in Swift Data follows the same principles as standard Swift inheritance but with additional considerations for persistence and querying.

Key concepts include:
- Base classes that define common properties and behaviors
- Specialized subclasses that extend functionality for specific use cases
- Type-based querying that can filter by specific model types
- Polymorphic relationships that work with different model types

## When to Use Inheritance in Swift Data

### Good Use Cases

- When you have a clear "IS-A" relationship between models (e.g., a `BusinessTrip` IS-A `Trip`)
- When models share fundamental properties but diverge as use cases become more specialized
- When your app needs to perform both deep searches (across all properties) and shallow searches (specific to subclass properties)
- When your data model naturally forms a hierarchical structure

```swift
// Example of a good inheritance relationship
@Model class Vehicle {
    var manufacturer: String
    var model: String
    var year: Int
}

@Model class Car: Vehicle {
    var numberOfDoors: Int
    var fuelType: FuelType
}

@Model class Motorcycle: Vehicle {
    var engineDisplacement: Int
    var hasABS: Bool
}
```

### When to Avoid Inheritance

- When specialized subclasses would only share a few common properties
- When your query strategy only focuses on specialized properties (shallow queries)
- When a Boolean flag or enumeration could represent the type distinction more efficiently
- When protocol conformance would be more appropriate for shared behavior

```swift
// Alternative to inheritance using an enum approach
@Model class Vehicle {
    var manufacturer: String
    var model: String
    var year: Int
    
    enum VehicleType: String, Codable {
        case car(numberOfDoors: Int, fuelType: FuelType)
        case motorcycle(engineDisplacement: Int, hasABS: Bool)
    }
    
    var type: VehicleType
}
```

## Designing Class Hierarchies

### Base Class Design

1. Identify common properties that all subclasses will share
2. Define relationships that apply to all subclasses
3. Use the `@Model` macro on the base class
4. Ensure the base class is declared as a `class` (not a struct)

```swift
import SwiftData

@Model class Trip {
    @Attribute(.preserveValueOnDeletion)
    var name: String
    var destination: String
    
    @Attribute(.preserveValueOnDeletion)
    var startDate: Date
    
    @Attribute(.preserveValueOnDeletion)
    var endDate: Date

    @Relationship(deleteRule: .cascade, inverse: \Accommodation.trip)
    var accommodation: Accommodation?
    
    init(name: String, destination: String, startDate: Date, endDate: Date) {
        self.name = name
        self.destination = destination
        self.startDate = startDate
        self.endDate = endDate
    }
}
```

### Subclass Design

1. Inherit from the base class using standard Swift inheritance syntax
2. Add the `@Model` macro to the subclass
3. Add specialized properties and relationships specific to the subclass
4. Override methods as needed
5. Consider availability annotations if needed

```swift
@Model class BusinessTrip: Trip {
    var purpose: String
    var expenseCode: String
    var perDiemRate: Double
    
    @Relationship(deleteRule: .cascade, inverse: \BusinessMeal.trip)
    var businessMeals: [BusinessMeal] = []
    
    @Relationship(deleteRule: .cascade, inverse: \MileageRecord.trip)
    var mileageRecords: [MileageRecord] = []
    
    init(name: String, destination: String, startDate: Date, endDate: Date,
         purpose: String, expenseCode: String, perDiemRate: Double) {
        self.purpose = purpose
        self.expenseCode = expenseCode
        self.perDiemRate = perDiemRate
        super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)
    }
}
```

```swift
@Model class PersonalTrip: Trip {
    enum Reason: String, CaseIterable, Codable, Identifiable {
        case family, vacation, wellness, other
        var id: Self { self }
    }
    
    var reason: Reason
    var notes: String?
    
    @Relationship(deleteRule: .cascade, inverse: \Attraction.trip)
    var attractions: [Attraction] = []
    
    init(name: String, destination: String, startDate: Date, endDate: Date,
         reason: Reason, notes: String? = nil) {
        self.reason = reason
        self.notes = notes
        super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)
    }
}
```

## Querying with Inheritance

### Basic Queries

You can query for all instances of a base class, which will include all subclass instances:

```swift
// Query for all trips (including BusinessTrip and PersonalTrip)
@Query(sort: \Trip.startDate)
var allTrips: [Trip]
```

### Type-Based Filtering

Filter by specific subclass types using the `is` operator in predicates:

```swift
// Query for only BusinessTrip instances
let businessTripPredicate = #Predicate<Trip> { $0 is BusinessTrip }
@Query(filter: businessTripPredicate)
var businessTrips: [Trip]
```

### Combined Filtering

Combine type filtering with property filtering:

```swift
// Query for PersonalTrip instances with a specific reason
let personalVacationPredicate = #Predicate<Trip> {
    if let personalTrip = $0 as? PersonalTrip {
        return personalTrip.reason == .vacation
    }
    return false
}

@Query(filter: personalVacationPredicate)
var vacationTrips: [Trip]
```

### Using Enums for Filtering

Create an enum to simplify filtering by type:

```swift
enum TripKind: String, CaseIterable {
    case all = "All"
    case personal = "Personal"
    case business = "Business"
}

struct TripListView: View {
    @Query var trips: [Trip]
    
    init(tripKind: TripKind, searchText: String = "") {
        // Create type predicate based on selected kind
        let typePredicate: Predicate<Trip>? = {
            switch tripKind {
            case .all:
                return nil
            case .personal:
                return #Predicate { $0 is PersonalTrip }
            case .business:
                return #Predicate { $0 is BusinessTrip }
            }
        }()
        
        // Create search predicate if needed
        let searchPredicate = searchText.isEmpty ? nil : #Predicate<Trip> {
            $0.name.localizedStandardContains(searchText) || 
            $0.destination.localizedStandardContains(searchText)
        }
        
        // Combine predicates if both exist
        let finalPredicate: Predicate<Trip>?
        if let typePredicate, let searchPredicate {
            finalPredicate = #Predicate { typePredicate.evaluate($0) && searchPredicate.evaluate($0) }
        } else {
            finalPredicate = typePredicate ?? searchPredicate
        }
        
        _trips = Query(filter: finalPredicate, sort: \.startDate)
    }
}
```

## Working with Subclass Properties

### Type Casting

When working with a collection of base class instances, you'll need to cast to access subclass-specific properties:

```swift
func calculateTotalExpenses(for trips: [Trip]) -> Double {
    var total = 0.0
    
    for trip in trips {
        if let businessTrip = trip as? BusinessTrip {
            // Access BusinessTrip-specific properties
            let perDiemTotal = businessTrip.perDiemRate * Double(Calendar.current.dateComponents([.day], from: businessTrip.startDate, to: businessTrip.endDate).day ?? 0)
            
            // Add meal expenses
            let mealExpenses = businessTrip.businessMeals.reduce(0.0) { $0 + $1.cost }
            
            total += perDiemTotal + mealExpenses
        }
    }
    
    return total
}
```

### Polymorphic Relationships

You can create relationships that work with the base class but contain instances of different subclasses:

```swift
@Model class TravelPlanner {
    var name: String
    
    @Relationship(deleteRule: .cascade)
    var upcomingTrips: [Trip] = []  // Can contain both BusinessTrip and PersonalTrip instances
    
    func addTrip(_ trip: Trip) {
        upcomingTrips.append(trip)
    }
}
```

## Best Practices

1. **Keep inheritance hierarchies shallow**: Avoid deep inheritance chains that can become difficult to maintain.

2. **Use meaningful IS-A relationships**: Only use inheritance when there's a true "is-a" relationship between models.

3. **Consider alternatives**: For simpler cases, enums or Boolean flags might be more appropriate than inheritance.

4. **Design for query patterns**: Consider how you'll query your data when designing your class hierarchy.

5. **Be mindful of schema migrations**: Changes to your inheritance hierarchy may require more complex migrations.

6. **Document the inheritance structure**: Make sure other developers understand the relationships between your models.

7. **Test with real data**: Verify that your inheritance structure works well with realistic data and query patterns.

## References

- [Adopting inheritance in SwiftData](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData)
- [Design for specialization](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData#Design-for-specialization)
- [Determine whether inheritance is right for your use case](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData#Determine-whether-inheritance-is-right-for-your-use-case)
- [Fetch and Query Data](https://developer.apple.com/documentation/SwiftData/Adopting-inheritance-in-SwiftData#Fetch-and-Query-Data)
--- END FILE ---

--- FILE: charting-data.md ---
---
title: Charting data | Apple Developer Documentation
source_url: https://developer.apple.com/design/human-interface-guidelines/charting-data
scraped_date: '2025-10-25T18:04:03.312840Z'
extraction_method: Chrome DevTools MCP Server
content_length: 6930
filename: charting-data.md
---

# Charting data | Apple Developer Documentation

Charting data
Presenting data in a chart can help you communicate information with clarity and appeal.

Charts provide efficient ways to communicate complex information without requiring people to read and interpret a lot of text. The graphical nature of charts also gives you additional opportunities to express the personality of your experience and add visual interest to your interface. To learn about the components you use to create a chart, see Charts.

A chart can range from a simple graphic that provides glanceable information to a rich, interactive experience that can form the centerpiece of your app and encourage people to explore the data from various perspectives. Whether simple or complex, you can use charts to help people perform data-driven tasks that are important to them, such as:

Analyzing trends based on historical or predicted values

Visualizing the current state of a process, system, or quantity that changes over time

Evaluating different items — or the same item at different times — by comparing data across multiple categories

Not every collection of data needs to be displayed in a chart. If you simply need to provide data — and you don't need to convey information about it or help people analyze it — consider offering the data in other ways, such as in a list or table that people can scroll, search, and sort.

Best practices

Use a chart when you want to highlight important information about a dataset. Charts are visually prominent, so they tend to draw people's attention. Take advantage of this prominence by clearly communicating what people can learn from the data they care about.

Keep a chart simple, letting people choose when they want additional details. Resist the temptation to pack as much data as possible into a chart. Too much data can make a chart visually overwhelming and difficult to use, obscuring the relationships and other information you want to convey. If you have a lot of data to present — or a lot of functionality to provide — consider giving people a way to reveal it gradually. For example, you might let people choose to view different levels of detail or subsets of data to match their interest. To help people learn how to use an interactive chart, you might offer several versions of the chart, each with more functionality than the last.

Make every chart in your app accessible. A chart communicates visually through graphical representations of data and visual descriptions. In addition to the visual descriptions you display, it's crucial to provide both accessibility labels that describe chart values and components, and accessibility elements that help people interact with the chart. For guidance, see Enhancing the accessibility of a chart.

Designing effective charts

In general, prefer using common chart types. People tend to be familiar with common chart types — such as bar charts and line charts — so using one of these types in your app can make it more likely that people will already know how to read your chart. For guidance, see Charts.

If you need to create a chart that presents data in a novel way, help people learn how to interpret the chart. For example, when a Watch pairs with iPhone, Activity introduces the Activity rings by animating them individually, showing people how each ring maps to the move, exercise, and stand metrics.

Examine the data from multiple levels or perspectives to find details you can display to enhance the chart. For example, viewing the data from a macro level can help you determine high-level summaries that people might be interested in, like totals or averages. From a mid-level perspective, you might find ways to help people identify useful subsets of the data, whereas examining individual data points might help you find ways to draw people's attention to specific values or items. Displaying information that helps people view the chart from various perspectives can encourage them to engage with it.

Aid comprehension by adding descriptive text to the chart. Descriptive text titles, subtitles, and annotations help emphasize the most important information in a chart and can highlight actionable takeaways. You can also display brief descriptive text that serves as a headline or summary for a chart, helping people grasp essential information at a glance. For example, Weather displays text that summarizes the information people need right now — such as "Chance of light rain in the next hour" — above the scrolling list of hourly forecasts for the next 24 hours. Although a descriptive headline or summary can make a chart more accessible, it doesn't take the place of accessibility labels.

Match the size of a chart to its functionality, topic, and level of detail. In general, a chart needs to be large enough to comfortably display the details you need to include and expansive enough for the interactivity you want to support. For example, you always want to make it easy for people to read a chart's details and descriptive text — like labels and annotations — but you might also want to give people enough room to change the scope of a chart or investigate the data from different perspectives. On the other hand, you might want to use a small chart to offer glanceable information about an individual item or to provide a snapshot or preview of a larger version of the chart that people can reveal in a different view.

Prefer consistency across multiple charts, deviating only when you need to highlight differences. If multiple charts in your app serve a similar purpose, you generally don't want to imply that the charts are unrelated by using a different type or style for each one. Also, using a consistent visual approach for the charts in your app lets people use what they learn about one chart to help them understand another. Consider using different chart types and styles when you need to highlight meaningful differences between charts.

Maintain continuity among multiple charts that use the same data. When you use multiple charts to help people explore one dataset from different perspectives, it's important to use one chart type and consistent colors, annotations, layouts, and descriptive text to signal that the dataset remains the same. For example, the Health Trends screen shows small charts that each use a specific visual style to depict a recent trend in an area like steps or resting heart rate. When people choose a chart to reveal all their data in that area, the expanded version uses the same style, colors, marks, and annotations to strengthen the relationship between the versions.

Platform considerations

No additional considerations for iOS, iPadOS, macOS, tvOS, visionOS, or watchOS.

Resources
Related

Charts

Developer documentation

Swift Charts

Videos
Bring Swift Charts to the third dimension
Design app experiences with charts
Design an effective chart
Change log

Date

	

Changes




September 23, 2022

	

New page.
--- END FILE ---

--- FILE: Swift-Charts-3D-Visualization.md ---
# Using 3D Charts with Swift Charts

## Overview

Swift Charts provides powerful 3D visualization capabilities through the `Chart3D` component, allowing developers to create immersive three-dimensional data visualizations. This guide covers how to create, customize, and interact with 3D charts in SwiftUI applications using the Swift Charts framework.

Key components for 3D charts include:
- `Chart3D`: The main container view for 3D chart content
- `SurfacePlot`: For visualizing 3D surface data
- `Chart3DPose`: For controlling the viewing angle and perspective
- `Chart3DSurfaceStyle`: For styling the appearance of 3D surfaces

## Basic Setup

### Importing Required Frameworks

```swift
import SwiftUI
import Charts
```

### Creating a Simple 3D Chart

The most basic 3D chart can be created using a mathematical function that maps x,y coordinates to z values:

```swift
struct Basic3DChartView: View {
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    // Simple mathematical function: z = sin(x) * cos(y)
                    sin(x) * cos(y)
                }
            )
        }
    }
}
```

### Creating a 3D Chart from Data

You can also create 3D charts from collections of data:

```swift
struct DataPoint3D: Identifiable {
    var x: Double
    var y: Double
    var z: Double
    var id = UUID()
}

struct Data3DChartView: View {
    let dataPoints: [DataPoint3D] = [
        // Your 3D data points
    ]
    
    var body: some View {
        Chart3D(dataPoints) { point in
            // Create appropriate 3D visualization for each point
        }
    }
}
```

## Customizing 3D Charts

### Setting the Chart Pose (Viewing Angle)

Control the viewing angle of your 3D chart using `Chart3DPose`:

```swift
struct CustomPose3DChartView: View {
    // Create a state variable to store the pose
    @State private var chartPose: Chart3DPose = .default
    
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    sin(x) * cos(y)
                }
            )
        }
        // Apply the pose to the chart
        .chart3DPose(chartPose)
    }
}
```

You can use predefined poses:
- `.default`: The default viewing angle
- `.front`: View from the front
- `.back`: View from the back
- `.top`: View from the top
- `.bottom`: View from the bottom
- `.right`: View from the right side
- `.left`: View from the left side

Or create a custom pose with specific azimuth and inclination angles:

```swift
Chart3DPose(azimuth: .degrees(45), inclination: .degrees(30))
```

### Interactive Pose Control

Allow users to interact with the chart by binding the pose to a state variable:

```swift
struct Interactive3DChartView: View {
    @State private var chartPose: Chart3DPose = .default
    
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    sin(x) * cos(y)
                }
            )
        }
        // Bind the pose to enable interactive rotation
        .chart3DPose($chartPose)
    }
}
```

### Setting the Camera Projection

Control the camera projection of the points in a 3D chart using `Chart3DCameraProjection`:

```swift
struct CustomProjection3DChartView: View {
    // Create a state variable to store the pose
    @State private var cameraProjection: Chart3DCameraProjection = .perspective
    
    var body: some View {
        Chart3D {
            SurfacePlot(
                x: "X Axis",
                y: "Y Axis",
                z: "Z Axis",
                function: { x, y in
                    sin(x) * cos(y)
                }
            )
        }
        // Apply the camera projection to the chart
        .chart3DCameraProjection(cameraProjection)
    }
}
```

You can use the following camera projection styles:
- `.automatic`: Automatically determines the camera projection
- `.orthographic`: Objects maintain size regardless of depth
- `.perspective`: Objects appear smaller with distance

## Working with Surface Plots

### Basic Surface Plot

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        // Mathematical function defining the surface
        sin(sqrt(x*x + y*y))
    }
)
```

### Styling Surface Plots

Apply different styles to your surface plots:

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(Color.blue)
```

Available surface styles:
- `.heightBased`: Colors the surface based on the height (y-value)
- `.normalBased`: Colors the surface based on the surface normal direction

### Custom Gradient Surface Style

Create a custom gradient for your surface:

```swift
let customGradient = Gradient(colors: [.blue, .purple, .red])

SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(LinearGradient(gradient: customGradient, startPoint: .topLeading, endPoint: .bottomTrailing))
```

### Controlling Surface Roughness

Adjust the roughness of the surface:

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.roughness(0.3) // 0 is smooth, 1 is completely rough
```

## Advanced Techniques

### Combining Multiple Surface Plots

```swift
Chart3D {
    // First surface plot
    SurfacePlot(
        x: "X",
        y: "Y",
        z: "Z",
        function: { x, y in
            sin(x) * cos(y)
        }
    )
    
    // Second surface plot
    SurfacePlot(
        x: "X",
        y: "Y",
        z: "Z",
        function: { x, y in
            cos(x) * sin(y) + 2 // Offset to avoid overlap
        }
    )
}
```

### Specifying Y-Range for Height-Based Styling

Control the color mapping by specifying the y-range:

```swift
SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(Chart3DSurfaceStyle.heightBased(yRange: -1.0...1.0))
```

### Custom Gradient with Y-Range

```swift
let customGradient = Gradient(colors: [.blue, .green, .yellow, .red])

SurfacePlot(
    x: "X Axis",
    y: "Y Axis",
    z: "Z Axis",
    function: { x, y in
        sin(x) * cos(y)
    }
)
.foregroundStyle(Chart3DSurfaceStyle.heightBased(customGradient, yRange: -1.0...1.0))
```

## Complete Example: Interactive 3D Visualization

Here's a complete example that demonstrates an interactive 3D chart with customized styling:

```swift
import SwiftUI
import Charts

struct Interactive3DSurfaceView: View {
    // State for interactive rotation
    @State private var chartPose: Chart3DPose = .default
    
    // Custom gradient for surface coloring
    let surfaceGradient = Gradient(colors: [
        .blue,
        .cyan,
        .green,
        .yellow,
        .orange,
        .red
    ])
    
    var body: some View {
        VStack {
            Text("Interactive 3D Surface Visualization")
                .font(.headline)
            
            Chart3D {
                SurfacePlot(
                    x: "X Value",
                    y: "Y Value",
                    z: "Result",
                    function: { x, y in
                        // Interesting mathematical function
                        sin(sqrt(x*x + y*y)) / sqrt(x*x + y*y + 0.1)
                    }
                )
                .roughness(0.2)
            }
            .chart3DPose($chartPose)
            .frame(height: 400)
            
            Text("Drag to rotate the visualization")
                .font(.caption)
                .foregroundColor(.secondary)
            
            HStack {
                Button("Front View") {
                    withAnimation {
                        chartPose = .front
                    }
                }
                
                Button("Top View") {
                    withAnimation {
                        chartPose = .top
                    }
                }
                
                Button("Default View") {
                    withAnimation {
                        chartPose = .default
                    }
                }
            }
            .buttonStyle(.bordered)
        }
        .padding()
    }
}
```

## References

- [Apple Developer Documentation: Chart3D](https://developer.apple.com/documentation/Charts/Chart3D)
- [Apple Developer Documentation: SurfacePlot](https://developer.apple.com/documentation/Charts/SurfacePlot)
- [Apple Developer Documentation: Chart3DPose](https://developer.apple.com/documentation/Charts/Chart3DPose)
- [Apple Developer Documentation: Chart3DSurfaceStyle](https://developer.apple.com/documentation/Charts/Chart3DSurfaceStyle)
- [Apple Developer Documentation: Creating a chart using Swift Charts](https://developer.apple.com/documentation/Charts/Creating-a-chart-using-Swift-Charts)
--- END FILE ---

--- FILE: Accessibility-fundamentals.md ---
# Accessibility fundamentals

**Make your SwiftUI apps accessible to everyone, including people with disabilities.**


## Overview

Like all Apple UI frameworks, SwiftUI comes with built-in accessibility support. The framework introspects common elements like navigation views, lists, text fields, sliders, buttons, and so on, and provides basic accessibility labels and values by default. You don’t have to do any extra work to enable these standard accessibility features.

![Image](accessibility-fundamentals-hero)

SwiftUI also provides tools to help you enhance the accessibility of your app. To find out what enhancements you need, try using your app with accessibility features like VoiceOver, Voice Control, and Switch Control, or get feedback from users of your app that regularly use these features. Then use the accessibility view modifiers that SwiftUI provides to improve the experience. For example, you can explicitly add accessibility labels to elements in your UI using the [doc://com.apple.SwiftUI/documentation/SwiftUI/View/accessibilityLabel(_:)](https://developer.apple.com/documentation/SwiftUI/View/accessibilityLabel(_:)) or the [doc://com.apple.SwiftUI/documentation/SwiftUI/View/accessibilityValue(_:)](https://developer.apple.com/documentation/SwiftUI/View/accessibilityValue(_:)) view modifier.

Customize your use of accessibility modifiers for all the platforms that your app runs on. For example, you may need to adjust the accessibility elements for a companion Apple Watch app that shares a common code base with an iOS app. If you integrate AppKit or UIKit controls in SwiftUI, expose any accessibility labels and make them accessible from your [doc://com.apple.SwiftUI/documentation/SwiftUI/NSViewRepresentable](https://developer.apple.com/documentation/SwiftUI/NSViewRepresentable) or [doc://com.apple.SwiftUI/documentation/SwiftUI/UIViewRepresentable](https://developer.apple.com/documentation/SwiftUI/UIViewRepresentable) views, or provide custom accessibility information if the underlying accessibility labels aren’t available.

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/accessibility in the Human Interface Guidelines.

## Topics

### Essentials

- [Creating accessible views](https://developer.apple.com/documentation/swiftui/creating-accessible-views) — Make your app accessible to everyone by applying accessibility modifiers to your SwiftUI views.
### Creating accessible elements

- [accessibilityElement(children:)](https://developer.apple.com/documentation/swiftui/view/accessibilityelement(children:)) — Creates a new accessibility element, or modifies the [doc://com.apple.SwiftUI/documentation/SwiftUI/AccessibilityChildBehavior](https://developer.apple.com/documentation/SwiftUI/AccessibilityChildBehavior) of the existing accessibility element.
- [accessibilityChildren(children:)](https://developer.apple.com/documentation/swiftui/view/accessibilitychildren(children:)) — Replaces the existing accessibility element’s children with one or more new synthetic accessibility elements.
- [accessibilityRepresentation(representation:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrepresentation(representation:)) — Replaces one or more accessibility elements for this view with new accessibility elements.
- [AccessibilityChildBehavior](https://developer.apple.com/documentation/swiftui/accessibilitychildbehavior) — Defines the behavior for the child elements of the new parent element.
### Identifying elements

- [accessibilityIdentifier(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityidentifier(_:)) — Uses the string you specify to identify the view.
- [accessibilityIdentifier(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityidentifier(_:isenabled:)) — Uses the string you specify to identify the view.
### Hiding elements

- [accessibilityHidden(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityhidden(_:)) — Specifies whether to hide this view from system accessibility features.
- [accessibilityHidden(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityhidden(_:isenabled:)) — Specifies whether to hide this view from system accessibility features.
### Supporting types

- [AccessibilityTechnologies](https://developer.apple.com/documentation/swiftui/accessibilitytechnologies) — Accessibility technologies available to the system.
- [AccessibilityAttachmentModifier](https://developer.apple.com/documentation/swiftui/accessibilityattachmentmodifier) — A view modifier that adds accessibility properties to the view

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessibility-fundamentals](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessibility-fundamentals)*
--- END FILE ---

--- FILE: Accessible-descriptions.md ---
# Accessible descriptions

**Describe interface elements to help people understand what they represent.**


## Overview

SwiftUI can often infer some information about your user interface elements, but you can use accessibility modifiers to provide even more information for users that need it.

![Image](accessible-descriptions-hero)

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/accessibility#Content-descriptions in the Accessibility section of the Human Interface Guidelines.

## Topics

### Applying labels

- [accessibilityLabel(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:)) — Adds a label to the view that describes its contents.
- [accessibilityLabel(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(_:isenabled:)) — Adds a label to the view that describes its contents.
- [accessibilityLabel(content:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabel(content:)) — Adds a label to the view that describes its contents.
- [accessibilityInputLabels(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:)) — Sets alternate input labels with which users identify a view.
- [accessibilityInputLabels(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityinputlabels(_:isenabled:)) — Sets alternate input labels with which users identify a view.
- [accessibilityLabeledPair(role:id:in:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylabeledpair(role:id:in:)) — Pairs an accessibility element representing a label with the element for the matching content.
- [AccessibilityLabeledPairRole](https://developer.apple.com/documentation/swiftui/accessibilitylabeledpairrole) — The role of an accessibility element in a label / content pair.
### Describing values

- [accessibilityValue(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:)) — Adds a textual description of the value that the view contains.
- [accessibilityValue(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityvalue(_:isenabled:)) — Adds a textual description of the value that the view contains.
### Describing content

- [accessibilityTextContentType(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitytextcontenttype(_:)) — Sets an accessibility text content type.
- [accessibilityHeading(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityheading(_:)) — Sets the accessibility level of this heading.
- [AccessibilityHeadingLevel](https://developer.apple.com/documentation/swiftui/accessibilityheadinglevel) — The hierarchy of a heading in relation other headings.
- [AccessibilityTextContentType](https://developer.apple.com/documentation/swiftui/accessibilitytextcontenttype) — Textual context that assistive technologies can use to improve the presentation of spoken text.
### Describing charts

- [accessibilityChartDescriptor(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitychartdescriptor(_:)) — Adds a descriptor to a View that represents a chart to make the chart’s contents accessible to all users.
- [AXChartDescriptorRepresentable](https://developer.apple.com/documentation/swiftui/axchartdescriptorrepresentable) — A type to generate an `AXChartDescriptor` object that you use to provide information about a chart and its data for an accessible experience in VoiceOver or other assistive technologies.
### Adding custom descriptions

- [accessibilityCustomContent(_:_:importance:)](https://developer.apple.com/documentation/swiftui/view/accessibilitycustomcontent(_:_:importance:)) — Add additional accessibility information to the view.
- [AccessibilityCustomContentKey](https://developer.apple.com/documentation/swiftui/accessibilitycustomcontentkey) — Key used to specify the identifier and label associated with an entry of additional accessibility information.
### Assigning traits to content

- [accessibilityAddTraits(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaddtraits(_:)) — Adds the given traits to the view.
- [accessibilityRemoveTraits(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityremovetraits(_:)) — Removes the given traits from this view.
- [AccessibilityTraits](https://developer.apple.com/documentation/swiftui/accessibilitytraits) — A set of accessibility traits that describe how an element behaves.
### Offering hints

- [accessibilityHint(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:)) — Communicates to the user what happens after performing the view’s action.
- [accessibilityHint(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityhint(_:isenabled:)) — Communicates to the user what happens after performing the view’s action.
### Configuring VoiceOver

- [speechAdjustedPitch(_:)](https://developer.apple.com/documentation/swiftui/view/speechadjustedpitch(_:)) — Raises or lowers the pitch of spoken text.
- [speechAlwaysIncludesPunctuation(_:)](https://developer.apple.com/documentation/swiftui/view/speechalwaysincludespunctuation(_:)) — Sets whether VoiceOver should always speak all punctuation in the text view.
- [speechAnnouncementsQueued(_:)](https://developer.apple.com/documentation/swiftui/view/speechannouncementsqueued(_:)) — Controls whether to queue pending announcements behind existing speech rather than interrupting speech in progress.
- [speechSpellsOutCharacters(_:)](https://developer.apple.com/documentation/swiftui/view/speechspellsoutcharacters(_:)) — Sets whether VoiceOver should speak the contents of the text view character by character.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-descriptions](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-descriptions)*
--- END FILE ---

--- FILE: Accessible-navigation.md ---
# Accessible navigation

**Enable users to navigate to specific user interface elements using rotors.**


## Overview

An accessibility rotor is a shortcut that enables users to quickly navigate to specific elements of the user interface, and, optionally, to specific ranges of text within those elements.

![Image](accessible-navigation-hero)

The system automatically provides rotors for many navigable elements, but you can supply additional rotors for specific purposes, or replace system rotors when they don’t automatically pick up off-screen elements, like those far down in a [doc://com.apple.SwiftUI/documentation/SwiftUI/LazyVStack](https://developer.apple.com/documentation/SwiftUI/LazyVStack) or a [doc://com.apple.SwiftUI/documentation/SwiftUI/List](https://developer.apple.com/documentation/SwiftUI/List).

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/accessibility#Navigation in the Accessibility section of the Human Interface Guidelines.

## Topics

### Working with rotors

- [accessibilityRotor(_:entries:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:)) — Create an Accessibility Rotor with the specified user-visible label, and entries generated from the content closure.
- [accessibilityRotor(_:entries:entryID:entryLabel:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entryid:entrylabel:)) — Create an Accessibility Rotor with the specified user-visible label and entries.
- [accessibilityRotor(_:entries:entryLabel:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:entries:entrylabel:)) — Create an Accessibility Rotor with the specified user-visible label and entries.
- [accessibilityRotor(_:textRanges:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotor(_:textranges:)) — Create an Accessibility Rotor with the specified user-visible label and entries for each of the specified ranges. The Rotor will be attached to the current Accessibility element, and each entry will go the specified range of that element.
### Creating rotors

- [AccessibilityRotorContent](https://developer.apple.com/documentation/swiftui/accessibilityrotorcontent) — Content within an accessibility rotor.
- [AccessibilityRotorContentBuilder](https://developer.apple.com/documentation/swiftui/accessibilityrotorcontentbuilder) — Result builder you use to generate rotor entry content.
- [AccessibilityRotorEntry](https://developer.apple.com/documentation/swiftui/accessibilityrotorentry) — A struct representing an entry in an Accessibility Rotor.
### Replacing system rotors

- [AccessibilitySystemRotor](https://developer.apple.com/documentation/swiftui/accessibilitysystemrotor) — Designates a Rotor that replaces one of the automatic, system-provided Rotors with a developer-provided Rotor.
### Configuring rotors

- [accessibilityRotorEntry(id:in:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrotorentry(id:in:)) — Defines an explicit identifier tying an Accessibility element for this view to an entry in an Accessibility Rotor.
- [accessibilityLinkedGroup(id:in:)](https://developer.apple.com/documentation/swiftui/view/accessibilitylinkedgroup(id:in:)) — Links multiple accessibility elements so that the user can quickly navigate from one element to another, even when the elements are not near each other in the accessibility hierarchy.
- [accessibilitySortPriority(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitysortpriority(_:)) — Sets the sort priority order for this view’s accessibility element, relative to other elements at the same level.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-navigation](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-navigation)*
--- END FILE ---

--- FILE: Accessible-controls.md ---
# Accessible controls

**Improve access to actions that your app can undertake.**


## Overview

Help people using assistive technologies to gain access to controls in your app.

![Image](accessible-controls-hero)

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/accessibility#Buttons-and-controls in the Accessibility section of the Human Interface Guidelines.

## Topics

### Adding actions to views

- [accessibilityAction(_:_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaction(_:_:)) — Adds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.
- [accessibilityActions(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityactions(_:)) — Adds multiple accessibility actions to the view.
- [accessibilityAction(named:_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaction(named:_:)) — Adds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.
- [accessibilityAction(action:label:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaction(action:label:)) — Adds an accessibility action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.
- [accessibilityAction(intent:label:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaction(intent:label:)) — Adds an accessibility action labeled by the contents of `label` to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action. When the action is performed, the `intent` will be invoked.
- [accessibilityAction(_:intent:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaction(_:intent:)) — Adds an accessibility action representing `actionKind` to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action. When the action is performed, the `intent` will be invoked.
- [accessibilityAction(named:intent:)](https://developer.apple.com/documentation/swiftui/view/accessibilityaction(named:intent:)) — Adds an accessibility action labeled `name` to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action. When the action is performed, the `intent` will be invoked.
- [accessibilityAdjustableAction(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityadjustableaction(_:)) — Adds an accessibility adjustable action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.
- [accessibilityScrollAction(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityscrollaction(_:)) — Adds an accessibility scroll action to the view. Actions allow assistive technologies, such as the VoiceOver, to interact with the view by invoking the action.
- [accessibilityActions(category:_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityactions(category:_:)) — Adds multiple accessibility actions to the view with a specific category. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action and are grouped by their category. When multiple action modifiers with an equal category are applied to the view, the actions are combined together.
- [AccessibilityActionKind](https://developer.apple.com/documentation/swiftui/accessibilityactionkind) — The structure that defines the kinds of available accessibility actions.
- [AccessibilityAdjustmentDirection](https://developer.apple.com/documentation/swiftui/accessibilityadjustmentdirection) — A directional indicator you use when making an accessibility adjustment.
- [AccessibilityActionCategory](https://developer.apple.com/documentation/swiftui/accessibilityactioncategory) — Designates an accessibility action category that is provided and named by the system.
### Offering Quick Actions to people

- [accessibilityQuickAction(style:content:)](https://developer.apple.com/documentation/swiftui/view/accessibilityquickaction(style:content:)) — Adds a quick action to be shown by the system when active.
- [accessibilityQuickAction(style:isActive:content:)](https://developer.apple.com/documentation/swiftui/view/accessibilityquickaction(style:isactive:content:)) — Adds a quick action to be shown by the system when active.
- [AccessibilityQuickActionStyle](https://developer.apple.com/documentation/swiftui/accessibilityquickactionstyle) — A type that describes the presentation style of an accessibility quick action.
### Making gestures accessible

- [accessibilityActivationPoint(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityactivationpoint(_:)) — The activation point for an element is the location assistive technologies use to initiate gestures.
- [accessibilityActivationPoint(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityactivationpoint(_:isenabled:)) — The activation point for an element is the location assistive technologies use to initiate gestures.
- [accessibilityDragPoint(_:description:)](https://developer.apple.com/documentation/swiftui/view/accessibilitydragpoint(_:description:)) — The point an assistive technology should use to begin a drag interaction.
- [accessibilityDragPoint(_:description:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilitydragpoint(_:description:isenabled:)) — The point an assistive technology should use to begin a drag interaction.
- [accessibilityDropPoint(_:description:)](https://developer.apple.com/documentation/swiftui/view/accessibilitydroppoint(_:description:)) — The point an assistive technology should use to end a drag interaction.
- [accessibilityDropPoint(_:description:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilitydroppoint(_:description:isenabled:)) — The point an assistive technology should use to end a drag interaction.
- [accessibilityDirectTouch(_:options:)](https://developer.apple.com/documentation/swiftui/view/accessibilitydirecttouch(_:options:)) — Explicitly set whether this accessibility element is a direct touch area. Direct touch areas passthrough touch events to the app rather than being handled through an assistive technology, such as VoiceOver. The modifier accepts an optional `AccessibilityDirectTouchOptions` option set to customize the functionality of the direct touch area.
- [accessibilityZoomAction(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityzoomaction(_:)) — Adds an accessibility zoom action to the view. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action.
- [AccessibilityDirectTouchOptions](https://developer.apple.com/documentation/swiftui/accessibilitydirecttouchoptions) — An option set that defines the functionality of a view’s direct touch area.
- [AccessibilityZoomGestureAction](https://developer.apple.com/documentation/swiftui/accessibilityzoomgestureaction) — Position and direction information of a zoom gesture that someone performs with an assistive technology like VoiceOver.
### Controlling focus

- [accessibilityFocused(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityfocused(_:)) — Modifies this view by binding its accessibility element’s focus state to the given boolean state value.
- [accessibilityFocused(_:equals:)](https://developer.apple.com/documentation/swiftui/view/accessibilityfocused(_:equals:)) — Modifies this view by binding its accessibility element’s focus state to the given state value.
- [AccessibilityFocusState](https://developer.apple.com/documentation/swiftui/accessibilityfocusstate) — A property wrapper type that can read and write a value that SwiftUI updates as the focus of any active accessibility technology, such as VoiceOver, changes.
### Managing interactivity

- [accessibilityRespondsToUserInteraction(_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrespondstouserinteraction(_:)) — Explicitly set whether this Accessibility element responds to user interaction and would thus be interacted with by technologies such as Switch Control, Voice Control or Full Keyboard Access.
- [accessibilityRespondsToUserInteraction(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityrespondstouserinteraction(_:isenabled:)) — Explicitly set whether this Accessibility element responds to user interaction and would thus be interacted with by technologies such as Switch Control, Voice Control or Full Keyboard Access.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-controls](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Accessible-controls)*
--- END FILE ---

--- FILE: View.md ---
# View

**A type that represents part of your app’s user interface and provides modifiers that you use to configure views.**

## Availability

- **iOS** 13.0+
- **iPadOS** 13.0+
- **Mac Catalyst** 13.0+
- **macOS** 10.15+
- **tvOS** 13.0+
- **visionOS** 1.0+
- **watchOS** 6.0+


## Overview

You create custom views by declaring types that conform to the `View` protocol. Implement the required [doc://com.apple.SwiftUI/documentation/SwiftUI/View/body-8kl5o](https://developer.apple.com/documentation/SwiftUI/View/body-8kl5o) computed property to provide the content for your custom view.

```swift
struct MyView: View {
    var body: some View {
        Text("Hello, World!")
    }
}
```

Assemble the view’s body by combining one or more of the built-in views provided by SwiftUI, like the [doc://com.apple.SwiftUI/documentation/SwiftUI/Text](https://developer.apple.com/documentation/SwiftUI/Text) instance in the example above, plus other custom views that you define, into a hierarchy of views. For more information about creating custom views, see [doc://com.apple.SwiftUI/documentation/SwiftUI/Declaring-a-Custom-View](https://developer.apple.com/documentation/SwiftUI/Declaring-a-Custom-View).

The `View` protocol provides a set of modifiers — protocol methods with default implementations — that you use to configure views in the layout of your app. Modifiers work by wrapping the view instance on which you call them in another view with the specified characteristics, as described in [doc://com.apple.SwiftUI/documentation/SwiftUI/Configuring-Views](https://developer.apple.com/documentation/SwiftUI/Configuring-Views). For example, adding the [doc://com.apple.SwiftUI/documentation/SwiftUI/View/opacity(_:)](https://developer.apple.com/documentation/SwiftUI/View/opacity(_:)) modifier to a text view returns a new view with some amount of transparency:

```swift
Text("Hello, World!")
    .opacity(0.5) // Display partially transparent text.
```

The complete list of default modifiers provides a large set of controls for managing views. For example, you can fine tune [doc://com.apple.SwiftUI/documentation/SwiftUI/View-Layout](https://developer.apple.com/documentation/SwiftUI/View-Layout), add [doc://com.apple.SwiftUI/documentation/SwiftUI/View-Accessibility](https://developer.apple.com/documentation/SwiftUI/View-Accessibility) information, and respond to [doc://com.apple.SwiftUI/documentation/SwiftUI/View-Input-and-Events](https://developer.apple.com/documentation/SwiftUI/View-Input-and-Events). You can also collect groups of default modifiers into new, custom view modifiers for easy reuse.

A type conforming to this protocol inherits `@preconcurrency @MainActor` isolation from the protocol if the conformance is declared in its original declaration. Isolation to the main actor is the default, but it’s not required. Declare the conformance in an extension to opt-out the isolation.

## Topics

### Implementing a custom view

- [body](https://developer.apple.com/documentation/swiftui/view/body-8kl5o) — The content and behavior of the view.
- [Body](https://developer.apple.com/documentation/swiftui/view/body-swift.associatedtype) — The type of view representing the body of this view.
- [modifier(_:)](https://developer.apple.com/documentation/swiftui/view/modifier(_:)) — Applies a modifier to a view and returns a new view.
- [Previews in Xcode](https://developer.apple.com/documentation/swiftui/previews-in-xcode) — Generate dynamic, interactive previews of your custom views.
### Configuring view elements

- [Accessibility modifiers](https://developer.apple.com/documentation/swiftui/view-accessibility) — Make your SwiftUI apps accessible to everyone, including people with disabilities.
- [Appearance modifiers](https://developer.apple.com/documentation/swiftui/view-appearance) — Configure a view’s foreground and background styles, controls, and visibility.
- [Text and symbol modifiers](https://developer.apple.com/documentation/swiftui/view-text-and-symbols) — Manage the rendering, selection, and entry of text in your view.
- [Auxiliary view modifiers](https://developer.apple.com/documentation/swiftui/view-auxiliary-views) — Add and configure supporting views, like toolbars and context menus.
- [Chart view modifiers](https://developer.apple.com/documentation/swiftui/view-chart-view) — Configure charts that you declare with Swift Charts.
### Drawing views

- [Style modifiers](https://developer.apple.com/documentation/swiftui/view-style-modifiers) — Apply built-in styles to different types of views.
- [Layout modifiers](https://developer.apple.com/documentation/swiftui/view-layout) — Tell a view how to arrange itself within a view hierarchy by adjusting its size, position, alignment, padding, and so on.
- [Graphics and rendering modifiers](https://developer.apple.com/documentation/swiftui/view-graphics-and-rendering) — Affect the way the system draws a view, for example by scaling or masking a view, or by applying graphical effects.
### Providing interactivity

- [Input and event modifiers](https://developer.apple.com/documentation/swiftui/view-input-and-events) — Supply actions for a view to perform in response to user input and system events.
- [Search modifiers](https://developer.apple.com/documentation/swiftui/view-search) — Enable people to search for content in your app.
- [Presentation modifiers](https://developer.apple.com/documentation/swiftui/view-presentation) — Define additional views for the view to present under specified conditions.
- [State modifiers](https://developer.apple.com/documentation/swiftui/view-state) — Access storage and provide child views with configuration data.
### Deprecated modifiers

- [Deprecated modifiers](https://developer.apple.com/documentation/swiftui/view-deprecated) — Review unsupported modifiers and their replacements.
### Instance Methods

- [accessibilityActions(category:_:)](https://developer.apple.com/documentation/swiftui/view/accessibilityactions(category:_:)) — Adds multiple accessibility actions to the view with a specific category. Actions allow assistive technologies, such as VoiceOver, to interact with the view by invoking the action and are grouped by their category. When multiple action modifiers with an equal category are applied to the view, the actions are combined together.
- [accessibilityDefaultFocus(_:_:)](https://developer.apple.com/documentation/swiftui/view/accessibilitydefaultfocus(_:_:)) — Defines a region in which default accessibility focus is evaluated by assigning a value to a given accessibility focus state binding.
- [accessibilityScrollStatus(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/accessibilityscrollstatus(_:isenabled:)) — Changes the announcement provided by accessibility technologies when a user scrolls a scroll view within this view.
- [accessoryWidgetGroupStyle(_:)](https://developer.apple.com/documentation/swiftui/view/accessorywidgetgroupstyle(_:)) — The view modifier that can be applied to `AccessoryWidgetGroup` to specify the shape the three content views will be masked with. The value of `style` is set to `.automatic`, which is `.circular` by default.
- [addOrderToWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/addordertowalletbuttonstyle(_:)) — Sets the button’s style.
- [addPassToWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/addpasstowalletbuttonstyle(_:)) — Sets the style to be used by the button. (see `PKAddPassButtonStyle`).
- [allowsWindowActivationEvents()](https://developer.apple.com/documentation/swiftui/view/allowswindowactivationevents()) — Configures gestures in this view hierarchy to handle events that activate the containing window.
- [appStoreMerchandising(isPresented:kind:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/appstoremerchandising(ispresented:kind:ondismiss:))
- [aspectRatio3D(_:contentMode:)](https://developer.apple.com/documentation/swiftui/view/aspectratio3d(_:contentmode:)) — Constrains this view’s dimensions to the specified 3D aspect ratio.
- [assistiveAccessNavigationIcon(_:)](https://developer.apple.com/documentation/swiftui/view/assistiveaccessnavigationicon(_:)) — Configures the view’s icon for purposes of navigation.
- [assistiveAccessNavigationIcon(systemImage:)](https://developer.apple.com/documentation/swiftui/view/assistiveaccessnavigationicon(systemimage:)) — Configures the view’s icon for purposes of navigation.
- [attributedTextFormattingDefinition(_:)](https://developer.apple.com/documentation/swiftui/view/attributedtextformattingdefinition(_:)) — Apply a text formatting definition to nested views.
- [automatedDeviceEnrollmentAddition(isPresented:)](https://developer.apple.com/documentation/swiftui/view/automateddeviceenrollmentaddition(ispresented:)) — Presents a modal view that enables users to add devices to their organization.
- [backgroundExtensionEffect()](https://developer.apple.com/documentation/swiftui/view/backgroundextensioneffect()) — Adds the background extension effect to the view. The view will be duplicated into mirrored copies which will be placed around the view on any edge with available safe area. Additionally, a blur effect will be applied on top to blur out the copies.
- [backgroundExtensionEffect(isEnabled:)](https://developer.apple.com/documentation/swiftui/view/backgroundextensioneffect(isenabled:)) — Adds the background extension effect to the view. The view will be duplicated into mirrored copies which will be placed around the view on any edge with available safe area. Additionally, a blur effect will be applied on top to blur out the copies.
- [breakthroughEffect(_:)](https://developer.apple.com/documentation/swiftui/view/breakthrougheffect(_:)) — Ensures that the view is always visible to the user, even when other content is occluding it, like 3D models.
- [buttonSizing(_:)](https://developer.apple.com/documentation/swiftui/view/buttonsizing(_:)) — The preferred sizing behavior of buttons in the view hierarchy.
- [certificateSheet(trust:title:message:help:)](https://developer.apple.com/documentation/swiftui/view/certificatesheet(trust:title:message:help:)) — Displays a certificate sheet using the provided certificate trust.
- [chart3DCameraProjection(_:)](https://developer.apple.com/documentation/swiftui/view/chart3dcameraprojection(_:))
- [chart3DPose(_:)](https://developer.apple.com/documentation/swiftui/view/chart3dpose(_:)) — Associates a binding to be updated when the 3D chart’s pose is changed by an interaction.
- [chart3DRenderingStyle(_:)](https://developer.apple.com/documentation/swiftui/view/chart3drenderingstyle(_:))
- [chartZAxis(_:)](https://developer.apple.com/documentation/swiftui/view/chartzaxis(_:)) — Sets the visibility of the z axis.
- [chartZAxis(content:)](https://developer.apple.com/documentation/swiftui/view/chartzaxis(content:)) — Configures the z-axis for 3D charts in the view.
- [chartZAxisLabel(_:position:alignment:spacing:)](https://developer.apple.com/documentation/swiftui/view/chartzaxislabel(_:position:alignment:spacing:)) — Adds z axis label for charts in the view. It effects 3D charts only.
- [chartZScale(domain:range:type:)](https://developer.apple.com/documentation/swiftui/view/chartzscale(domain:range:type:)) — Configures the z scale for 3D charts.
- [chartZScale(domain:type:)](https://developer.apple.com/documentation/swiftui/view/chartzscale(domain:type:)) — Configures the z scale for 3D charts.
- [chartZScale(range:type:)](https://developer.apple.com/documentation/swiftui/view/chartzscale(range:type:)) — Configures the z scale for 3D charts.
- [chartZSelection(range:)](https://developer.apple.com/documentation/swiftui/view/chartzselection(range:))
- [chartZSelection(value:)](https://developer.apple.com/documentation/swiftui/view/chartzselection(value:))
- [contactAccessButtonCaption(_:)](https://developer.apple.com/documentation/swiftui/view/contactaccessbuttoncaption(_:))
- [contactAccessButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/contactaccessbuttonstyle(_:))
- [contactAccessPicker(isPresented:completionHandler:)](https://developer.apple.com/documentation/swiftui/view/contactaccesspicker(ispresented:completionhandler:)) — Modally present UI which allows the user to select which contacts your app has access to.
- [containerCornerOffset(_:sizeToFit:)](https://developer.apple.com/documentation/swiftui/view/containercorneroffset(_:sizetofit:)) — Adjusts the view’s layout to avoid the container view’s corner insets for the specified edges.
- [containerValue(_:_:)](https://developer.apple.com/documentation/swiftui/view/containervalue(_:_:)) — Sets a particular container value of a view.
- [contentCaptureProtected(_:)](https://developer.apple.com/documentation/swiftui/view/contentcaptureprotected(_:))
- [contentToolbar(for:content:)](https://developer.apple.com/documentation/swiftui/view/contenttoolbar(for:content:)) — Populates the toolbar of the specified content view type with the views you provide.
- [continuityDevicePicker(isPresented:onDidConnect:)](https://developer.apple.com/documentation/swiftui/view/continuitydevicepicker(ispresented:ondidconnect:)) — A `continuityDevicePicker` should be used to discover and connect nearby continuity device through a button interface or other form of activation. On tvOS, this presents a fullscreen continuity device picker experience when selected. The modal view covers as much the screen of `self` as possible when a given condition is true.
- [controlWidgetActionHint(_:)](https://developer.apple.com/documentation/swiftui/view/controlwidgetactionhint(_:)) — The action hint of the control described by the modified label.
- [controlWidgetStatus(_:)](https://developer.apple.com/documentation/swiftui/view/controlwidgetstatus(_:)) — The status of the control described by the modified label.
- [currentEntitlementTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/currententitlementtask(for:priority:action:)) — Declares the view as dependent on the entitlement of an In-App Purchase product, and returns a modified view.
- [dialogPreventsAppTermination(_:)](https://developer.apple.com/documentation/swiftui/view/dialogpreventsapptermination(_:)) — Whether the alert or confirmation dialog prevents the app from being quit/terminated by the system or app termination menu item.
- [documentBrowserContextMenu(_:)](https://developer.apple.com/documentation/swiftui/view/documentbrowsercontextmenu(_:)) — Adds to a `DocumentLaunchView` actions that accept a list of selected files as their parameter.
- [dragConfiguration(_:)](https://developer.apple.com/documentation/swiftui/view/dragconfiguration(_:)) — Configures a drag session.
- [dragContainer(for:in:_:)](https://developer.apple.com/documentation/swiftui/view/dragcontainer(for:in:_:)) — A container with draggable views where the drag payload is based on multiple identifiers of dragged items.
- [dragContainer(for:itemID:in:_:)](https://developer.apple.com/documentation/swiftui/view/dragcontainer(for:itemid:in:_:)) — A container with draggable views.
- [dragContainerSelection(_:containerNamespace:)](https://developer.apple.com/documentation/swiftui/view/dragcontainerselection(_:containernamespace:)) — Provides multiple item selection support for drag containers.
- [dragPreviewsFormation(_:)](https://developer.apple.com/documentation/swiftui/view/dragpreviewsformation(_:)) — Describes the way dragged previews are visually composed.
- [draggable(_:containerNamespace:_:)](https://developer.apple.com/documentation/swiftui/view/draggable(_:containernamespace:_:)) — Activates this view as the source of a drag and drop operation, allowing to provide optional identifiable payload and specify the namespace of the drag container this view belongs to.
- [draggable(_:id:containerNamespace:_:)](https://developer.apple.com/documentation/swiftui/view/draggable(_:id:containernamespace:_:)) — Activates this view as the source of a drag and drop operation, allowing to provide optional payload and specify the namespace of the drag container this view belongs to.
- [draggable(_:id:item:containerNamespace:)](https://developer.apple.com/documentation/swiftui/view/draggable(_:id:item:containernamespace:)) — Activates this view as the source of a drag and drop operation, allowing to provide optional payload and specify the namespace of the drag container this view belongs to.
- [draggable(_:item:containerNamespace:)](https://developer.apple.com/documentation/swiftui/view/draggable(_:item:containernamespace:)) — Activates this view as the source of a drag and drop operation, allowing to provide optional identifiable payload and specify the namespace of the drag container this view belongs to.
- [draggable(containerItemID:containerNamespace:)](https://developer.apple.com/documentation/swiftui/view/draggable(containeritemid:containernamespace:)) — Inside a drag container, activates this view as the source of a drag and drop operation. Supports lazy drag containers.
- [dropConfiguration(_:)](https://developer.apple.com/documentation/swiftui/view/dropconfiguration(_:)) — Configures a drop session.
- [dropDestination(for:isEnabled:action:)](https://developer.apple.com/documentation/swiftui/view/dropdestination(for:isenabled:action:)) — Defines the destination of a drag and drop operation that provides a drop operation proposal and handles the dropped content with a closure that you specify.
- [dropPreviewsFormation(_:)](https://developer.apple.com/documentation/swiftui/view/droppreviewsformation(_:)) — Describes the way previews for a drop are composed.
- [formStyle(_:)](https://developer.apple.com/documentation/swiftui/view/formstyle(_:)) — Sets the style for forms in a view hierarchy.
- [gameSaveSyncingAlert(directory:finishedLoading:)](https://developer.apple.com/documentation/swiftui/view/gamesavesyncingalert(directory:finishedloading:)) — Presents a modal view while the game synced directory loads.
- [glassBackgroundEffect(_:displayMode:)](https://developer.apple.com/documentation/swiftui/view/glassbackgroundeffect(_:displaymode:)) — Fills the view’s background with a custom glass background effect and container-relative rounded rectangle shape.
- [glassBackgroundEffect(_:in:displayMode:)](https://developer.apple.com/documentation/swiftui/view/glassbackgroundeffect(_:in:displaymode:)) — Fills the view’s background with a custom glass background effect and a shape that you specify.
- [glassEffect(_:in:)](https://developer.apple.com/documentation/swiftui/view/glasseffect(_:in:)) — Applies the Liquid Glass effect to a view.
- [glassEffectID(_:in:)](https://developer.apple.com/documentation/swiftui/view/glasseffectid(_:in:)) — Associates an identity value to Liquid Glass effects defined within this view.
- [glassEffectTransition(_:)](https://developer.apple.com/documentation/swiftui/view/glasseffecttransition(_:)) — Associates a glass effect transition with any glass effects defined within this view.
- [glassEffectUnion(id:namespace:)](https://developer.apple.com/documentation/swiftui/view/glasseffectunion(id:namespace:)) — Associates any Liquid Glass effects defined within this view to a union with the provided identifier.
- [groupActivityAssociation(_:)](https://developer.apple.com/documentation/swiftui/view/groupactivityassociation(_:)) — Specifies how a view should be associated with the current SharePlay group activity.
- [handGestureShortcut(_:isEnabled:)](https://developer.apple.com/documentation/swiftui/view/handgestureshortcut(_:isenabled:)) — Assigns a hand gesture shortcut to the modified control.
- [handPointerBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/handpointerbehavior(_:)) — Sets the behavior of the hand pointer while the user is interacting with the view.
- [handlesGameControllerEvents(matching:)](https://developer.apple.com/documentation/swiftui/view/handlesgamecontrollerevents(matching:)) — Specifies the game controllers events which should be delivered through the GameController framework when the view, or one of its descendants has focus.
- [handlesGameControllerEvents(matching:withOptions:)](https://developer.apple.com/documentation/swiftui/view/handlesgamecontrollerevents(matching:withoptions:)) — Specifies the game controllers events which should be delivered through the GameController framework when the view or one of its descendants has focus.
- [healthDataAccessRequest(store:objectType:predicate:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:objecttype:predicate:trigger:completion:)) — Asynchronously requests permission to read a data type that requires per-object authorization (such as vision prescriptions).
- [healthDataAccessRequest(store:readTypes:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:readtypes:trigger:completion:)) — Requests permission to read the specified HealthKit data types.
- [healthDataAccessRequest(store:shareTypes:readTypes:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:sharetypes:readtypes:trigger:completion:)) — Requests permission to save and read the specified HealthKit data types.
- [imagePlaygroundGenerationStyle(_:in:)](https://developer.apple.com/documentation/swiftui/view/imageplaygroundgenerationstyle(_:in:)) — Sets the generation style for an image playground.
- [imagePlaygroundPersonalizationPolicy(_:)](https://developer.apple.com/documentation/swiftui/view/imageplaygroundpersonalizationpolicy(_:)) — Policy determining whether to support the usage of people in the playground or not.
- [imagePlaygroundSheet(isPresented:concept:sourceImage:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/imageplaygroundsheet(ispresented:concept:sourceimage:oncompletion:oncancellation:)) — Presents the system sheet to create images from the specified input.
- [imagePlaygroundSheet(isPresented:concept:sourceImageURL:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/imageplaygroundsheet(ispresented:concept:sourceimageurl:oncompletion:oncancellation:)) — Presents the system sheet to create images from the specified input.
- [imagePlaygroundSheet(isPresented:concepts:sourceImage:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/imageplaygroundsheet(ispresented:concepts:sourceimage:oncompletion:oncancellation:)) — Presents the system sheet to create images from the specified input.
- [imagePlaygroundSheet(isPresented:concepts:sourceImageURL:onCompletion:onCancellation:)](https://developer.apple.com/documentation/swiftui/view/imageplaygroundsheet(ispresented:concepts:sourceimageurl:oncompletion:oncancellation:)) — Presents the system sheet to create images from the specified input.
- [immersiveEnvironmentPicker(content:)](https://developer.apple.com/documentation/swiftui/view/immersiveenvironmentpicker(content:)) — Add menu items to open immersive spaces from a media player’s environment picker.
- [inAppPurchaseOptions(_:)](https://developer.apple.com/documentation/swiftui/view/inapppurchaseoptions(_:)) — Add a function to call before initiating a purchase from StoreKit view within this view, providing a set of options for the purchase.
- [journalingSuggestionsPicker(isPresented:journalingSuggestionToken:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/journalingsuggestionspicker(ispresented:journalingsuggestiontoken:oncompletion:)) — Presents a visual picker interface that contains events and images that a person can select to retrieve more information.
- [journalingSuggestionsPicker(isPresented:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/journalingsuggestionspicker(ispresented:oncompletion:)) — Presents a visual picker interface that contains events and images that a person can select to retrieve more information.
- [labelIconToTitleSpacing(_:)](https://developer.apple.com/documentation/swiftui/view/labelicontotitlespacing(_:)) — Set the spacing between the icon and title in labels.
- [labelReservedIconWidth(_:)](https://developer.apple.com/documentation/swiftui/view/labelreservediconwidth(_:)) — Set the width reserved for icons in labels.
- [labeledContentStyle(_:)](https://developer.apple.com/documentation/swiftui/view/labeledcontentstyle(_:)) — Sets a style for labeled content.
- [labelsVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/labelsvisibility(_:)) — Controls the visibility of labels of any controls contained within this view.
- [lineHeight(_:)](https://developer.apple.com/documentation/swiftui/view/lineheight(_:)) — A modifier for the default line height in the view hierarchy.
- [listRowInsets(_:_:)](https://developer.apple.com/documentation/swiftui/view/listrowinsets(_:_:)) — Sets the insets of rows in a list on the specified edges.
- [listSectionIndexVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/listsectionindexvisibility(_:)) — Changes the visibility of the list section index.
- [listSectionMargins(_:_:)](https://developer.apple.com/documentation/swiftui/view/listsectionmargins(_:_:)) — Set the section margins for the specific edges.
- [lookAroundViewer(isPresented:initialScene:allowsNavigation:showsRoadLabels:pointsOfInterest:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/lookaroundviewer(ispresented:initialscene:allowsnavigation:showsroadlabels:pointsofinterest:ondismiss:))
- [lookAroundViewer(isPresented:scene:allowsNavigation:showsRoadLabels:pointsOfInterest:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/lookaroundviewer(ispresented:scene:allowsnavigation:showsroadlabels:pointsofinterest:ondismiss:))
- [manageSubscriptionsSheet(isPresented:subscriptionGroupID:)](https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:subscriptiongroupid:))
- [managedContentStyle(_:)](https://developer.apple.com/documentation/swiftui/view/managedcontentstyle(_:)) — Applies a managed content style to the view.
- [manipulable(coordinateSpace:operations:inertia:isEnabled:onChanged:)](https://developer.apple.com/documentation/swiftui/view/manipulable(coordinatespace:operations:inertia:isenabled:onchanged:)) — Allows this view to be manipulated using common hand gestures.
- [manipulable(transform:coordinateSpace:operations:inertia:isEnabled:onChanged:)](https://developer.apple.com/documentation/swiftui/view/manipulable(transform:coordinatespace:operations:inertia:isenabled:onchanged:)) — Applies the given 3D affine transform to the view and allows it to be manipulated using common hand gestures.
- [manipulable(using:)](https://developer.apple.com/documentation/swiftui/view/manipulable(using:)) — Allows the view to be manipulated using a manipulation gesture attached to a different view.
- [manipulationGesture(updating:coordinateSpace:operations:inertia:isEnabled:onChanged:)](https://developer.apple.com/documentation/swiftui/view/manipulationgesture(updating:coordinatespace:operations:inertia:isenabled:onchanged:)) — Adds a manipulation gesture to this view without allowing this view to be manipulable itself.
- [mapCameraKeyframeAnimator(trigger:keyframes:)](https://developer.apple.com/documentation/swiftui/view/mapcamerakeyframeanimator(trigger:keyframes:)) — Uses the given keyframes to animate the camera of a `Map` when the given trigger value changes.
- [mapControlVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/mapcontrolvisibility(_:)) — Configures all Map controls in the environment to have the specified visibility
- [mapControls(_:)](https://developer.apple.com/documentation/swiftui/view/mapcontrols(_:)) — Configures all `Map` views in the associated environment to have standard size and position controls
- [mapFeatureSelectionAccessory(_:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectionaccessory(_:)) — Specifies the selection accessory to display for a `MapFeature`
- [mapFeatureSelectionContent(content:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectioncontent(content:)) — Specifies a custom presentation for the currently selected feature.
- [mapFeatureSelectionDisabled(_:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectiondisabled(_:)) — Specifies which map features should have selection disabled.
- [mapItemDetailPopover(isPresented:item:displaysMap:attachmentAnchor:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(ispresented:item:displaysmap:attachmentanchor:)) — Presents a map item detail popover.
- [mapItemDetailPopover(isPresented:item:displaysMap:attachmentAnchor:arrowEdge:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(ispresented:item:displaysmap:attachmentanchor:arrowedge:)) — Presents a map item detail popover.
- [mapItemDetailPopover(item:displaysMap:attachmentAnchor:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(item:displaysmap:attachmentanchor:)) — Presents a map item detail popover.
- [mapItemDetailPopover(item:displaysMap:attachmentAnchor:arrowEdge:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(item:displaysmap:attachmentanchor:arrowedge:)) — Presents a map item detail popover.
- [mapItemDetailSheet(isPresented:item:displaysMap:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailsheet(ispresented:item:displaysmap:)) — Presents a map item detail sheet.
- [mapItemDetailSheet(item:displaysMap:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailsheet(item:displaysmap:)) — Presents a map item detail sheet.
- [mapScope(_:)](https://developer.apple.com/documentation/swiftui/view/mapscope(_:)) — Creates a mapScope that SwiftUI uses to connect map controls to an associated map.
- [mapStyle(_:)](https://developer.apple.com/documentation/swiftui/view/mapstyle(_:)) — Specifies the map style to be used.
- [matchedTransitionSource(id:in:)](https://developer.apple.com/documentation/swiftui/view/matchedtransitionsource(id:in:)) — Identifies this view as the source of a navigation transition, such as a zoom transition.
- [matchedTransitionSource(id:in:configuration:)](https://developer.apple.com/documentation/swiftui/view/matchedtransitionsource(id:in:configuration:)) — Identifies this view as the source of a navigation transition, such as a zoom transition.
- [materialActiveAppearance(_:)](https://developer.apple.com/documentation/swiftui/view/materialactiveappearance(_:)) — Sets an explicit active appearance for materials in this view.
- [multilineTextAlignment(strategy:)](https://developer.apple.com/documentation/swiftui/view/multilinetextalignment(strategy:)) — A modifier for the default text alignment strategy in the view hierarchy.
- [navigationLinkIndicatorVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/navigationlinkindicatorvisibility(_:)) — Configures whether navigation links show a disclosure indicator.
- [navigationTransition(_:)](https://developer.apple.com/documentation/swiftui/view/navigationtransition(_:)) — Sets the navigation transition style for this view.
- [onAppIntentExecution(_:perform:)](https://developer.apple.com/documentation/swiftui/view/onappintentexecution(_:perform:)) — Registers a handler to invoke in response to the specified app intent that your app receives.
- [onApplePayCouponCodeChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepaycouponcodechange(perform:)) — Called when a user has entered or updated a coupon code. This is required if the user is being asked to provide a coupon code.
- [onApplePayPaymentMethodChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepaypaymentmethodchange(perform:)) — Called when a payment method has changed and asks for an update payment request. If this modifier isn’t provided Wallet will assume the payment method is valid.
- [onApplePayShippingContactChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepayshippingcontactchange(perform:)) — Called when a user selected a shipping address. This is required if the user is being asked to provide a shipping contact.
- [onApplePayShippingMethodChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepayshippingmethodchange(perform:)) — Called when a user selected a shipping method. This is required if the user is being asked to provide a shipping method.
- [onCameraCaptureEvent(isEnabled:defaultSoundDisabled:action:)](https://developer.apple.com/documentation/swiftui/view/oncameracaptureevent(isenabled:defaultsounddisabled:action:)) — Used to register an action triggered by system capture events.
- [onCameraCaptureEvent(isEnabled:defaultSoundDisabled:primaryAction:secondaryAction:)](https://developer.apple.com/documentation/swiftui/view/oncameracaptureevent(isenabled:defaultsounddisabled:primaryaction:secondaryaction:)) — Used to register actions triggered by system capture events.
- [onDragSessionUpdated(_:)](https://developer.apple.com/documentation/swiftui/view/ondragsessionupdated(_:)) — Specifies an action to perform on each update of an ongoing dragging operation activated by `draggable(_:)` or anther drag modifiers.
- [onDropSessionUpdated(_:)](https://developer.apple.com/documentation/swiftui/view/ondropsessionupdated(_:)) — Specifies an action to perform on each update of an ongoing drop operation activated by `dropDestination(_:)` or other drop modifiers.
- [onGeometryChange3D(for:of:action:)](https://developer.apple.com/documentation/swiftui/view/ongeometrychange3d(for:of:action:)) — Returns a new view that arranges to call `action(value)` whenever the value computed by `transform(proxy)` changes, where `proxy` provides access to the view’s 3D geometry properties.
- [onInAppPurchaseCompletion(perform:)](https://developer.apple.com/documentation/swiftui/view/oninapppurchasecompletion(perform:)) — Add an action to perform when a purchase initiated from a StoreKit view within this view completes.
- [onInAppPurchaseStart(perform:)](https://developer.apple.com/documentation/swiftui/view/oninapppurchasestart(perform:)) — Add an action to perform when a user triggers the purchase button on a StoreKit view within this view.
- [onInteractiveResizeChange(_:)](https://developer.apple.com/documentation/swiftui/view/oninteractiveresizechange(_:)) — Adds an action to perform when the enclosing window is being interactively resized.
- [onMapCameraChange(frequency:_:)](https://developer.apple.com/documentation/swiftui/view/onmapcamerachange(frequency:_:)) — Performs an action when Map camera framing changes
- [onOpenURL(prefersInApp:)](https://developer.apple.com/documentation/swiftui/view/onopenurl(prefersinapp:)) — Sets an `OpenURLAction` that prefers opening URL with an in-app browser. It’s equivalent to calling `.onOpenURL(_:)`
- [onWorldRecenter(action:)](https://developer.apple.com/documentation/swiftui/view/onworldrecenter(action:)) — Adds an action to perform when recentering the view with the digital crown.
- [payLaterViewAction(_:)](https://developer.apple.com/documentation/swiftui/view/paylaterviewaction(_:)) — Sets the action on the PayLaterView. See `PKPayLaterAction`.
- [payLaterViewDisplayStyle(_:)](https://developer.apple.com/documentation/swiftui/view/paylaterviewdisplaystyle(_:)) — Sets the display style on the PayLaterView. See `PKPayLaterDisplayStyle`.
- [payWithApplePayButtonDisableCardArt()](https://developer.apple.com/documentation/swiftui/view/paywithapplepaybuttondisablecardart()) — Sets the features that should be allowed to show on the payment buttons.
- [payWithApplePayButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/paywithapplepaybuttonstyle(_:)) — Sets the style to be used by the button. (see `PayWithApplePayButtonStyle`).
- [popoverTip(_:arrowEdge:action:)](https://developer.apple.com/documentation/swiftui/view/popovertip(_:arrowedge:action:)) — Presents a popover tip on the modified view.
- [popoverTip(_:isPresented:attachmentAnchor:arrowEdge:action:)](https://developer.apple.com/documentation/swiftui/view/popovertip(_:ispresented:attachmentanchor:arrowedge:action:)) — Presents a popover tip on the modified view.
- [popoverTip(_:isPresented:attachmentAnchor:arrowEdges:action:)](https://developer.apple.com/documentation/swiftui/view/popovertip(_:ispresented:attachmentanchor:arrowedges:action:)) — Presents a popover tip on the modified view.
- [postToPhotosSharedAlbumSheet(isPresented:items:photoLibrary:defaultAlbumIdentifier:completion:)](https://developer.apple.com/documentation/swiftui/view/posttophotossharedalbumsheet(ispresented:items:photolibrary:defaultalbumidentifier:completion:)) — Presents an “Add to Shared Album” sheet that allows the user to post the given items to a shared album.
- [preferredSubscriptionOffer(_:)](https://developer.apple.com/documentation/swiftui/view/preferredsubscriptionoffer(_:)) — Selects a subscription offer to apply to a purchase that a customer makes from a subscription store view, a store view, or a product view.
- [preferredWindowClippingMargins(_:_:)](https://developer.apple.com/documentation/swiftui/view/preferredwindowclippingmargins(_:_:)) — Requests additional margins for drawing beyond the bounds of the window.
- [presentationBreakthroughEffect(_:)](https://developer.apple.com/documentation/swiftui/view/presentationbreakthrougheffect(_:)) — Changes the way the enclosing presentation breaks through content occluding it.
- [presentationPreventsAppTermination(_:)](https://developer.apple.com/documentation/swiftui/view/presentationpreventsapptermination(_:)) — Whether a presentation prevents the app from being terminated/quit by the system or app termination menu item.
- [productDescription(_:)](https://developer.apple.com/documentation/swiftui/view/productdescription(_:)) — Configure the visibility of labels displaying an in-app purchase product description within the view.
- [productIconBorder()](https://developer.apple.com/documentation/swiftui/view/producticonborder()) — Adds a standard border to an in-app purchase product’s icon .
- [productViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/productviewstyle(_:)) — Sets the style for In-App Purchase product views within a view.
- [realityViewCameraControls(_:)](https://developer.apple.com/documentation/swiftui/view/realityviewcameracontrols(_:)) — Adds gestures that control the position and direction of a virtual camera.
- [realityViewLayoutBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/realityviewlayoutbehavior(_:)) — A view modifier that controls the frame sizing and content alignment behavior for `RealityView`
- [rotation3DLayout(_:)](https://developer.apple.com/documentation/swiftui/view/rotation3dlayout(_:)) — Rotates a view with impacts to its frame in a containing layout
- [rotation3DLayout(_:axis:)](https://developer.apple.com/documentation/swiftui/view/rotation3dlayout(_:axis:)) — Rotates a view with impacts to its frame in a containing layout
- [safeAreaBar(edge:alignment:spacing:content:)](https://developer.apple.com/documentation/swiftui/view/safeareabar(edge:alignment:spacing:content:)) — Shows the specified content as a custom bar beside the modified view.
- [scaledToFill3D()](https://developer.apple.com/documentation/swiftui/view/scaledtofill3d()) — Scales this view to fill its parent.
- [scaledToFit3D()](https://developer.apple.com/documentation/swiftui/view/scaledtofit3d()) — Scales this view to fit its parent.
- [scrollEdgeEffectHidden(_:for:)](https://developer.apple.com/documentation/swiftui/view/scrolledgeeffecthidden(_:for:)) — Hides any scroll edge effects for scroll views within this hierarchy.
- [scrollEdgeEffectStyle(_:for:)](https://developer.apple.com/documentation/swiftui/view/scrolledgeeffectstyle(_:for:)) — Configures the scroll edge effect style for scroll views within this hierarchy.
- [scrollInputBehavior(_:for:)](https://developer.apple.com/documentation/swiftui/view/scrollinputbehavior(_:for:)) — Enables or disables scrolling in scrollable views when using particular inputs.
- [searchSelection(_:)](https://developer.apple.com/documentation/swiftui/view/searchselection(_:)) — Binds the selection of the search field associated with the nearest searchable modifier to the given [doc://com.apple.SwiftUI/documentation/SwiftUI/TextSelection](https://developer.apple.com/documentation/SwiftUI/TextSelection) value.
- [searchToolbarBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/searchtoolbarbehavior(_:)) — Configures the behavior for search in the toolbar.
- [sectionIndexLabel(_:)](https://developer.apple.com/documentation/swiftui/view/sectionindexlabel(_:)) — Sets the label that is used in a section index to point to this section, typically only a single character long.
- [signInWithAppleButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/signinwithapplebuttonstyle(_:)) — Sets the style used for displaying the control (see `SignInWithAppleButton.Style`).
- [sliderThumbVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/sliderthumbvisibility(_:)) — Sets the thumb visibility for `Slider`s within this view.
- [spatialOverlay(alignment:content:)](https://developer.apple.com/documentation/swiftui/view/spatialoverlay(alignment:content:)) — Adds secondary views within the 3D bounds of this view.
- [spatialOverlayPreferenceValue(_:alignment:_:)](https://developer.apple.com/documentation/swiftui/view/spatialoverlaypreferencevalue(_:alignment:_:)) — Uses the specified preference value from the view to produce another view occupying the same 3D space of the first view.
- [storeButton(_:for:)](https://developer.apple.com/documentation/swiftui/view/storebutton(_:for:)) — Specifies the visibility of auxiliary buttons that store view and subscription store view instances may use.
- [storeProductTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/storeproducttask(for:priority:action:)) — Declares the view as dependent on an In-App Purchase product and returns a modified view.
- [storeProductsTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/storeproductstask(for:priority:action:)) — Declares the view as dependent on a collection of In-App Purchase products and returns a modified view.
- [subscriptionIntroductoryOffer(applyOffer:compactJWS:)](https://developer.apple.com/documentation/swiftui/view/subscriptionintroductoryoffer(applyoffer:compactjws:)) — Selects the introductory offer eligibility preference to apply to a purchase a customer makes from a subscription store view.
- [subscriptionOfferViewButtonVisibility(_:for:)](https://developer.apple.com/documentation/swiftui/view/subscriptionofferviewbuttonvisibility(_:for:))
- [subscriptionOfferViewDetailAction(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionofferviewdetailaction(_:))
- [subscriptionOfferViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionofferviewstyle(_:))
- [subscriptionPromotionalOffer(offer:compactJWS:)](https://developer.apple.com/documentation/swiftui/view/subscriptionpromotionaloffer(offer:compactjws:)) — Selects a promotional offer to apply to a purchase a customer makes from a subscription store view.
- [subscriptionPromotionalOffer(offer:signature:)](https://developer.apple.com/documentation/swiftui/view/subscriptionpromotionaloffer(offer:signature:)) — Selects a promotional offer to apply to a purchase a customer makes from a subscription store view.
- [subscriptionStatusTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstatustask(for:priority:action:)) — Declares the view as dependent on the status of an auto-renewable subscription group, and returns a modified view.
- [subscriptionStoreButtonLabel(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorebuttonlabel(_:)) — Configures subscription store view instances within a view to use the provided button label.
- [subscriptionStoreControlBackground(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolbackground(_:)) — Set a standard effect to use for the background of subscription store view controls within the view.
- [subscriptionStoreControlIcon(icon:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolicon(icon:)) — Sets a view to use to decorate individual subscription options within a subscription store view.
- [subscriptionStoreControlStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolstyle(_:)) — Sets the control style for subscription store views within a view.
- [subscriptionStoreControlStyle(_:placement:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolstyle(_:placement:)) — Sets the control style and control placement for subscription store views within a view.
- [subscriptionStoreOptionGroupStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstoreoptiongroupstyle(_:)) — Sets the style subscription store views within this view use to display groups of subscription options.
- [subscriptionStorePickerItemBackground(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:)) — Sets the background style for picker items of the subscription store view instances within a view.
- [subscriptionStorePickerItemBackground(_:in:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:in:)) — Sets the background shape and style for subscription store view picker items within a view.
- [subscriptionStorePolicyDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(for:destination:)) — Configures a view as the destination for a policy button action in subscription store views.
- [subscriptionStorePolicyDestination(url:for:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(url:for:)) — Configures a URL as the destination for a policy button action in subscription store views.
- [subscriptionStorePolicyForegroundStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:)) — Sets the style for the terms of service and privacy policy buttons within a subscription store view.
- [subscriptionStorePolicyForegroundStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:_:)) — Sets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.
- [subscriptionStoreSignInAction(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstoresigninaction(_:)) — Adds an action to perform when a person uses the sign-in button on a subscription store view within a view.
- [symbolColorRenderingMode(_:)](https://developer.apple.com/documentation/swiftui/view/symbolcolorrenderingmode(_:)) — Sets the color rendering mode for symbol images.
- [symbolVariableValueMode(_:)](https://developer.apple.com/documentation/swiftui/view/symbolvariablevaluemode(_:)) — Sets the variable value mode mode for symbol images within this view.
- [tabBarMinimizeBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/tabbarminimizebehavior(_:)) — Sets the behavior for tab bar minimization.
- [tabViewBottomAccessory(content:)](https://developer.apple.com/documentation/swiftui/view/tabviewbottomaccessory(content:))
- [tabViewSearchActivation(_:)](https://developer.apple.com/documentation/swiftui/view/tabviewsearchactivation(_:)) — Configures the activation and deactivation behavior of search in the search tab.
- [tabletopGame(_:parent:automaticUpdate:)](https://developer.apple.com/documentation/swiftui/view/tabletopgame(_:parent:automaticupdate:)) — Adds a tabletop game to a view.
- [tabletopGame(_:parent:automaticUpdate:interaction:)](https://developer.apple.com/documentation/swiftui/view/tabletopgame(_:parent:automaticupdate:interaction:)) — Supplies a closure which returns a new interaction whenever needed.
- [task(id:name:executorPreference:priority:file:line:_:)](https://developer.apple.com/documentation/swiftui/view/task(id:name:executorpreference:priority:file:line:_:)) — Adds a task to perform before this view appears or when a specified value changes.
- [textContentType(_:)](https://developer.apple.com/documentation/swiftui/view/textcontenttype(_:)) — Sets the text content type for this view, which the system uses to offer suggestions while the user enters text on macOS.
- [textInputFormattingControlVisibility(_:for:)](https://developer.apple.com/documentation/swiftui/view/textinputformattingcontrolvisibility(_:for:)) — Define which system text formatting controls are available.
- [textRenderer(_:)](https://developer.apple.com/documentation/swiftui/view/textrenderer(_:)) — Returns a new view such that any text views within it will use `renderer` to draw themselves.
- [textSelectionAffinity(_:)](https://developer.apple.com/documentation/swiftui/view/textselectionaffinity(_:)) — Sets the direction of a selection or cursor relative to a text character.
- [tipAnchor(_:)](https://developer.apple.com/documentation/swiftui/view/tipanchor(_:)) — Sets a value for the specified tip anchor to be used to anchor a tip view to the `.bounds` of the view.
- [tipBackground(_:)](https://developer.apple.com/documentation/swiftui/view/tipbackground(_:)) — Sets the tip’s view background to a style. Currently this only applies to inline tips, not popover tips.
- [tipBackgroundInteraction(_:)](https://developer.apple.com/documentation/swiftui/view/tipbackgroundinteraction(_:)) — Controls whether people can interact with the view behind a presented tip.
- [tipCornerRadius(_:antialiased:)](https://developer.apple.com/documentation/swiftui/view/tipcornerradius(_:antialiased:)) — Sets the corner radius for an inline tip view.
- [tipImageSize(_:)](https://developer.apple.com/documentation/swiftui/view/tipimagesize(_:)) — Sets the size for a tip’s image.
- [tipImageStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:)) — Sets the style for a tip’s image.
- [tipImageStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:_:)) — Sets the style for a tip’s image.
- [tipImageStyle(_:_:_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:_:_:)) — Sets the style for a tip’s image.
- [tipViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tipviewstyle(_:)) — Sets the given style for TipView within the view hierarchy.
- [toolbarItemHidden(_:)](https://developer.apple.com/documentation/swiftui/view/toolbaritemhidden(_:)) — Hides an individual view within a control group toolbar item.
- [transactionPicker(isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/transactionpicker(ispresented:selection:)) — Presents a picker that selects a collection of transactions.
- [transactionTask(_:action:)](https://developer.apple.com/documentation/swiftui/view/transactiontask(_:action:)) — Provides a task to perform before this view appears
- [translationPresentation(isPresented:text:attachmentAnchor:arrowEdge:replacementAction:)](https://developer.apple.com/documentation/swiftui/view/translationpresentation(ispresented:text:attachmentanchor:arrowedge:replacementaction:)) — Presents a translation popover when a given condition is true.
- [translationTask(_:action:)](https://developer.apple.com/documentation/swiftui/view/translationtask(_:action:)) — Adds a task to perform before this view appears or when the translation configuration changes.
- [translationTask(source:target:action:)](https://developer.apple.com/documentation/swiftui/view/translationtask(source:target:action:)) — Adds a task to perform before this view appears or when the specified source or target languages change.
- [verifyIdentityWithWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/verifyidentitywithwalletbuttonstyle(_:)) — Sets the style to be used by the button. (see `PKIdentityButtonStyle`).
- [webViewBackForwardNavigationGestures(_:)](https://developer.apple.com/documentation/swiftui/view/webviewbackforwardnavigationgestures(_:)) — Determines whether horizontal swipe gestures trigger backward and forward page navigation.
- [webViewContentBackground(_:)](https://developer.apple.com/documentation/swiftui/view/webviewcontentbackground(_:)) — Specifies the visibility of the webpage’s natural background color within this view.
- [webViewContextMenu(menu:)](https://developer.apple.com/documentation/swiftui/view/webviewcontextmenu(menu:)) — Adds an item-based context menu to a WebView, replacing the default set of context menu items.
- [webViewElementFullscreenBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/webviewelementfullscreenbehavior(_:)) — Determines whether a web view can display content full screen.
- [webViewLinkPreviews(_:)](https://developer.apple.com/documentation/swiftui/view/webviewlinkpreviews(_:)) — Determines whether pressing a link displays a preview of the destination for the link.
- [webViewMagnificationGestures(_:)](https://developer.apple.com/documentation/swiftui/view/webviewmagnificationgestures(_:)) — Determines whether magnify gestures change the view’s magnification.
- [webViewOnScrollGeometryChange(for:of:action:)](https://developer.apple.com/documentation/swiftui/view/webviewonscrollgeometrychange(for:of:action:)) — Adds an action to be performed when a value, created from a scroll geometry, changes.
- [webViewScrollInputBehavior(_:for:)](https://developer.apple.com/documentation/swiftui/view/webviewscrollinputbehavior(_:for:)) — Enables or disables scrolling in web views when using particular inputs.
- [webViewScrollPosition(_:)](https://developer.apple.com/documentation/swiftui/view/webviewscrollposition(_:)) — Associates a binding to a scroll position with the web view.
- [webViewTextSelection(_:)](https://developer.apple.com/documentation/swiftui/view/webviewtextselection(_:)) — Determines whether to allow people to select or otherwise interact with text.
- [windowResizeAnchor(_:)](https://developer.apple.com/documentation/swiftui/view/windowresizeanchor(_:)) — Sets the window anchor point used when the size of the view changes such that the window must resize.
- [windowToolbarFullScreenVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/windowtoolbarfullscreenvisibility(_:)) — Configures the visibility of the window toolbar when the window enters full screen mode.
- [workoutPreview(_:isPresented:)](https://developer.apple.com/documentation/swiftui/view/workoutpreview(_:ispresented:)) — Presents a preview of the workout contents as a modal sheet
- [writingDirection(strategy:)](https://developer.apple.com/documentation/swiftui/view/writingdirection(strategy:)) — A modifier for the default text writing direction strategy in the view hierarchy.
- [writingToolsAffordanceVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/writingtoolsaffordancevisibility(_:)) — Specifies whether the system should show the Writing Tools affordance for text input views affected by the environment.
- [writingToolsBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/writingtoolsbehavior(_:)) — Specifies the Writing Tools behavior for text and text input in the environment.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/View](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/View)*
--- END FILE ---

--- FILE: Technology-specific-views.md ---
# Technology-specific views

**Use SwiftUI views that other Apple frameworks provide.**


## Overview

To access SwiftUI views that another framework defines, import both SwiftUI and the other framework into the file where you use the view. You can find the framework to import by looking at the availability information on the view’s documentation page.

![Image](technology-specific-views-hero)

For example, to use the [doc://com.apple.documentation/documentation/MapKit/Map](https://developer.apple.com/documentation/MapKit/Map) view in your app, import both SwiftUI and MapKit.

```swift
import SwiftUI
import MapKit

struct MyMapView: View {
    // Center the map on Joshua Tree National Park.
    var region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: 34.011_286, longitude: -116.166_868),
            span: MKCoordinateSpan(latitudeDelta: 0.2, longitudeDelta: 0.2)
        )

    var body: some View {
        Map(initialPosition: .region(region))
    }
}
```

For design guidance, see doc://com.apple.documentation/design/Human-Interface-Guidelines/technologies in the Human Interface Guidelines.

## Topics

### Displaying web content

- [WebView](https://developer.apple.com/documentation/WebKit/WebView-swift.struct) — A view that displays some web content.
- [WebPage](https://developer.apple.com/documentation/WebKit/WebPage) — An object that controls and manages the behavior of interactive web content.
- [webViewBackForwardNavigationGestures(_:)](https://developer.apple.com/documentation/swiftui/view/webviewbackforwardnavigationgestures(_:)) — Determines whether horizontal swipe gestures trigger backward and forward page navigation.
- [webViewContentBackground(_:)](https://developer.apple.com/documentation/swiftui/view/webviewcontentbackground(_:)) — Specifies the visibility of the webpage’s natural background color within this view.
- [webViewContextMenu(menu:)](https://developer.apple.com/documentation/swiftui/view/webviewcontextmenu(menu:)) — Adds an item-based context menu to a WebView, replacing the default set of context menu items.
- [webViewElementFullscreenBehavior(_:)](https://developer.apple.com/documentation/swiftui/view/webviewelementfullscreenbehavior(_:)) — Determines whether a web view can display content full screen.
- [webViewLinkPreviews(_:)](https://developer.apple.com/documentation/swiftui/view/webviewlinkpreviews(_:)) — Determines whether pressing a link displays a preview of the destination for the link.
- [webViewMagnificationGestures(_:)](https://developer.apple.com/documentation/swiftui/view/webviewmagnificationgestures(_:)) — Determines whether magnify gestures change the view’s magnification.
- [webViewOnScrollGeometryChange(for:of:action:)](https://developer.apple.com/documentation/swiftui/view/webviewonscrollgeometrychange(for:of:action:)) — Adds an action to be performed when a value, created from a scroll geometry, changes.
- [webViewScrollInputBehavior(_:for:)](https://developer.apple.com/documentation/swiftui/view/webviewscrollinputbehavior(_:for:)) — Enables or disables scrolling in web views when using particular inputs.
- [webViewScrollPosition(_:)](https://developer.apple.com/documentation/swiftui/view/webviewscrollposition(_:)) — Associates a binding to a scroll position with the web view.
- [webViewTextSelection(_:)](https://developer.apple.com/documentation/swiftui/view/webviewtextselection(_:)) — Determines whether to allow people to select or otherwise interact with text.
### Accessing Apple Pay and Wallet

- [PayWithApplePayButton](https://developer.apple.com/documentation/PassKit/PayWithApplePayButton) — A type that provides a button to pay with Apple pay.
- [AddPassToWalletButton](https://developer.apple.com/documentation/PassKit/AddPassToWalletButton) — A type that provides a button that enables people to add a new or existing pass to Apple Wallet.
- [VerifyIdentityWithWalletButton](https://developer.apple.com/documentation/PassKit/VerifyIdentityWithWalletButton) — A type that displays a button to present the identity verification flow.
- [addOrderToWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/addordertowalletbuttonstyle(_:)) — Sets the button’s style.
- [addPassToWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/addpasstowalletbuttonstyle(_:)) — Sets the style to be used by the button. (see `PKAddPassButtonStyle`).
- [onApplePayCouponCodeChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepaycouponcodechange(perform:)) — Called when a user has entered or updated a coupon code. This is required if the user is being asked to provide a coupon code.
- [onApplePayPaymentMethodChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepaypaymentmethodchange(perform:)) — Called when a payment method has changed and asks for an update payment request. If this modifier isn’t provided Wallet will assume the payment method is valid.
- [onApplePayShippingContactChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepayshippingcontactchange(perform:)) — Called when a user selected a shipping address. This is required if the user is being asked to provide a shipping contact.
- [onApplePayShippingMethodChange(perform:)](https://developer.apple.com/documentation/swiftui/view/onapplepayshippingmethodchange(perform:)) — Called when a user selected a shipping method. This is required if the user is being asked to provide a shipping method.
- [payLaterViewAction(_:)](https://developer.apple.com/documentation/swiftui/view/paylaterviewaction(_:)) — Sets the action on the PayLaterView. See `PKPayLaterAction`.
- [payLaterViewDisplayStyle(_:)](https://developer.apple.com/documentation/swiftui/view/paylaterviewdisplaystyle(_:)) — Sets the display style on the PayLaterView. See `PKPayLaterDisplayStyle`.
- [payWithApplePayButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/paywithapplepaybuttonstyle(_:)) — Sets the style to be used by the button. (see `PayWithApplePayButtonStyle`).
- [verifyIdentityWithWalletButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/verifyidentitywithwalletbuttonstyle(_:)) — Sets the style to be used by the button. (see `PKIdentityButtonStyle`).
- [AsyncShareablePassConfiguration](https://developer.apple.com/documentation/PassKit/AsyncShareablePassConfiguration)
- [transactionTask(_:action:)](https://developer.apple.com/documentation/swiftui/view/transactiontask(_:action:)) — Provides a task to perform before this view appears
### Authorizing and authenticating

- [LocalAuthenticationView](https://developer.apple.com/documentation/LocalAuthentication/LocalAuthenticationView) — A SwiftUI view that displays an authentication interface.
- [SignInWithAppleButton](https://developer.apple.com/documentation/AuthenticationServices/SignInWithAppleButton) — A SwiftUI view that creates the Sign in with Apple button for display.
- [signInWithAppleButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/signinwithapplebuttonstyle(_:)) — Sets the style used for displaying the control (see `SignInWithAppleButton.Style`).
- [authorizationController](https://developer.apple.com/documentation/swiftui/environmentvalues/authorizationcontroller) — A value provided in the SwiftUI environment that views can use to perform authorization requests.
- [webAuthenticationSession](https://developer.apple.com/documentation/swiftui/environmentvalues/webauthenticationsession) — A value provided in the SwiftUI environment that views can use to authenticate a user through a web service.
### Configuring Family Sharing

- [FamilyActivityPicker](https://developer.apple.com/documentation/FamilyControls/FamilyActivityPicker) — A view in which users specify applications, web domains, and categories without revealing their choices to the app.
- [familyActivityPicker(isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/familyactivitypicker(ispresented:selection:)) — Presents an activity picker view as a sheet.
- [familyActivityPicker(headerText:footerText:isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/familyactivitypicker(headertext:footertext:ispresented:selection:)) — Presents an activity picker view as a sheet.
### Reporting on device activity

- [DeviceActivityReport](https://developer.apple.com/documentation/DeviceActivity/DeviceActivityReport) — A view that reports the user’s application, category, and web domain activity in a privacy-preserving way.
### Working with managed devices

- [managedContentStyle(_:)](https://developer.apple.com/documentation/swiftui/view/managedcontentstyle(_:)) — Applies a managed content style to the view.
- [automatedDeviceEnrollmentAddition(isPresented:)](https://developer.apple.com/documentation/swiftui/view/automateddeviceenrollmentaddition(ispresented:)) — Presents a modal view that enables users to add devices to their organization.
### Creating graphics

- [Chart](https://developer.apple.com/documentation/Charts/Chart) — A SwiftUI view that displays a chart.
- [SceneView](https://developer.apple.com/documentation/SceneKit/SceneView) — A SwiftUI view for displaying 3D SceneKit content.
- [SpriteView](https://developer.apple.com/documentation/SpriteKit/SpriteView) — A SwiftUI view that renders a SpriteKit scene.
### Getting location information

- [LocationButton](https://developer.apple.com/documentation/CoreLocationUI/LocationButton) — A SwiftUI button that grants one-time location authorization.
- [Map](https://developer.apple.com/documentation/MapKit/Map) — A view that displays an embedded map interface.
- [mapStyle(_:)](https://developer.apple.com/documentation/swiftui/view/mapstyle(_:)) — Specifies the map style to be used.
- [mapScope(_:)](https://developer.apple.com/documentation/swiftui/view/mapscope(_:)) — Creates a mapScope that SwiftUI uses to connect map controls to an associated map.
- [mapFeatureSelectionDisabled(_:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectiondisabled(_:)) — Specifies which map features should have selection disabled.
- [mapFeatureSelectionAccessory(_:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectionaccessory(_:)) — Specifies the selection accessory to display for a `MapFeature`
- [mapFeatureSelectionContent(content:)](https://developer.apple.com/documentation/swiftui/view/mapfeatureselectioncontent(content:)) — Specifies a custom presentation for the currently selected feature.
- [mapControls(_:)](https://developer.apple.com/documentation/swiftui/view/mapcontrols(_:)) — Configures all `Map` views in the associated environment to have standard size and position controls
- [mapControlVisibility(_:)](https://developer.apple.com/documentation/swiftui/view/mapcontrolvisibility(_:)) — Configures all Map controls in the environment to have the specified visibility
- [mapCameraKeyframeAnimator(trigger:keyframes:)](https://developer.apple.com/documentation/swiftui/view/mapcamerakeyframeanimator(trigger:keyframes:)) — Uses the given keyframes to animate the camera of a `Map` when the given trigger value changes.
- [lookAroundViewer(isPresented:scene:allowsNavigation:showsRoadLabels:pointsOfInterest:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/lookaroundviewer(ispresented:scene:allowsnavigation:showsroadlabels:pointsofinterest:ondismiss:))
- [lookAroundViewer(isPresented:initialScene:allowsNavigation:showsRoadLabels:pointsOfInterest:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/lookaroundviewer(ispresented:initialscene:allowsnavigation:showsroadlabels:pointsofinterest:ondismiss:))
- [onMapCameraChange(frequency:_:)](https://developer.apple.com/documentation/swiftui/view/onmapcamerachange(frequency:_:)) — Performs an action when Map camera framing changes
- [mapItemDetailPopover(isPresented:item:displaysMap:attachmentAnchor:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(ispresented:item:displaysmap:attachmentanchor:)) — Presents a map item detail popover.
- [mapItemDetailPopover(isPresented:item:displaysMap:attachmentAnchor:arrowEdge:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(ispresented:item:displaysmap:attachmentanchor:arrowedge:)) — Presents a map item detail popover.
- [mapItemDetailPopover(item:displaysMap:attachmentAnchor:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(item:displaysmap:attachmentanchor:)) — Presents a map item detail popover.
- [mapItemDetailPopover(item:displaysMap:attachmentAnchor:arrowEdge:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailpopover(item:displaysmap:attachmentanchor:arrowedge:)) — Presents a map item detail popover.
- [mapItemDetailSheet(isPresented:item:displaysMap:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailsheet(ispresented:item:displaysmap:)) — Presents a map item detail sheet.
- [mapItemDetailSheet(item:displaysMap:)](https://developer.apple.com/documentation/swiftui/view/mapitemdetailsheet(item:displaysmap:)) — Presents a map item detail sheet.
### Displaying media

- [CameraView](https://developer.apple.com/documentation/HomeKit/CameraView) — A SwiftUI view into which a video stream or an image snapshot is rendered.
- [NowPlayingView](https://developer.apple.com/documentation/WatchKit/NowPlayingView) — A view that displays the system’s Now Playing interface so that the user can control audio.
- [VideoPlayer](https://developer.apple.com/documentation/AVKit/VideoPlayer) — A view that displays content from a player and a native user interface to control playback.
- [continuityDevicePicker(isPresented:onDidConnect:)](https://developer.apple.com/documentation/swiftui/view/continuitydevicepicker(ispresented:ondidconnect:)) — A `continuityDevicePicker` should be used to discover and connect nearby continuity device through a button interface or other form of activation. On tvOS, this presents a fullscreen continuity device picker experience when selected. The modal view covers as much the screen of `self` as possible when a given condition is true.
- [cameraAnchor(isActive:)](https://developer.apple.com/documentation/swiftui/view/cameraanchor(isactive:)) — Specifies the view that should act as the virtual camera for Apple Vision Pro 2D Persona stream.
### Selecting photos

- [PhotosPicker](https://developer.apple.com/documentation/PhotosUI/PhotosPicker) — A view that displays a Photos picker for choosing assets from the photo library.
- [photosPicker(isPresented:selection:matching:preferredItemEncoding:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:matching:preferreditemencoding:)) — Presents a Photos picker that selects a `PhotosPickerItem`.
- [photosPicker(isPresented:selection:matching:preferredItemEncoding:photoLibrary:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:matching:preferreditemencoding:photolibrary:)) — Presents a Photos picker that selects a `PhotosPickerItem` from a given photo library.
- [photosPicker(isPresented:selection:maxSelectionCount:selectionBehavior:matching:preferredItemEncoding:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:maxselectioncount:selectionbehavior:matching:preferreditemencoding:)) — Presents a Photos picker that selects a collection of `PhotosPickerItem`.
- [photosPicker(isPresented:selection:maxSelectionCount:selectionBehavior:matching:preferredItemEncoding:photoLibrary:)](https://developer.apple.com/documentation/swiftui/view/photospicker(ispresented:selection:maxselectioncount:selectionbehavior:matching:preferreditemencoding:photolibrary:)) — Presents a Photos picker that selects a collection of `PhotosPickerItem` from a given photo library.
- [photosPickerAccessoryVisibility(_:edges:)](https://developer.apple.com/documentation/swiftui/view/photospickeraccessoryvisibility(_:edges:)) — Sets the accessory visibility of the Photos picker. Accessories include anything between the content and the edge, like the navigation bar or the sidebar.
- [photosPickerDisabledCapabilities(_:)](https://developer.apple.com/documentation/swiftui/view/photospickerdisabledcapabilities(_:)) — Disables capabilities of the Photos picker.
- [photosPickerStyle(_:)](https://developer.apple.com/documentation/swiftui/view/photospickerstyle(_:)) — Sets the mode of the Photos picker.
### Previewing content

- [quickLookPreview(_:)](https://developer.apple.com/documentation/swiftui/view/quicklookpreview(_:)) — Presents a Quick Look preview of the contents of a single URL.
- [quickLookPreview(_:in:)](https://developer.apple.com/documentation/swiftui/view/quicklookpreview(_:in:)) — Presents a Quick Look preview of the URLs you provide.
### Interacting with networked devices

- [DevicePicker](https://developer.apple.com/documentation/DeviceDiscoveryUI/DevicePicker) — A SwiftUI view that displays other devices on the network, and creates an encrypted connection to a copy of your app running on that device.
- [devicePickerSupports](https://developer.apple.com/documentation/swiftui/environmentvalues/devicepickersupports) — Checks for support to present a DevicePicker.
### Configuring a Live Activity

- [activitySystemActionForegroundColor(_:)](https://developer.apple.com/documentation/swiftui/view/activitysystemactionforegroundcolor(_:)) — The text color for the auxiliary action button that the system shows next to a Live Activity on the Lock Screen.
- [activityBackgroundTint(_:)](https://developer.apple.com/documentation/swiftui/view/activitybackgroundtint(_:)) — Sets the tint color for the background of a Live Activity that appears on the Lock Screen.
- [isActivityFullscreen](https://developer.apple.com/documentation/swiftui/environmentvalues/isactivityfullscreen) — A Boolean value that indicates whether the Live Activity appears in a full-screen presentation.
- [activityFamily](https://developer.apple.com/documentation/swiftui/environmentvalues/activityfamily) — The size family of the current Live Activity.
### Interacting with the App Store and Apple Music

- [appStoreOverlay(isPresented:configuration:)](https://developer.apple.com/documentation/swiftui/view/appstoreoverlay(ispresented:configuration:)) — Presents a StoreKit overlay when a given condition is true.
- [manageSubscriptionsSheet(isPresented:)](https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:))
- [refundRequestSheet(for:isPresented:onDismiss:)](https://developer.apple.com/documentation/swiftui/view/refundrequestsheet(for:ispresented:ondismiss:)) — Display the refund request sheet for the given transaction.
- [offerCodeRedemption(isPresented:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/offercoderedemption(ispresented:oncompletion:)) — Presents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.
- [musicSubscriptionOffer(isPresented:options:onLoadCompletion:)](https://developer.apple.com/documentation/swiftui/view/musicsubscriptionoffer(ispresented:options:onloadcompletion:)) — Initiates the process of presenting a sheet with subscription offers for Apple Music when the `isPresented` binding is `true`.
- [currentEntitlementTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/currententitlementtask(for:priority:action:)) — Declares the view as dependent on the entitlement of an In-App Purchase product, and returns a modified view.
- [inAppPurchaseOptions(_:)](https://developer.apple.com/documentation/swiftui/view/inapppurchaseoptions(_:)) — Add a function to call before initiating a purchase from StoreKit view within this view, providing a set of options for the purchase.
- [manageSubscriptionsSheet(isPresented:subscriptionGroupID:)](https://developer.apple.com/documentation/swiftui/view/managesubscriptionssheet(ispresented:subscriptiongroupid:))
- [onInAppPurchaseCompletion(perform:)](https://developer.apple.com/documentation/swiftui/view/oninapppurchasecompletion(perform:)) — Add an action to perform when a purchase initiated from a StoreKit view within this view completes.
- [onInAppPurchaseStart(perform:)](https://developer.apple.com/documentation/swiftui/view/oninapppurchasestart(perform:)) — Add an action to perform when a user triggers the purchase button on a StoreKit view within this view.
- [productIconBorder()](https://developer.apple.com/documentation/swiftui/view/producticonborder()) — Adds a standard border to an in-app purchase product’s icon .
- [productViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/productviewstyle(_:)) — Sets the style for In-App Purchase product views within a view.
- [productDescription(_:)](https://developer.apple.com/documentation/swiftui/view/productdescription(_:)) — Configure the visibility of labels displaying an in-app purchase product description within the view.
- [storeButton(_:for:)](https://developer.apple.com/documentation/swiftui/view/storebutton(_:for:)) — Specifies the visibility of auxiliary buttons that store view and subscription store view instances may use.
- [storeProductTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/storeproducttask(for:priority:action:)) — Declares the view as dependent on an In-App Purchase product and returns a modified view.
- [storeProductsTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/storeproductstask(for:priority:action:)) — Declares the view as dependent on a collection of In-App Purchase products and returns a modified view.
- [subscriptionStatusTask(for:priority:action:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstatustask(for:priority:action:)) — Declares the view as dependent on the status of an auto-renewable subscription group, and returns a modified view.
- [subscriptionStoreButtonLabel(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorebuttonlabel(_:)) — Configures subscription store view instances within a view to use the provided button label.
- [subscriptionStoreControlIcon(icon:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolicon(icon:)) — Sets a view to use to decorate individual subscription options within a subscription store view.
- [subscriptionStoreControlStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolstyle(_:)) — Sets the control style for subscription store views within a view.
- [subscriptionStoreControlStyle(_:placement:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolstyle(_:placement:)) — Sets the control style and control placement for subscription store views within a view.
- [subscriptionStoreOptionGroupStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstoreoptiongroupstyle(_:)) — Sets the style subscription store views within this view use to display groups of subscription options.
- [subscriptionStorePickerItemBackground(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:)) — Sets the background style for picker items of the subscription store view instances within a view.
- [subscriptionStorePickerItemBackground(_:in:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepickeritembackground(_:in:)) — Sets the background shape and style for subscription store view picker items within a view.
- [subscriptionStorePolicyDestination(for:destination:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(for:destination:)) — Configures a view as the destination for a policy button action in subscription store views.
- [subscriptionStorePolicyDestination(url:for:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicydestination(url:for:)) — Configures a URL as the destination for a policy button action in subscription store views.
- [subscriptionStorePolicyForegroundStyle(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:)) — Sets the style for the terms of service and privacy policy buttons within a subscription store view.
- [subscriptionStorePolicyForegroundStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorepolicyforegroundstyle(_:_:)) — Sets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.
- [subscriptionStoreSignInAction(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstoresigninaction(_:)) — Adds an action to perform when a person uses the sign-in button on a subscription store view within a view.
- [subscriptionStoreControlBackground(_:)](https://developer.apple.com/documentation/swiftui/view/subscriptionstorecontrolbackground(_:)) — Set a standard effect to use for the background of subscription store view controls within the view.
- [subscriptionPromotionalOffer(offer:signature:)](https://developer.apple.com/documentation/swiftui/view/subscriptionpromotionaloffer(offer:signature:)) — Selects a promotional offer to apply to a purchase a customer makes from a subscription store view.
- [preferredSubscriptionOffer(_:)](https://developer.apple.com/documentation/swiftui/view/preferredsubscriptionoffer(_:)) — Selects a subscription offer to apply to a purchase that a customer makes from a subscription store view, a store view, or a product view.
### Accessing health data

- [healthDataAccessRequest(store:objectType:predicate:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:objecttype:predicate:trigger:completion:)) — Asynchronously requests permission to read a data type that requires per-object authorization (such as vision prescriptions).
- [healthDataAccessRequest(store:readTypes:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:readtypes:trigger:completion:)) — Requests permission to read the specified HealthKit data types.
- [healthDataAccessRequest(store:shareTypes:readTypes:trigger:completion:)](https://developer.apple.com/documentation/swiftui/view/healthdataaccessrequest(store:sharetypes:readtypes:trigger:completion:)) — Requests permission to save and read the specified HealthKit data types.
- [workoutPreview(_:isPresented:)](https://developer.apple.com/documentation/swiftui/view/workoutpreview(_:ispresented:)) — Presents a preview of the workout contents as a modal sheet
### Providing tips

- [popoverTip(_:arrowEdge:action:)](https://developer.apple.com/documentation/swiftui/view/popovertip(_:arrowedge:action:)) — Presents a popover tip on the modified view.
- [tipBackground(_:)](https://developer.apple.com/documentation/swiftui/view/tipbackground(_:)) — Sets the tip’s view background to a style. Currently this only applies to inline tips, not popover tips.
- [tipCornerRadius(_:antialiased:)](https://developer.apple.com/documentation/swiftui/view/tipcornerradius(_:antialiased:)) — Sets the corner radius for an inline tip view.
- [tipImageSize(_:)](https://developer.apple.com/documentation/swiftui/view/tipimagesize(_:)) — Sets the size for a tip’s image.
- [tipViewStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tipviewstyle(_:)) — Sets the given style for TipView within the view hierarchy.
- [tipImageStyle(_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:)) — Sets the style for a tip’s image.
- [tipImageStyle(_:_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:_:)) — Sets the style for a tip’s image.
- [tipImageStyle(_:_:_:)](https://developer.apple.com/documentation/swiftui/view/tipimagestyle(_:_:_:)) — Sets the style for a tip’s image.
### Showing a translation

- [translationPresentation(isPresented:text:attachmentAnchor:arrowEdge:replacementAction:)](https://developer.apple.com/documentation/swiftui/view/translationpresentation(ispresented:text:attachmentanchor:arrowedge:replacementaction:)) — Presents a translation popover when a given condition is true.
- [translationTask(_:action:)](https://developer.apple.com/documentation/swiftui/view/translationtask(_:action:)) — Adds a task to perform before this view appears or when the translation configuration changes.
- [translationTask(source:target:action:)](https://developer.apple.com/documentation/swiftui/view/translationtask(source:target:action:)) — Adds a task to perform before this view appears or when the specified source or target languages change.
### Presenting journaling suggestions

- [journalingSuggestionsPicker(isPresented:onCompletion:)](https://developer.apple.com/documentation/swiftui/view/journalingsuggestionspicker(ispresented:oncompletion:)) — Presents a visual picker interface that contains events and images that a person can select to retrieve more information.
### Managing contact access

- [contactAccessButtonCaption(_:)](https://developer.apple.com/documentation/swiftui/view/contactaccessbuttoncaption(_:))
- [contactAccessButtonStyle(_:)](https://developer.apple.com/documentation/swiftui/view/contactaccessbuttonstyle(_:))
- [contactAccessPicker(isPresented:completionHandler:)](https://developer.apple.com/documentation/swiftui/view/contactaccesspicker(ispresented:completionhandler:)) — Modally present UI which allows the user to select which contacts your app has access to.
### Handling game controller events

- [handlesGameControllerEvents(matching:)](https://developer.apple.com/documentation/swiftui/view/handlesgamecontrollerevents(matching:)) — Specifies the game controllers events which should be delivered through the GameController framework when the view, or one of its descendants has focus.
### Creating a tabletop game

- [tabletopGame(_:parent:automaticUpdate:)](https://developer.apple.com/documentation/swiftui/view/tabletopgame(_:parent:automaticupdate:)) — Adds a tabletop game to a view.
- [tabletopGame(_:parent:automaticUpdate:interaction:)](https://developer.apple.com/documentation/swiftui/view/tabletopgame(_:parent:automaticupdate:interaction:)) — Supplies a closure which returns a new interaction whenever needed.
### Configuring camera controls

- [realityViewCameraControls](https://developer.apple.com/documentation/swiftui/environmentvalues/realityviewcameracontrols) — The camera controls for the reality view.
- [realityViewCameraControls(_:)](https://developer.apple.com/documentation/swiftui/view/realityviewcameracontrols(_:)) — Adds gestures that control the position and direction of a virtual camera.
### Interacting with transactions

- [transactionPicker(isPresented:selection:)](https://developer.apple.com/documentation/swiftui/view/transactionpicker(ispresented:selection:)) — Presents a picker that selects a collection of transactions.

---

*Source: [https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Technology-specific-views](https://developer.apple.com/documentation/com.apple.SwiftUI/documentation/SwiftUI/Technology-specific-views)*
--- END FILE ---

--- FILE: Core-Data.md ---
# Core Data

**Persist or cache data on a single device, or sync data to multiple devices with CloudKit.**

## Availability

- **iOS** 3.0+
- **iPadOS** 3.0+
- **Mac Catalyst** 13.0+
- **macOS** 10.4+
- **tvOS** 9.0+
- **visionOS** 1.0+
- **watchOS** 2.0+


## Overview

Use Core Data to save your application’s permanent data for offline use, to cache temporary data, and to add undo functionality to your app on a single device. To sync data across multiple devices in a single iCloud account, Core Data automatically mirrors your schema to a CloudKit container.

Through Core Data’s Data Model editor, you define your data’s types and relationships, and generate respective class definitions. Core Data can then manage object instances at runtime to provide the following features.


### Persistence

Core Data abstracts the details of mapping your objects to a store, making it easy to save data from Swift and Objective-C without administering a database directly.

![Image](media-3119932)


### Undo and redo of individual and batched changes

Core Data’s undo manager tracks changes and can roll them back individually, in groups, or all at once, making it easy to add undo and redo support to your app.

![Image](media-3118362)


### Background data tasks

Perform potentially UI-blocking data tasks, like parsing JSON into objects, in the background. You can then cache or store the results to reduce server roundtrips.

![Image](media-3118359)


### View synchronization

Core Data also helps keep your views and data synchronized by providing data sources for table and collection views.


### Versioning and migration

Core Data includes mechanisms for versioning your data model and migrating user data as your app evolves.

## Topics

### Essentials

- [Creating a Core Data model](https://developer.apple.com/documentation/coredata/creating-a-core-data-model) — Define your app’s object structure with a data model file.
- [Setting up a Core Data stack](https://developer.apple.com/documentation/coredata/setting-up-a-core-data-stack) — Set up the classes that manage and persist your app’s objects.
- [Core Data stack](https://developer.apple.com/documentation/coredata/core-data-stack) — Manage and persist your app’s model layer.
- [Handling Different Data Types in Core Data](https://developer.apple.com/documentation/coredata/handling-different-data-types-in-core-data) — Create, store, and present records for a variety of data types.
- [Linking Data Between Two Core Data Stores](https://developer.apple.com/documentation/coredata/linking-data-between-two-core-data-stores) — Organize data in two different stores and implement a link between them.
### Data modeling

- [Modeling data](https://developer.apple.com/documentation/coredata/modeling-data) — Configure the data model file to contain your app’s object graph.
- [Core Data model](https://developer.apple.com/documentation/coredata/core-data-model) — Describe your app’s object structure.
### Fetch requests

- [NSFetchRequest](https://developer.apple.com/documentation/coredata/nsfetchrequest) — A description of search criteria used to retrieve data from a persistent store.
- [NSAsynchronousFetchRequest](https://developer.apple.com/documentation/coredata/nsasynchronousfetchrequest) — A fetch request that retrieves results asynchronously and supports progress notification.
- [NSAsynchronousFetchResult](https://developer.apple.com/documentation/coredata/nsasynchronousfetchresult) — A fetch result object that encompasses the response from an executed asynchronous fetch request.
- [NSFetchedResultsController](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller) — A controller that you use to manage the results of a Core Data fetch request and to display data to the user.
### SwiftData migration and coexistence

- [Adopting SwiftData for a Core Data app](https://developer.apple.com/documentation/coredata/adopting-swiftdata-for-a-core-data-app) — Persist data in your app intuitively with the Swift native persistence framework.
### CloudKit mirroring

- [Mirroring a Core Data store with CloudKit](https://developer.apple.com/documentation/coredata/mirroring-a-core-data-store-with-cloudkit) — Back user interfaces with a local replica of a CloudKit private database.
- [Synchronizing a local store to the cloud](https://developer.apple.com/documentation/coredata/synchronizing-a-local-store-to-the-cloud) — Share data between a user’s devices and other iCloud users.
- [NSPersistentCloudKitContainer](https://developer.apple.com/documentation/coredata/nspersistentcloudkitcontainer) — A container that encapsulates the Core Data stack in your app, and mirrors select persistent stores to a CloudKit private database.
- [NSPersistentCloudKitContainerOptions](https://developer.apple.com/documentation/coredata/nspersistentcloudkitcontaineroptions) — An object that customizes how a store description aligns with a CloudKit database.
- [Sharing Core Data objects between iCloud users](https://developer.apple.com/documentation/coredata/sharing-core-data-objects-between-icloud-users) — Use Core Data and CloudKit to synchronize data between devices of an iCloud user and share data between different iCloud users.
### Change processing

- [Accessing data when the store changes](https://developer.apple.com/documentation/coredata/accessing-data-when-the-store-changes) — Guarantee that a context won’t see store changes until you tell it to look.
- [Consuming relevant store changes](https://developer.apple.com/documentation/coredata/consuming-relevant-store-changes) — Filter store transactions for changes relevant to the current view.
- [Persistent history](https://developer.apple.com/documentation/coredata/persistent-history) — Use persistent history tracking to determine what changes have occurred in the store since the enabling of persistent history tracking.
### Background tasks

- [Using Core Data in the background](https://developer.apple.com/documentation/coredata/using-core-data-in-the-background) — Use Core Data in both a single-threaded and multithreaded app.
- [Loading and Displaying a Large Data Feed](https://developer.apple.com/documentation/swiftui/loading_and_displaying_a_large_data_feed) — Consume data in the background, and lower memory use by batching imports and preventing duplicate records.
- [Conflict resolution](https://developer.apple.com/documentation/coredata/conflict-resolution) — Detect and resolve conflicts that occur when data is changed on multiple threads.
- [Batch processing](https://developer.apple.com/documentation/coredata/batch-processing) — Use batch processes to manage large data changes.
### Data model migration

- [Migrating your data model automatically](https://developer.apple.com/documentation/coredata/migrating-your-data-model-automatically) — Enable lightweight migrations to keep your data model and the underlying data in a consistent state.
- [Staged migrations](https://developer.apple.com/documentation/coredata/staged-migrations) — Migrate complex data models containing changes that are incompatible with lightweight migrations.
- [Manual migrations](https://developer.apple.com/documentation/coredata/manual-migrations) — Migrate elaborate data models with changes that go beyond the capabilities of both lightweight and staged migrations.
### Related types

- [Core Data Constants](https://developer.apple.com/documentation/coredata/core-data-constants) — Keys to use with persistent stores and notifications from Core Data.

---

*Source: [https://developer.apple.com/documentation/com.apple.coredata/documentation/CoreData](https://developer.apple.com/documentation/com.apple.coredata/documentation/CoreData)*
--- END FILE ---

--- FILE: accessibility.md ---
---
title: Accessibility | Apple Developer Documentation
source_url: https://developer.apple.com/design/human-interface-guidelines/accessibility
scraped_date: '2025-10-25T18:04:03.284807Z'
extraction_method: Chrome DevTools MCP Server
content_length: 19147
filename: accessibility.md
---

# Accessibility | Apple Developer Documentation

Accessibility
Accessible user interfaces empower everyone to have a great experience with your app or game.

When you design for accessibility, you reach a larger audience and create a more inclusive experience. An accessible interface allows people to experience your app or game regardless of their capabilities or how they use their devices. Accessibility makes information and interactions available to everyone. An accessible interface is:

Intuitive. Your interface uses familiar and consistent interactions that make tasks straightforward to perform.

Perceivable. Your interface doesn't rely on any single method to convey information. People can access and interact with your content, whether they use sight, hearing, speech, or touch.

Adaptable. Your interface adapts to how people want to use their device, whether by supporting system accessibility features or letting people personalize settings.

As you design your app, audit the accessibility of your interface. Use Accessibility Inspector to highlight accessibility issues with your interface and to understand how your app represents itself to people using system accessibility features. You can also communicate how accessible your app is on the App Store using Accessibility Nutrition Labels. To learn more about how to evaluate and indicate accessibility feature support, see Accessibility Nutrition Labels in App Store Connect help.

Vision

The people who use your interface may be blind, color blind, or have low vision or light sensitivity. They may also be in situations where lighting conditions and screen brightness affect their ability to interact with your interface.

Support larger text sizes. Make sure people can adjust the size of your text or icons to make them more legible, visible, and comfortable to read. Ideally, give people the option to enlarge text by at least 200 percent (or 140 percent in watchOS apps). Your interface can support font size enlargement either through custom UI, or by adopting Dynamic Type. Dynamic Type is a systemwide setting that lets people adjust the size of text for comfort and legibility. For more guidance, see Supporting Dynamic Type.

Use recommended defaults for custom type sizes. Each platform has different default and minimum sizes for system-defined type styles to promote readability. If you're using custom type styles, follow the recommended defaults.

Platform

	

Default size

	

Minimum size




iOS, iPadOS

	

17 pt

	

11 pt




macOS

	

13 pt

	

10 pt




tvOS

	

29 pt

	

23 pt




visionOS

	

17 pt

	

12 pt




watchOS

	

16 pt

	

12 pt

Bear in mind that font weight can also impact how easy text is to read. If you're using a custom font with a thin weight, aim for larger than the recommended sizes to increase legibility. For more guidance, see Typography.

Thicker weights are easier to read for smaller font sizes.

Consider increasing the font size when using a thin weight.

Strive to meet color contrast minimum standards. To ensure all information in your app is legible, it's important that there's enough contrast between foreground text and icons and background colors. Two popular standards of measure for color contrast are the Web Content Accessibility Guidelines (WCAG) and the Accessible Perceptual Contrast Algorithm (APCA). Use standard contrast calculators to ensure your UI meets acceptable levels. Accessibility Inspector uses the following values from WCAG Level AA as guidance in determining whether your app's colors have an acceptable contrast.

Text size

	

Text weight

	

Minimum contrast ratio




Up to 17 pts

	

All

	

4.5:1




18 pts

	

All

	

3:1




All

	

Bold

	

3:1

If your app doesn't provide this minimum contrast by default, ensure it at least provides a higher contrast color scheme when the system setting Increase Contrast is turned on. If your app supports Dark Mode, make sure to check the minimum contrast in both light and dark appearances.

A button with insufficient color contrast

A button with sufficient color contrast

Prefer system-defined colors. These colors have their own accessible variants that automatically adapt when people adjust their color preferences, such as enabling Increase Contrast or toggling between the light and dark appearances. For guidance, see Color.

The systemRed default color in iOS

The systemRed accessible color in iOS

Convey information with more than color alone. Some people have trouble differentiating between certain colors and shades. For example, people who are color blind may have particular difficulty with pairings such as red-green and blue-orange. Offer visual indicators, like distinct shapes or icons, in addition to color to help people perceive differences in function and changes in state. Consider allowing people to customize color schemes such as chart colors or game characters so they can personalize your interface in a way that's comfortable for them.

For someone with red-green color blindness, these indicators might appear the same.

Both visual indicators and color help differentiate between indicators.

Describe your app's interface and content for VoiceOver. VoiceOver is a screen reader that lets people experience your app's interface without needing to see the screen. For more guidance, see VoiceOver.

Hearing

The people who use your interface may be deaf or hard of hearing. They may also be in noisy or public environments.

Support text-based ways to enjoy audio and video. It's important that dialogue and crucial information about your app or game isn't communicated through audio alone. Depending on the context, give people different text-based ways to experience their media, and allow people to customize the visual presentation of that text:

Captions give people the textual equivalent of audible information in video or audio-only content. Captions are great for scenarios like game cutscenes and video clips where text synchronizes live with the media.

Subtitles allow people to read live onscreen dialogue in their preferred language. Subtitles are great for TV shows and movies.

Audio descriptions are interspersed between natural pauses in the main audio of a video and supply spoken narration of important information that's presented only visually.

Transcripts provide a complete textual description of a video, covering both audible and visual information. Transcripts are great for longer-form media like podcasts and audiobooks where people may want to review content as a whole or highlight the transcript as media is playing.

For developer guidance, see Selecting Subtitles and Alternative Audio Tracks.

Use haptics in addition to audio cues. If your interface conveys information through audio cues — such as a success chime, error sound, or game feedback — consider pairing that sound with matching haptics for people who can't perceive the audio or have their audio turned off. In iOS and iPadOS, you can also use Music Haptics and Audio graphs to let people experience music and infographics through vibration and texture. For guidance, see Playing haptics.

Augment audio cues with visual cues. This is especially important for games and spatial apps where important content might be taking place off screen. When using audio to guide people towards a specific action, also add in visual indicators that point to where you want people to interact.

Mobility

Ensure your interface offers a comfortable experience for people with limited dexterity or mobility.

Offer sufficiently sized controls. Controls that are too small are hard for many people to interact with and select. Strive to meet the recommended minimum control size for each platform to ensure controls and menus are comfortable for all when tapping and clicking.

Platform

	

Default control size

	

Minimum control size




iOS, iPadOS

	

44x44 pt

	

28x28 pt




macOS

	

28x28 pt

	

20x20 pt




tvOS

	

66x66 pt

	

56x56 pt




visionOS

	

60x60 pt

	

28x28 pt




watchOS

	

44x44 pt

	

28x28 pt

Consider spacing between controls as important as size. Include enough padding between elements to reduce the chance that someone taps the wrong control. In general, it works well to add about 12 points of padding around elements that include a bezel. For elements without a bezel, about 24 points of padding works well around the element's visible edges.

Elements with insufficient padding

Elements with sufficient padding

Support simple gestures for common interactions. For many people, with or without disabilities, complex gestures can be challenging. For interactions people do frequently in your app or game, use the simplest gesture possible — avoid custom multifinger and multihand gestures — so repetitive actions are both comfortable and easy to remember.

Offer alternatives to gestures. Make sure your UI's core functionality is accessible through more than one type of physical interaction. Gestures can be less comfortable for people who have limited dexterity, so offer onscreen ways to achieve the same outcome. For example, if you use a swipe gesture to dismiss a view, also make a button available so people can tap or use an assistive device.

Edit and tap to delete

Swipe to delete

Let people use Voice Control to give guidance and enter information verbally. With Voice Control, people can interact with their devices entirely by speaking commands. They can perform gestures, interact with screen elements, dictate and edit text, and more. To ensure a smooth experience, label interface elements appropriately. For developer guidance, see Voice Control.

Integrate with Siri and Shortcuts to let people perform tasks using voice alone. When your app supports Siri and Shortcuts, people can automate the important and repetitive tasks they perform regularly. They can initiate these tasks from Siri, the Action button on their iPhone or Apple Watch, and shortcuts on their Home Screen or in Control Center. For guidance, see Siri.

Support mobility-related assistive technologies. Features like VoiceOver, AssistiveTouch, Full Keyboard Access, Pointer Control, and Switch Control offer alternative ways for people with low mobility to interact with their devices. Conduct testing and verify that your app or game supports these technologies, and that your interface elements are appropriately labeled to ensure a great experience. For more information, see Performing accessibility testing for your app.

Speech

Apple's accessibility features help people with speech disabilities and people who prefer text-based interactions to communicate effectively using their devices.

Let people use the keyboard alone to navigate and interact with your app. People can turn on Full Keyboard Access to navigate apps using their physical keyboard. The system also defines accessibility keyboard shortcuts and a wide range of other keyboard shortcuts that many people use all the time. Avoid overriding system-defined keyboard shortcuts and evaluate your app to ensure it works well with Full Keyboard Access. For additional guidance, see Keyboards. For developer guidance, see Support Full Keyboard Access in your iOS app.

Support Switch Control. Switch Control is an assistive technology that lets people control their devices through separate hardware, game controllers, or sounds such as a click or a pop. People can perform actions like selecting, tapping, typing, and drawing when your app or game supports the ability to navigate using Switch Control. For developer guidance, see Switch Control.

Cognitive

When you minimize complexity in your app or game, all people benefit.

Keep actions simple and intuitive. Ensure that people can navigate your interface using easy-to-remember and consistent interactions. Prefer system gestures and behaviors people are already familiar with over creating custom gestures people must learn and retain.

Minimize use of time-boxed interface elements. Views and controls that auto-dismiss on a timer can be problematic for people who need longer to process information, and for people who use assistive technologies that require more time to traverse the interface. Prefer dismissing views with an explicit action.

Consider offering difficulty accommodations in games. Everyone has their own way of playing and enjoying games. To support a variety of cognitive abilities, consider adding the ability to customize the difficulty level of your game, such as offering options for people to reduce the criteria for successfully completing a level, adjust reaction time, or enable control assistance.

Let people control audio and video playback. Avoid autoplaying audio and video content without also providing controls to start and stop it. Make sure these controls are discoverable and easy to act upon, and consider global settings that let people opt out of auto-playing all audio and video. For developer guidance, see Animated images and isVideoAutoplayEnabled.

Allow people to opt out of flashing lights in video playback. People might want to avoid bright, frequent flashes of light in the media they consume. A Dim Flashing Lights setting allows the system to calculate, mitigate, and inform people about flashing lights in a piece of media. If your app supports video playback, ensure that it responds appropriately to the Dim Flashing Lights setting. For developer guidance, see Flashing lights.

Be cautious with fast-moving and blinking animations. When you use these effects in excess, it can be distracting, cause dizziness, and in some cases even result in epileptic episodes. People who are prone to these effects can turn on the Reduce Motion accessibility setting. When this setting is active, ensure your app or game responds by reducing automatic and repetitive animations, including zooming, scaling, and peripheral motion. Other best practices for reducing motion include:

Tightening animation springs to reduce bounce effects

Tracking animations directly with people's gestures

Avoiding animating depth changes in z-axis layers

Replacing transitions in x-, y-, and z-axes with fades to avoid motion

Avoiding animating into and out of blurs

Optimize your app's UI for Assistive Access. Assistive Access is an accessibility feature in iOS and iPadOS that allows people with cognitive disabilities to use a streamlined version of your app. Assistive Access sets a default layout and control presentation for apps that reduces cognitive load, such as the following layout of the Camera app.

To optimize your app for this mode, use the following guidelines when Assistive Access is turned on:

Identify the core functionality of your app and consider removing noncritical workflows and UI elements.

Break up multistep workflows so people can focus on a single interaction per screen.

Always ask for confirmation twice whenever people perform an action that's difficult to recover from, such a deleting a file.

For developer guidance, see Assistive Access.

Platform considerations

No additional considerations for iOS, iPadOS, macOS, tvOS, or watchOS.

visionOS

visionOS offers a variety of accessibility features people can use to interact with their surroundings in ways that are comfortable and work best for them, including head and hand Pointer Control, and a Zoom feature.

Pointer Control (hand)

Pointer Control (head)

Zoom

Prioritize comfort. The immersive nature of visionOS means that interfaces, animations, and interactions have a greater chance of causing motion sickness, and visual and ergonomic discomfort for people. To ensure the most comfortable experience, consider these tips:

Keep interface elements within a person's field of view. Prefer horizontal layouts to vertical ones that might cause neck strain, and avoid demanding the viewer's attention in different locations in quick succession.

Reduce the speed and intensity of animated objects, particularly in someone's peripheral vision.

Be gentle with camera and video motion, and avoid situations where someone may feel like the world around them is moving without their control.

Avoid anchoring content to the wearer's head, which may make them feel stuck and confined, and also prevent them from using assistive technologies like Pointer Control.

Minimize the need for large and repetitive gestures, as these can become tiresome and may be difficult depending on a person's surroundings.

For additional guidance, see Create accessible spatial experiences and Design considerations for vision and motion.

Resources

Related

Inclusion

Typography

VoiceOver

Developer documentation

Building accessible apps

Accessibility framework

Overview of Accessibility Nutrition Labels

Videos

Principles of inclusive app design

Evaluate your app for Accessibility Nutrition Labels

Catch up on accessibility in SwiftUI

Change log

Date

	

Changes




June 9, 2025

	

Added guidance and links for Assistive Access, Switch Control, and Accessibility Nutrition Labels.




March 7, 2025

	

Expanded and refined all guidance. Moved Dynamic Type guidance to the Typography page, and moved VoiceOver guidance to a new VoiceOver page.




June 10, 2024

	

Added a link to Apple's Unity plug-ins for supporting Dynamic Type.




December 5, 2023

	

Updated visionOS Zoom lens artwork.




June 21, 2023

	

Updated to include guidance for visionOS.

Current page is Accessibility

## Detailed Sections

### Quick Links

DownloadsDocumentationSample CodeVideosForums
5 Quick Links


## Vision

The people who use your interface may be blind, color blind, or have low vision or light sensitivity. They may also be in situations where lighting conditions and screen brightness affect their ability to interact with your interface.
Support larger text sizes. Make sure people can adjust the size of your text or icons to make them more legible, visible, and comfortable to read. Ideally, give people the option to enlarge text by at least 200 percent (or 140 percent in watchOS apps). Your interface can support font size enlargement either through custom UI, or by adopting Dynamic Type. Dynamic Type is a systemwide setting that lets people adjust the size of text for comfort and legibility. For more guidance, see Supporting Dynamic Type.
Use recommended defaults for custom type sizes. Each platform has different default and minimum sizes for system-defined type styles to promote readability. If you're using custom type styles, follow the recommended defaults.
PlatformDefault sizeMinimum sizeiOS, iPadOS17 pt11 ptmacOS13 pt10 pttvOS29 pt23 ptvisionOS17 pt12 ptwatchOS16 pt12 pt
Bear in mind that font weight can also impact how easy text is to read. If you're using a custom font with a thin weight, aim for larger than the recommended sizes to increase legibility. For more guidance, see Typography.
Thicker weights are easier to read for smaller font sizes.Consider increasing the font size when using a thin weight.
Strive to meet color contrast minimum standards. To ensure all information in your app is legible, it's important that there's enough contrast between foreground text and icons and background colors. Two popular standards of measure for color contrast are the Web Content Accessibility Guidelines (WCAG) and the Accessible Perceptual Contrast Algorithm (APCA). Use standard contrast calculators to ensure your UI meets acceptable levels. Accessibility Inspector uses the following values from WCAG Level AA as guidance in determining whether your app's colors have an acceptable contrast.
Text sizeText weightMinimum contrast ratioUp to 17 ptsAll4.5:118 ptsAll3:1AllBold3:1
If your app doesn't provide this minimum contrast by default, ensure it at least provides a higher contrast color scheme when the system setting Increase Contrast is turned on. If your app supports Dark Mode, make sure to check the minimum contrast in both light and dark appearances.
A button with insufficient color contrastA button with sufficient color contrast
Prefer system-defined colors. These colors have their own accessible variants that automatically adapt when people adjust their color preferences, such as enabling Increase Contrast or toggling between the light and dark appearances. For guidance, see Color.
The systemRed default color in iOSThe systemRed accessible color in iOS
Convey information with more than color alone. Some people have trouble differentiating between certain colors and shades. For example, people who are color blind may have particular difficulty with pairings such as red-green and blue-orange. Offer visual indicators, like distinct shapes or icons, in addition to color to help people perceive differences in function and changes in state. Consider allowing people to customize color schemes such as chart colors or game characters so they can personalize your interface in a way that's comfortable for them.
For someone with red-green color blindness, these indicators might appear the same.Both visual indicators and color help differentiate between indicators.
Describe your app's interface and content for VoiceOver. VoiceOver is a screen reader that lets people experience your app's interface without needing to see the screen. For more guidance, see VoiceOver.


## Hearing

The people who use your interface may be deaf or hard of hearing. They may also be in noisy or public environments.
Support text-based ways to enjoy audio and video. It's important that dialogue and crucial information about your app or game isn't communicated through audio alone. Depending on the context, give people different text-based ways to experience their media, and allow people to customize the visual presentation of that text:
Captions give people the textual equivalent of audible information in video or audio-only content. Captions are great for scenarios like game cutscenes and video clips where text synchronizes live with the media.Subtitles allow people to read live onscreen dialogue in their preferred language. Subtitles are great for TV shows and movies.Audio descriptions are interspersed between natural pauses in the main audio of a video and supply spoken narration of important information that's presented only visually.Transcripts provide a complete textual description of a video, covering both audible and visual information. Transcripts are great for longer-form media like podcasts and audiobooks where people may want to review content as a whole or highlight the transcript as media is playing.
For developer guidance, see Selecting Subtitles and Alternative Audio Tracks.
Use haptics in addition to audio cues. If your interface conveys information through audio cues — such as a success chime, error sound, or game feedback — consider pairing that sound with matching haptics for people who can't perceive the audio or have their audio turned off. In iOS and iPadOS, you can also use Music Haptics and Audio graphs to let people experience music and infographics through vibration and texture. For guidance, see Playing haptics.
Augment audio cues with visual cues. This is especially important for games and spatial apps where important content might be taking place off screen. When using audio to guide people towards a specific action, also add in visual indicators that point to where you want people to interact.


## Mobility

Ensure your interface offers a comfortable experience for people with limited dexterity or mobility.
Offer sufficiently sized controls. Controls that are too small are hard for many people to interact with and select. Strive to meet the recommended minimum control size for each platform to ensure controls and menus are comfortable for all when tapping and clicking.
PlatformDefault control sizeMinimum control sizeiOS, iPadOS44x44 pt28x28 ptmacOS28x28 pt20x20 pttvOS66x66 pt56x56 ptvisionOS60x60 pt28x28 ptwatchOS44x44 pt28x28 pt
Consider spacing between controls as important as size. Include enough padding between elements to reduce the chance that someone taps the wrong control. In general, it works well to add about 12 points of padding around elements that include a bezel. For elements without a bezel, about 24 points of padding works well around the element's visible edges.
Elements with insufficient paddingElements with sufficient padding
Support simple gestures for common interactions. For many people, with or without disabilities, complex gestures can be challenging. For interactions people do frequently in your app or game, use the simplest gesture possible — avoid custom multifinger and multihand gestures — so repetitive actions are both comfortable and easy to remember.
Offer alternatives to gestures. Make sure your UI's core functionality is accessible through more than one type of physical interaction. Gestures can be less comfortable for people who have limited dexterity, so offer onscreen ways to achieve the same outcome. For example, if you use a swipe gesture to dismiss a view, also make a button available so people can tap or use an assistive device.
Edit and tap to deleteSwipe to delete
Let people use Voice Control to give guidance and enter information verbally. With Voice Control, people can interact with their devices entirely by speaking commands. They can perform gestures, interact with screen elements, dictate and edit text, and more. To ensure a smooth experience, label interface elements appropriately. For developer guidance, see Voice Control.
Integrate with Siri and Shortcuts to let people perform tasks using voice alone. When your app supports Siri and Shortcuts, people can automate the important and repetitive tasks they perform regularly. They can initiate these tasks from Siri, the Action button on their iPhone or Apple Watch, and shortcuts on their Home Screen or in Control Center. For guidance, see Siri.
Support mobility-related assistive technologies. Features like VoiceOver, AssistiveTouch, Full Keyboard Access, Pointer Control, and Switch Control offer alternative ways for people with low mobility to interact with their devices. Conduct testing and verify that your app or game supports these technologies, and that your interface elements are appropriately labeled to ensure a great experience. For more information, see Performing accessibility testing for your app.


## Speech

Apple's accessibility features help people with speech disabilities and people who prefer text-based interactions to communicate effectively using their devices.
Let people use the keyboard alone to navigate and interact with your app. People can turn on Full Keyboard Access to navigate apps using their physical keyboard. The system also defines accessibility keyboard shortcuts and a wide range of other keyboard shortcuts that many people use all the time. Avoid overriding system-defined keyboard shortcuts and evaluate your app to ensure it works well with Full Keyboard Access. For additional guidance, see Keyboards. For developer guidance, see Support Full Keyboard Access in your iOS app.
Support Switch Control. Switch Control is an assistive technology that lets people control their devices through separate hardware, game controllers, or sounds such as a click or a pop. People can perform actions like selecting, tapping, typing, and drawing when your app or game supports the ability to navigate using Switch Control. For developer guidance, see Switch Control.


## Cognitive

When you minimize complexity in your app or game, all people benefit.
Keep actions simple and intuitive. Ensure that people can navigate your interface using easy-to-remember and consistent interactions. Prefer system gestures and behaviors people are already familiar with over creating custom gestures people must learn and retain.
Minimize use of time-boxed interface elements. Views and controls that auto-dismiss on a timer can be problematic for people who need longer to process information, and for people who use assistive technologies that require more time to traverse the interface. Prefer dismissing views with an explicit action.
Consider offering difficulty accommodations in games. Everyone has their own way of playing and enjoying games. To support a variety of cognitive abilities, consider adding the ability to customize the difficulty level of your game, such as offering options for people to reduce the criteria for successfully completing a level, adjust reaction time, or enable control assistance.
Let people control audio and video playback. Avoid autoplaying audio and video content without also providing controls to start and stop it. Make sure these controls are discoverable and easy to act upon, and consider global settings that let people opt out of auto-playing all audio and video. For developer guidance, see Animated images and isVideoAutoplayEnabled.
Allow people to opt out of flashing lights in video playback. People might want to avoid bright, frequent flashes of light in the media they consume. A Dim Flashing Lights setting allows the system to calculate, mitigate, and inform people about flashing lights in a piece of media. If your app supports video playback, ensure that it responds appropriately to the Dim Flashing Lights setting. For developer guidance, see Flashing lights.
Be cautious with fast-moving and blinking animations. When you use these effects in excess, it can be distracting, cause dizziness, and in some cases even result in epileptic episodes. People who are prone to these effects can turn on the Reduce Motion accessibility setting. When this setting is active, ensure your app or game responds by reducing automatic and repetitive animations, including zooming, scaling, and peripheral motion. Other best practices for reducing motion include:
Tightening animation springs to reduce bounce effectsTracking animations directly with people's gesturesAvoiding animating depth changes in z-axis layersReplacing transitions in x-, y-, and z-axes with fades to avoid motionAvoiding animating into and out of blurs
Optimize your app's UI for Assistive Access. Assistive Access is an accessibility feature in iOS and iPadOS that allows people with cognitive disabilities to use a streamlined version of your app. Assistive Access sets a default layout and control presentation for apps that reduces cognitive load, such as the following layout of the Camera app.
To optimize your app for this mode, use the following guidelines when Assistive Access is turned on:
Identify the core functionality of your app and consider removing noncritical workflows and UI elements.Break up multistep workflows so people can focus on a single interaction per screen.Always ask for confirmation twice whenever people perform an action that's difficult to recover from, such a deleting a file.
For developer guidance, see Assistive Access.


## Platform considerations

No additional considerations for iOS, iPadOS, macOS, tvOS, or watchOS.


### visionOS

visionOS offers a variety of accessibility features people can use to interact with their surroundings in ways that are comfortable and work best for them, including head and hand Pointer Control, and a Zoom feature.
Pointer Control (hand)  Pointer Control (head)  Zoom  Video with custom controls.  Content description: A recording of a person's hand using Pointer Control to interact with content in an app's visionOS window. A line with a pointer at the end extends from the person's hand. It changes position within the field of view as the person moves their hand.  Play  Video with custom controls.  Content description: A recording of someone using Pointer Control to interact with content in an app's visionOS window. The person isn't visible in the recording. Only the pointer is visible. It's centered in the field of view, and the person uses their head movement to position content beneath the pointer.  Play
Prioritize comfort. The immersive nature of visionOS means that interfaces, animations, and interactions have a greater chance of causing motion sickness, and visual and ergonomic discomfort for people. To ensure the most comfortable experience, consider these tips:
Keep interface elements within a person's field of view. Prefer horizontal layouts to vertical ones that might cause neck strain, and avoid demanding the viewer's attention in different locations in quick succession.Reduce the speed and intensity of animated objects, particularly in someone's peripheral vision.Be gentle with camera and video motion, and avoid situations where someone may feel like the world around them is moving without their control.Avoid anchoring content to the wearer's head, which may make them feel stuck and confined, and also prevent them from using assistive technologies like Pointer Control.Minimize the need for large and repetitive gestures, as these can become tiresome and may be difficult depending on a person's surroundings.
For additional guidance, see Create accessible spatial experiences and Design considerations for vision and motion.


#### Related

Inclusion
Typography
VoiceOver


#### Developer documentation

Building accessible apps
Accessibility framework
Overview of Accessibility Nutrition Labels


#### Videos

Principles of inclusive app design  Evaluate your app for Accessibility Nutrition Labels  Catch up on accessibility in SwiftUI


## Change log

DateChangesJune 9, 2025Added guidance and links for Assistive Access, Switch Control, and Accessibility Nutrition Labels.March 7, 2025Expanded and refined all guidance. Moved Dynamic Type guidance to the Typography page, and moved VoiceOver guidance to a new VoiceOver page.June 10, 2024Added a link to Apple's Unity plug-ins for supporting Dynamic Type.December 5, 2023Updated visionOS Zoom lens artwork.June 21, 2023Updated to include guidance for visionOS.


### Platforms

Toggle Menu
iOSiPadOSmacOStvOSvisionOSwatchOS


### Tools

Toggle Menu
SwiftSwiftUISwift PlaygroundTestFlightXcodeXcode CloudSF Symbols


### Topics & Technologies

Toggle Menu
AccessibilityAccessoriesApp ExtensionApp StoreAudio & VideoAugmented RealityDesignDistributionEducationFontsGamesHealth & FitnessIn-App PurchaseLocalizationMaps & LocationMachine Learning & AIOpen SourceSecuritySafari & Web


### Resources

Toggle Menu
DocumentationTutorialsDownloadsForumsVideos


### Support

Toggle Menu
Support ArticlesContact UsBug ReportingSystem Status


### Account

Toggle Menu
Apple DeveloperApp Store ConnectCertificates, IDs, & ProfilesFeedback Assistant


### Programs

Toggle Menu
Apple Developer ProgramApple Developer Enterprise ProgramApp Store Small Business ProgramMFi ProgramNews Partner ProgramVideo Partner ProgramSecurity Bounty ProgramSecurity Research Device Program


### Events

Toggle Menu
Meet with AppleApple Developer CentersApp Store AwardsApple Design AwardsApple Developer AcademiesWWDC
--- END FILE ---

--- FILE: SwiftUI-Accessibility-beond-the-basics.md ---
Bass music playing ♪  ♪ Nathan Tannar: Hello, and welcome to WWDC! My name is Nathan, and I'm an engineer on the Accessibility team.

Today we'll be going beyond the basics to learn how to deliver exceptional and accessible SwiftUI apps.

This year marks a huge leap forward for accessibility in SwiftUI.

At Apple, accessibility is one of our core values.

Our assistive technologies across all our platforms make sure that anyone can use your app regardless of any physical, visual, audible, or motor impairment.

My team and I work to make sure most of your app is accessible by default, but there is always more you can do to enrich the experience.

Today I'll show you the new tools and APIs for SwiftUI that make enriching this experience easy.

Let's begin with the tooling improvements in Xcode.

SwiftUI Previews have changed how many of us develop apps.

It dramatically improves your ability to iterate upon your views across multiple environments, all without the need of running your app.

To make the most important accessibility modifiers just a click away, we've added a curated list of accessibility editors.

I hope this encourages everyone to always make their views accessible.

But there's more.

Since accessibility modifiers don't have visual changes in the previews, a new tool was developed that allows you to inspect the accessibility of your view without leaving Xcode.

Let's switch from the editor's panel to the new accessibility panel.

Shipping in Xcode 13, SwiftUI Previews will now also feature an Accessibility Preview.

With it, you can inspect the accessibility elements for a preview in real time.

And this is a game changer.

Accessibility Preview will help you make accessible apps even if you don't have a deep understanding of each assistive technology.

Let's take a closer look to see how changes are reflected in the Accessibility Preview.

This is a simplified version of the view we just saw.

After running the preview, I can select the VStack and the Accessibility Preview will update to display the elements in their sorted order.

Notice that each element will always display its basic properties -- such as a label and traits.

For example, the Text view will create an accessibility element with the string as its label.

It also gains the .isStaticText trait.

The preview will update for any accessibility changes we make, such as adding the .isHeader trait.

You will also be able to see some of the automatic accessibility that takes place behind the scenes, such as automatic SF Symbol labels.

For example, the checkmark.seal.fill symbol is labeled "Verified" by default.

If you're relying on a symbol's default label, it's important to check that it accurately describes your interface.

We'll continue to use the Accessibility Preview as we step through five importance areas that'll help you deliver an exceptional experience to all of your app's users.

We'll start by examining the best way to make custom controls accessible.

Next, we'll discuss how to make a view accessible with children.

I'll highlight how to audit your app for common navigation problems and how the Accessibility Preview can assist with this.

Then I'll show you how to supercharge your app's navigation with VoiceOver rotors.

And finally, we'll look at focus and how it relates to assistive technologies.

I've been working to prototype a new finance app I call Wallet Pal.

It's still in the early stages, but so far, I'm pretty happy with the initial design.

I was pleased to hear that early beta testers are also loving it.

Now that I've polished the UI, I should spend some time to polish the accessibility interface.

The accessibility interface compliments the visual experience to make sure that it’s usable by everyone.

I've asked some VoiceOver users to help test Wallet Pal and I've heard that the app is hard to navigate and not fully accessible.

If parts are not accessible to VoiceOver, then they are also not accessible to other assistive technologies.

It's important that anyone be able to use Wallet Pal, so let's investigate to see where we can improve the experience.

We'll begin with reports of users not being able to edit their budgets, a critical feature in Wallet Pal.

This is the Budget Planner view which allows users to edit their food, entertainment, and savings budgets.

To fit the design of Wallet Pal, I ended up needing to create custom sliders.

```swift
struct BudgetSlider: View {
    @Binding var value: Double
    var label: String

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text(label)
                Text(value.toDollars()).bold()
            }
            SliderShape(value: value)
                .gesture(DragGesture().onChanged(handle))
                .accessibilityRepresentation {
                    Slider(value: $value, in: 0...1) {
                        Text(label)
                    }
                    .accessibilityValue(value.toDollars())
                }
        }
    }
}

struct SliderShape: View {
    var value: Double

    private struct BackgroundTrack: View {
        var cornerRadius: CGFloat
        var body: some View {
            RoundedRectangle(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(Color(white: 0.2))
        }
    }

    private struct OverlayTrack: View {
        var cornerRadius: CGFloat
        var body: some View {
            RoundedRectangle(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(Color(white: 0.95))
        }
    }

    private struct Knob: View {
        var cornerRadius: CGFloat
        var body: some View {
            RoundedRectangle(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .strokeBorder(Color(white: 0.7), lineWidth: 1)
            .shadow(radius: 3)
        }
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                BackgroundTrack(cornerRadius: geometry.size.height / 2)

                OverlayTrack(cornerRadius: geometry.size.height / 2)
                    .frame(
                        width: max(geometry.size.height, geometry.size.width * CGFloat(value) + geometry.size.height / 2),
                        height: geometry.size.height)

                Knob(cornerRadius: geometry.size.height / 2)
                    .frame(
                        width: geometry.size.height,
                        height: geometry.size.height)
                    .offset(x: max(0, geometry.size.width * CGFloat(value) - geometry.size.height / 2), y: 0)
            }
        }
    }
}

extension Double {
    func toDollars() -> String {
        return "$\(Int(self))"
    }
}
```

This must be why some users are not able to edit their budgets.

We can confirm it's not accessible by running a SwiftUI preview and selecting the SliderShape.

The Accessibility Preview shows that there are no elements, so this control is not accessible.

Ideally, we should have a single labeled accessibility element with a value that can be changed.

In contrast, standard controls are accessible by default, meaning little to no extra effort is required to provide a great experience.

SwiftUI uses the view type and its initialization parameters to automatically derive the accessibility element's label, value, traits, and actions.

So what's the best way to make our custom budget slider accessible? Since the standard slider is accessible by default, my team and I thought it would be great to have an API that allows the accessibility of one view to be represented by another.

This is what led us to us to create accessibilityRepresentation(representation:).

It's an API that allows the accessibility of one view to be defined by another.

Since I want this to be perceived by assistive technologies as a slider, that's what I'll use for the accessibility representation.

With accessibilityRepresentation(representation:), we're now well on the way to making this budget slider accessible.

The only change needed to improve the experience of the slider is to describe the value in dollars.

And great, just like that, now our budget slider is perfectly accessible.

On macOS, the type of control will also be spoken to VoiceOver users.

So by using the slider view in our budget slider's representation, it will be announced as a slider.

It's recommended to use accessibilityRepresentation(representation:) when possible, to make custom controls accessible.

This is just one way to use accessibilityRepresentation(representation:).

Its flexibility allows for many more creative uses.

Let's see if we can use it to fix other accessibility bugs in our app.

While we have now fixed the functional ability to edit budgets, some users reported that they couldn't discover how to navigate to the Budget Planner view.

When designing Wallet Pal, we decided to use SF Symbols for all of our buttons.

While SF Symbols may have great default accessibility labels, they may not always fit the intended use case.

Let's investigate if the problem is a poorly labeled button.

The NavigationBarView contains the Edit Budgets button.

Since we rely on SF Symbols for so many of our buttons, I created a custom buttonStyle called SymbolButtonStyle.

But it appears that despite initializing the button with the label "Edit Budgets", the label for the button is slider.vertical.3.

So the accessibility label is being derived from the SF Symbol.

Let's take a closer look at the SymbolButtonStyle.

The SymbolButtonStyle's makeBody(configuration:) method returns an Image view.

The Edit Budgets string we initialize the button with would create a Text view as the configuration's label.

But this style completely ignores the configuration's label.

This is why the button is not labeled "Edit Budgets".

While we want an SF Symbol to appear visually, we want the accessibility of the button to be represented by the configuration's label.

And so this seems like a great use case for accessibilityRepresentation(representation:).

Using accessibilityRepresentation(representation:), I can substitute the accessibility of the Image view with another view, in this case, the configuration's label.

This way, we can preserve the label we used to create the button.

accessibilityRepresentation(representation:) is not just the ideal and recommended way to make custom controls accessible, it also opens up new creative possibilities to make views accessible.

Next, let's discuss the relationship between children and accessibility containers.

As you may recall, accessibility elements can be wrapped together in a group as children of an accessibility container.

This is done with the accessibilityElement(children:) modifier and the contain child behavior.

In case you're unfamiliar, the contain child behavior can be used to create an accessibility container, which wraps existing accessibility elements as children.

But what if instead you have an accessibility element and you want to set its children? I'm running into this case when trying to make the Budget History graph accessible.

Users reported the graph is completely inaccessible.

And so this means when assistive technologies are focused on the Budget History header and try to navigate to the next element, they end up at the Alerts header.

VoiceOver users would not even know that this graph exists.

I built the graph using the new Canvas view.

Canvas makes it easier to draw a collection of shapes.

For more on Canvas, please check out Jacob's presentation on how it can be used to add rich graphics to your app.

Canvas draws a collection of shapes and just like we saw with BudgetSlider, shapes are not accessible by default.

All users need to be able to view their budget history, so let's make this accessible for everyone.

Starting with the basics, let's give our Canvas a label.

This will automatically create a new accessibility element for the Canvas and assign its label.

Now, I'd like each bar in the graph to be represented by their own accessibility element.

This is a use case where we have an accessibility element and want to provide its children.

To do this, I'll use the new accessibilityChildren(children:) modifier.

This will transform the accessibility element into an accessibility container, preserving other accessibility properties, such as the label.

The modifier takes a ViewBuilder, which allows us to set new views as children of the accessibility container.

Recall that our Budget History graph is drawing a horizontal bar graph, so we'll use an HStack and return a view for each budget.

I'll use a Rectangle for each accessibility element so that the frame will fill all available vertical space.

This will make each accessibility element's frame bigger than what's displayed visually, and that's OK.

Having a large but consistent frame will make it easier to navigate on iOS when VoiceOver users drag their finger across the screen to scan for accessibility elements.

If I select the HStack from within the accessibilityChildren(children:) modifier, the Accessibility Preview confirms that an element has been created for each bar in the graph.

These will all be accessible as children of the Canvas accessibility container.

With these changes, the Budget History graph is now completely accessible, and assistive technologies can navigate through each bar in the graph.

Notice that the frame for each element is the same, which is ideal.

For more complex charts, we have other ways of making them accessible.

For that, please check out Preston's presentation on bringing accessibility to charts.

But with accessibility children, the accessibility elements of a view can differ from what's presented visually, allowing you to tailor a great experience.

But accessibility children can also be used to compose the accessibility with the help of the combine behavior.

As a quick refresh, the combine child behavior will merge properties from multiple accessibility elements into a new or existing accessibility element.

But with the addition of the accessibility children API, it can now also be used to compose accessibility in a generic way.

With accessibility representation, the original accessibility is completely replaced.

This means no composition can take place; whereas accessibility children is additive.

This means you could later combine the children to merge their properties into the original element.

This is a more advanced use case of the accessibilityChildren(children:) modifier, but it's a functionality I wanted to highlight.

Examples are featured in this presentation's Accessibility Catalog Sample Project.

I hope to see many of you explore what's possible with this kind of composition.

accessibilityChildren(children:) gives you control over the children of a container.

And with that, complex graphs drawn with Canvas can be made accessible with modifiers and views you're already familiar with.

And with the combine child behavior, the accessibility of a single view can be composed of many.

Now that we've learned how to make individual components of our app accessible, we can start putting things together to refine the navigation experience.

I've heard that navigating Wallet Pal with VoiceOver is confusing and difficult.

So we have some more work to do if we want to deliver a great accessible app.

Let's take a closer look at the Friends carousel at the top.

While I don't have this feature built yet, I plan to add some kind of gamification to Wallet Pal.

So I've added a challenge button at the top left of each friend view.

We already fixed the SymbolButtonStyle, so the challenge button will be properly labeled now.

But since users are reporting that navigation is confusing, are there other issues? To answer that, we must first understand how assistive technologies will navigate Wallet Pal.

By default, accessibility elements are sorted based off their geometric position in relation to other elements, from top left to bottom right.

This means that without accessibility containers to differentiate the content, VoiceOver would navigate through each of the challenge buttons, then the Image and Add Friend button, and finally, the text with the user's name.

A great feature of the Accessibility Preview is that it shows accessibility elements in their sorted order.

This makes it easy to visualize how assistive technologies will navigate right from within Xcode.

As expected, the sorted order matches what we previously saw.

And this order would certainly be confusing to navigate.

Now there are multiple ways we could fix the sort order of the accessibility elements.

One thing we could do is to introduce accessibility containers.

I'll add the accessibilityElement(children:) modifier with the contain behavior.

This will wrap the accessibility elements of each FriendCellView in an accessibility container.

This fixes the navigation order, because children of an accessibility container are navigated before moving to the next accessibility element.

With this change, VoiceOver will navigate through the children of the accessibility container before moving to the next accessibility element.

And so we achieve a much more desirable navigation order.

But could we do better to improve this experience? One problem is that the challenge button is navigated to before knowing who the user is.

A VoiceOver user would want to know the name of the user before sending a challenge, so this button should really be sorted last.

We can use the accessibilitySortPriority(_:) modifier to fix this.

accessibilitySortPriority(_:) can be used to change the order of elements within an accessibility container.

An element with a higher priority will be sorted first, whereas a lower priority will be sorted last.

Elements with equal priorities are then sorted based off their geometric positioning.

I'll add the accessibilitySortPriority(_:) modifier to the challenge button to improve the navigation order.

I'll use a priority of -1 since the default is 0, to force the sort order of the challenge button to be last.

Now the challenge button will be navigated to last.

This is a good improvement, since there is less chance a VoiceOver user would be confused as to who they are sending a challenge to, but it's still not great.

Rather than wrapping each FriendCellView in an accessibility container, we could combine the children into a single element.

```swift
struct User: Identifiable {
    var id: Int
    var name: String
    var photo: String
}

struct FriendCellView: View {
    var user: User

    var body: some View {
        ZStack(alignment: .topLeading) {
            VStack(alignment: .center) {
                Image(user.photo)
                Text(user.name)
            }

            Button("Send Challenge", action: { /* ... */ })
                .buttonStyle(
                    SymbolButtonStyle(
                        systemName: "gamecontroller.fill"))
        }
    }
}
      
struct FriendsView: View {
    var users: [User]

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack {
                ForEach(users) { user in
                    FriendCellView(user: user)
                        .accessibilityElement(children: .combine)
                        .onTapGesture { /* ... */ }
                }

                AddFriendButton()

                Spacer()
            }
        }
    }
}
  
struct AddFriendButton: View {
    var body: some View {
        Button(action: { /* ... */ }) {
            Circle()
                .foregroundColor(Color(white: 0.9))
                .frame(width: 50, height: 50)
                .overlay(
                    Image(systemName: "plus")
                        .resizable()
                        .foregroundColor(Color(white: 0.5))
                        .padding(15)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct SymbolButtonStyle: ButtonStyle {
    let systemName: String

    func makeBody(configuration: Configuration) -> some View {
                Image(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

This too fixes the navigation order and reduces the number of accessibility elements. 

---

### AlertView implicit Rotor

And so this seems like a great use case for accessibilityRotorEntry.

```swift
struct Alert: Identifiable {
    var id: Int
    var isUnread: Bool
    var isFlagged: Bool
    var subject: String
    var content: String
}

struct AlertsView: View {
    var alerts: [Alert]

    var body: some View {
        VStack {
            ForEach(alerts) { alert in
                AlertCellView(alert: alert)
                    .accessibilityElement(children: .combine)
            }
        }
        .accessibilityElement(children: .contain)
        .accessibilityRotor("Warnings") {
            ForEach(alerts) { alert in
                if alert.isWarning {
                    AccessibilityRotorEntry(alert.title, id: alert.id)
                }
            }
        }
    }
}

struct AlertCell: View {
    var alert: Alert

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                if alert.isUnread {
                    Circle()
                        .foregroundColor(.blue)
                        .frame(width: 10, height: 10)
                }
                if alert.isFlagged {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundColor(.orange)
                        .frame(width: 10, height: 10)
                }
                Text(alert.subject)
                    .font(.headline)
                    .fontWeight(.semibold)
                Spacer()
                Text("04/30/21")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Text(alert.content)
                .lineLimit(3)
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .foregroundColor(Color(white: 0.9))
        )
    }
}
```

These will all be accessible as children of the Canvas accessibility container. 

---

### AlertView Explicit Rotor

The identity of a view is important to understand for accessibility rotors.

```swift
struct Alert: Identifiable {
    var id: Int
    var isUnread: Bool
    var isFlagged: Bool
    var subject: String
    var content: String
}

struct AlertsView: View {
    var alerts: [Alert]
    @Namespace var namespace

    var body: some View {
        VStack {
            ForEach(alerts) { alert in
                VStack {
                    AlertCellView(alert: alert)
                        .accessibilityElement(children: .combine)
                        .accessibilityRotorEntry(id: alert.id, in: namespace)
                    AlertActionsView(alert: alert)
                }
            }
        }
        .accessibilityElement(children: .contain)
        .accessibilityRotor("Warnings") {
            ForEach(alerts) { alert in
                if alert.isWarning {
                    AccessibilityRotorEntry(alert.title, id: alert.id, in: namespace)
                }
            }
        }
    }
}

struct AlertCell: View {
    var alert: Alert

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                if alert.isUnread {
                    Circle()
                        .foregroundColor(.blue)
                        .frame(width: 10, height: 10)
                }
                if alert.isFlagged {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundColor(.orange)
                        .frame(width: 10, height: 10)
                }
                Text(alert.subject)
                    .font(.headline)
                    .fontWeight(.semibold)
                Spacer()
                Text("04/30/21")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Text(alert.content)
                .lineLimit(3)
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .foregroundColor(Color(white: 0.9))
        )
    }
}
```

This simple case works elegantly because there is a single accessibility element -- due to the combine -- for the AlertCellView. 

---

### AlertNotifcationView

AccessibilityFocusState is the last piece you need.

```swift
struct Notification: Equatable {
    enum Priority {
        case low, high
    }
    var content: String
    var priority: Priority
}

struct AlertNotificationView<Content: View>: View {
    @ViewBuilder var content: Content
    @Binding var notification: Notification?
    @AccessibilityFocusState var isNotificationFocused: Bool

    var body: some View {
        ZStack(alignment: .top) {
            content

            if let notification = $notification {
                NotificationBanner(notification: notification)
                    .accessibilityFocused($isNotificationFocused)
            }
        }
        .onChange(of: notification) { notification in
            if notification?.priority == .high {
                isNotificationFocused = true
            } else {
                postAccessibilityNotification()
            }
        }
    }

    func postAccessibilityNotification() {
        guard let announcement = notification?.content else {
            return
        }
        #if os(macOS)
        NSAccessibility.post(
            element: NSApp.accessibilityWindow(),
            notification: .announcementRequested,
            userInfo: [.announcement: announcement])
        #else
        UIAccessibility.post(notification: .announcement, argument: announcement)
        #endif
    }
}

struct NotificationBanner: View {
    @Binding var notification: Notification?
    @State var timer: Timer?
    @AccessibilityFocusState var isNotificationFocused: Bool

    var body: some View {
        if let notification = notification {
            Text(notification.content)
                .accessibilityFocused($isNotificationFocused)
                .onAppear { startTimer() }
                .onDisappear { stopTimer() }
        } else {
            EmptyView()
        }
    }

    func startTimer() {
        timer = Timer.scheduledTimer(
            withTimeInterval: 3,
            repeats: true) { _ in
            if !isNotificationFocused {
                notification = nil
            }
        }
    }

    func stopTimer() {
        timer?.invalidate()
    }
}
```

With it, you can read and direct the focus of assistive technologies to create smooth transitions between views.
--- END FILE ---
=== END SWIFT DOCUMENTATION ===
=== END CONTEXT ===

=== BUILD ATTEMPT 3 FAILED ===
The previous implementation failed with the following errors:

Build failed but no detailed error log available.

=== INSTRUCTIONS FOR ATTEMPT 4 ===
1. Analyze what went wrong in the previous approach
2. Try a DIFFERENT approach or fix the specific issues
3. Do NOT repeat the same mistakes
4. If the same approach keeps failing, consider an alternative implementation strategy
5. Write the corrected code directly - do not explain, just implement

Please fix the issues and provide the corrected implementation.